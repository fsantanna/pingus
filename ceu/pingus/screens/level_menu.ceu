#ifndef _LEVELMENU_CEU
#define _LEVELMENU_CEU

#include "../../engine/display/sprite.ceu"
#include "../../engine/gui/surface_button.ceu"
#include "../components/wood.ceu"

native/pre do
    ##include "pingus/levelset.hpp"
    typedef std::vector<std::shared_ptr<Levelset>> Levelsets;
    struct LevelsetPrioritySorter {
        bool operator()(std::shared_ptr<Levelset> lhs, std::shared_ptr<Levelset> rhs) const {
            return lhs->get_priority() > rhs->get_priority();
        }
    };
    static std::shared_ptr<Levelset> current_levelset;
    static Levelsets levelsets;
end

#define LEVEL_ITEMS_PER_PAGE 10
#define LEVELSET_ITEMS_PER_PAGE 4

#define LEVEL_ITEM_HEIGHT 32
#define LEVELSET_ITEM_HEIGHT 95

////////////////////////////////////////////////////////////////////////////////

data ILevelUI with
    var   int item_at_top = 0;
    event int ok;
    event int go;
end

code/await LevelUI (var int items_total, var int items_per_page, var int item_height)
                    -> (var& ILevelUI levelui)
                        -> int
do
    var ILevelUI levelui_ = _;
    levelui = &levelui_;

    var int xc = {Display::get_width()}  / 2;
    var int yc = {Display::get_height()} / 2;

    spawn Wood();

    var Rect rect = val Rect(xc, yc, _,_);
    spawn Sprite_from_name(&rect, "core/menu/blackboard", false);

    var& IRectComponent cancel;
    var Rect cancel_r = val Rect(xc-300, yc+200, 0, 0);
    spawn SurfaceButton(&cancel_r,
                        "core/start/back",
                        "core/start/back_clicked",
                        "core/start/back_hover")
                            -> (&cancel);
    spawn do
        every SDL_REDRAW do
            call {Fonts::chalk_normal}.render(
                _origin_top_center,
                cancel_r.left + 55, cancel_r.top,
                __("Back"),
                *{Display::s_framebuffer}
            );
        end
    end

    var& IRectComponent prv;
    var Rect prv_r = val Rect(xc+280, yc-48-12, _,_);
    spawn SurfaceButton(&prv_r,
                        "core/menu/arrow_up",
                        "core/menu/arrow_up_pressed",
                        "core/menu/arrow_up_hover")
                            -> (&prv);

    var& IRectComponent nxt;
    var Rect nxt_r = val Rect(xc+280, yc+12, _,_);
    spawn SurfaceButton(&nxt_r,
                        "core/menu/arrow_down",
                        "core/menu/arrow_down_pressed",
                        "core/menu/arrow_down_hover")
                            -> (&nxt);

    // terminate on ESCAPE or cancel click

    par do
        every cancel.on_pointer_enter do
            call {Sound::PingusSound::play_sound}("tick");
        end
    with
        await cancel.on_click;
        escape -1;
    with
        every prv.on_pointer_enter do
            call {Sound::PingusSound::play_sound}("tick");
        end
    with
        every nxt.on_pointer_enter do
            call {Sound::PingusSound::play_sound}("tick");
        end
    with
        par do
            every prv.on_click do
                if levelui_.item_at_top > 0 then
                    levelui_.item_at_top = levelui_.item_at_top - 1;
                    emit levelui_.go(item_height);
                end
            end
        with
            every nxt.on_click do
                if levelui_.item_at_top < items_total-items_per_page then
                    levelui_.item_at_top = levelui_.item_at_top + 1;
                    emit levelui_.go(-item_height);
                end
            end
        with
            var _Input__ButtonEvent&& but;
            every but in ON_BUTTON_PRESSED do
                if but:name == {Input::ACTION_DOWN_BUTTON} then
                    emit nxt.on_click;
                else/if but:name == {Input::ACTION_UP_BUTTON} then
                    emit prv.on_click;
                end
            end
        end
    with
        loop do
            var _Input__ButtonEvent&& but = await ON_BUTTON_PRESSED;
            if but:name == {Input::ESCAPE_BUTTON} then
                escape -1;
            end
        end
    end
end

////////////////////////////////////////////////////////////////////////////////

code/await Level (var& _Levelset levelset, var& ILevelUI ui, var int i, var Rect rect)
                    -> FOREVER
do
    var& IRectComponent component;
    spawn RectComponent(&rect) -> (&component);

    var int x = rect.left;
    var int y = rect.top;

    event bool pse;
    par do
        pause/if pse do
            par do
/// TODO
                if levelset.get_level(i):accessible as bool then
                    par do
                        every component.on_click do
                            emit ui.ok(i);
                        end
                    with
                        // draw background highlight mark
                        loop do
                            await component.on_pointer_enter;
                            var Rect r = val Rect(60+20, y, 0, 0);
                            spawn Sprite_from_name(&r, "core/menu/marker2", false);
                            await component.on_pointer_leave;
                        end
                    end
                else
                    await FOREVER;
                end
            with
                // load checkbox
                var _char&& name;
                if not (levelset.get_level(i):accessible as bool) then
                    name = "core/menu/locked_small";
                else/if levelset.get_level(i):finished as bool then
                    name = "core/menu/checkbox_marked_small";
                else
                    name = "core/menu/checkbox_small";
                end
                var& Surface sfc;
                spawn Surface_from_name(name, _)
                        -> (&sfc);

                every SDL_REDRAW do
                    // draw checkbox
                    call {Display::s_framebuffer}:draw_surface(
                        sfc.framebuffer,
                        _Vector2i(x, y)
                    );

                    // draw levelname
                    if {globals::developer_mode} as bool then
                        call {Fonts::chalk_normal}.render(
                            _origin_top_left,
                            x+40, y+4,
                            __(levelset.get_level(i):plf.get_resname()),
                            *{Display::s_framebuffer}
                        );
                    else
                        call {Fonts::chalk_normal}.render(
                            _origin_top_left,
                            x+40, y+4,
                            __(levelset.get_level(i):plf.get_levelname()),
                            *{Display::s_framebuffer}
                        );
                    end
                end
            end
        end
    with
        loop do
            if i>=ui.item_at_top and
               i<ui.item_at_top+LEVEL_ITEMS_PER_PAGE
            then
                emit pse(false);
            else
                emit pse(true);
            end
            var int v = await ui.go;
            rect.top = rect.top + v;
            y = y + v;
        end
    end
end

////////////////////////////////////////////////////////////////////////////////

code/await LevelSelector (var& _Levelset levelset) -> int
do
    vector[] byte title = [] .. (levelset.get_title().c_str() as _char&&);
    vector[] byte image = [] .. (levelset.get_image().c_str() as _char&&);
    var int count = levelset.get_level_count() as int;

    //levelset.refresh();
    var& ILevelUI ui;
    var int? ret =
        watching LevelUI(levelset.get_level_count() as int, LEVEL_ITEMS_PER_PAGE, LEVEL_ITEM_HEIGHT)
                    -> (&ui)
        do
            var int yy  = 50+15;

            var Rect r1 = val Rect(0, yy, 0, 0);
            spawn Sprite_from_name(&r1, levelset.get_image().c_str(), false);
                r1.left = 60 + 680/2 - r1.width/2 - 275;

            var Rect r2 = val Rect(0, yy, 0, 0);
            spawn Sprite_from_name(&r2, levelset.get_image().c_str(), false);
                r2.left = 60 + 680/2 - r2.width/2 + 275;

            pool[] Level levels;
            var Rect rect = val Rect(60+50, 50+112, 680-90, LEVEL_ITEM_HEIGHT-1);
            var int i;
            loop i in [0->levelset.get_level_count() as int[ do
                spawn Level(&levelset, &ui, i, rect) in levels;
                rect.top = rect.top + LEVEL_ITEM_HEIGHT;
            end

            par do
                var int v = await ui.ok;
                escape v;   // always >= 0
            with
                every SDL_REDRAW do
                    call {Fonts::chalk_large}.render(
                        _origin_top_left,
                        680/2, 50+10,
                        __(levelset.get_title()),
                        *{Display::s_framebuffer}
                    );
                end
            end
        end;
    escape ret!;
end

////////////////////////////////////////////////////////////////////////////////

code/await Levelset (var& ILevelUI ui, var int i, var Rect rect) -> FOREVER
do
    var& IRectComponent component;
    spawn RectComponent(&rect) -> (&component);

    var int x = rect.left;
    var int y = rect.top;

    event bool pse;
    par do
        pause/if pse do
            par do
                every component.on_click do
                    emit ui.ok(i);
                end
            with
                // draw background highlight mark
                loop do
                    await component.on_pointer_enter;
                    var Rect r = val Rect(60+15, y-5, _,_);
                    spawn Sprite_from_name(&r, "core/menu/marker", _);
                    await component.on_pointer_leave;
                end
            with
                var& Surface sfc;
                spawn Surface_from_name({levelsets[@i]->get_image().c_str()}, _)
                        -> (&sfc);
                every SDL_REDRAW do
                    call {Display::s_framebuffer}:draw_surface(
                        sfc.framebuffer,
                        _Vector2i(x+10, y)
                    );

                    call {Fonts::chalk_normal}.render(
                        _origin_top_left,
                        rect.left+105, 15+rect.top,
                        {_(levelsets[@i]->get_title())},
                        *{Display::s_framebuffer}
                    );

                    call {Fonts::chalk_normal}.render(
                        _origin_top_left,
                        rect.left+105, 40+rect.top,
                        {_(levelsets[@i]->get_description())},
                        *{Display::s_framebuffer}
                    );

                    call {Fonts::chalk_normal}.render(
                        _origin_top_right,
                        60+rect.width, 15+rect.top,
                        {(boost::format("%1% %2%%%") % _("Solved:") % levelsets[@i]->get_completion()).str()},
                        *{Display::s_framebuffer}
                    );

                    call {Fonts::chalk_normal}.render(
                        _origin_top_right,
                        60+rect.width, 40+rect.top,
                        {(boost::format("%1% %2%") % levelsets[@i]->get_level_count() % _("levels")).str()},
                        *{Display::s_framebuffer}
                    );
                end
            end
        end
    with
        loop do
            if i>=ui.item_at_top and
               i<ui.item_at_top+LEVELSET_ITEMS_PER_PAGE
            then
                emit pse(false);
            else
                emit pse(true);
            end
            var int v = await ui.go;
            rect.top = rect.top + v;
            y = y + v;
        end
    end
end

code/await LevelsetSelector (void) -> int do
    {
        static auto directory = Pathname("levelsets", Pathname::DATA_PATH).opendir("*.levelset");
        directory = Pathname("levelsets", Pathname::DATA_PATH).opendir("*.levelset");
        levelsets.clear();
        for(auto i = directory.begin(); i != directory.end(); ++i) {
            try {
                std::shared_ptr<Levelset> levelset = Levelset::from_file(*i);
                //current_levelset = levelset;
                if (!levelset->get_developer_only() || globals::developer_mode) {
                    levelsets.push_back(levelset);
                }
            } catch(const std::exception& err) {
                log_error("%1%", err.what());
            }
        }
#if 0
        if (globals::developer_mode) {
            levelsets.push_back(Levelset::from_directory(_("Under Construction"),
                                                   _("Untested, unpolished and broken levels"),
                                                   "levelsets/underconstruction",
                                                   Pathname("levels", Pathname::DATA_PATH)).release());
        }
#endif
        std::sort(levelsets.begin(), levelsets.end(), LevelsetPrioritySorter());
    };
    var& ILevelUI ui;
    var int? ret =
        watching LevelUI({levelsets.size()} as int, LEVELSET_ITEMS_PER_PAGE, LEVELSET_ITEM_HEIGHT)
                    -> (&ui)
        do
            pool[] Levelset sets;
            var Rect rect = val Rect(60+30, 50+70, 680-90, LEVELSET_ITEM_HEIGHT-1);
            var int i;
            loop i in [0 -> {levelsets.size()}[ do
                spawn Levelset(&ui, i, rect) in sets;
                rect.top = rect.top + LEVELSET_ITEM_HEIGHT;
            end

            par do
                var int v = await ui.ok;
                escape v;   // always >= 0
            with
                every SDL_REDRAW do
                    call {Fonts::chalk_large}.render(
                        _origin_top_center,
                        60+680/2, 50+10,
                        __("Levelsets"),
                        *{Display::s_framebuffer}
                    );
                end
            end
        end;
    escape ret!;
end

////////////////////////////////////////////////////////////////////////////////

code/await LevelMenu (void) -> void do
    loop do
        var int i = await LevelsetSelector();
        if i == -1 then
            break;
        end
        var&? _Levelset levelset = &{levelsets[@i]}.get() finalize (levelset) with end;
        {current_levelset = levelsets[@i];}
        loop do
            var int j = await LevelSelector(&levelset!);
            if j == -1 then
                break;
            end
            var&? _PingusLevel plf    = &_ID(&&levelset!.get_level(j):plf) finalize (plf) with end;
            var&? _Result      result = &_ID({&result}) finalize (result) with end;
            await Start_Game_Result_Loop(&plf!, &result!);
        end
    end
end

#endif
