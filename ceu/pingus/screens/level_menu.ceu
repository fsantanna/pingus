#ifndef _LEVELMENU_CEU
#define _LEVELMENU_CEU

#include "../../engine/display/sprite.ceu"
#include "../../engine/gui/surface_button.ceu"
#include "../components/wood.ceu"

native/pre do
    ##include "pingus/levelset.hpp"
    typedef std::vector<std::shared_ptr<Levelset>> Levelsets;
    struct LevelsetPrioritySorter {
        bool operator()(std::shared_ptr<Levelset> lhs, std::shared_ptr<Levelset> rhs) const {
            return lhs->get_priority() > rhs->get_priority();
        }
    };
    static std::shared_ptr<Levelset> current_levelset;
    static Levelsets levelsets;
end

#define LEVEL_ITEMS_PER_PAGE 10
#define LEVELSET_ITEMS_PER_PAGE 4

#define LEVEL_ITEM_HEIGHT 32
#define LEVELSET_ITEM_HEIGHT 95

////////////////////////////////////////////////////////////////////////////////

class LevelUI with
    var   int items_total;
    var   int items_per_page;
    var   int item_height;
    var   int item_at_top = 0;
    event int ok;
    event int go;
    function (int total, int per, int height)=>LevelUI build;
do
    function (int total, int per, int height)=>LevelUI build do
        this.items_total    = total;
        this.items_per_page = per;
        this.item_height    = height;
    end

    var float xc = {Display::get_width()}  / 2;
    var float yc = {Display::get_height()} / 2;

    var Wood _;

    var Rect rect = Rect(xc, yc, 0, 0);
    var Sprite _ = Sprite.build_name(&rect, "core/menu/blackboard");

    var SurfaceButton cancel with
        this.x = xc - 300;
        this.y = yc + 200;
        this.button         = "core/start/back";
        this.button_pressed = "core/start/back_clicked";
        this.button_over    = "core/start/back_hover";
    end;
    spawn do
        every REDRAW do
            call {Fonts::chalk_normal}.render(
                _origin_top_center,
                cancel.x + 55, cancel.y,
                __("Back"),
                *{Display::s_framebuffer}
            );
        end
    end

    var SurfaceButton prv with
        this.x = xc + 280;
        this.y = yc - 48 - 12;
        this.button         = "core/menu/arrow_up";
        this.button_pressed = "core/menu/arrow_up_pressed";
        this.button_over    = "core/menu/arrow_up_hover";
    end;

    var SurfaceButton nxt with
        this.x = xc + 280;
        this.y = yc +  12;
        this.button         = "core/menu/arrow_down";
        this.button_pressed = "core/menu/arrow_down_pressed";
        this.button_over    = "core/menu/arrow_down_hover";
    end;

    // terminate on ESCAPE or cancel click

    par do
        every cancel.component.on_pointer_enter do
            call {Sound::PingusSound::play_sound}("tick");
        end
    with
        await cancel.component.on_click;
        escape -1;
    with
        every prv.component.on_pointer_enter do
            call {Sound::PingusSound::play_sound}("tick");
        end
    with
        every nxt.component.on_pointer_enter do
            call {Sound::PingusSound::play_sound}("tick");
        end
    with
        par do
            every prv.component.on_click do
                if this.item_at_top > 0 then
                    this.item_at_top = item_at_top - 1;
                    emit this.go => this.item_height;
                end
            end
        with
            every nxt.component.on_click do
                if this.item_at_top < this.items_total-this.items_per_page then
                    this.item_at_top = item_at_top + 1;
                    emit this.go => -this.item_height;
                end
            end
        with
            every but in ON_BUTTON_PRESSED do
                if but:name == {Input::ACTION_DOWN_BUTTON} then
                    emit nxt.component.on_click;
                else/if but:name == {Input::ACTION_UP_BUTTON} then
                    emit prv.component.on_click;
                end
            end
        end
    with
        loop do
            var _Input__ButtonEvent&& but = await ON_BUTTON_PRESSED;
            if but:name == {Input::ESCAPE_BUTTON} then
                escape -1;
            end
        end
    end
end

////////////////////////////////////////////////////////////////////////////////

class Level with
    var _Levelset& levelset;
    var LevelUI& ui;
    var int      i;
    var Rect     rect;
    function (_Levelset& levelset, LevelUI& ui, int i, Rect rect)=>Level build;
do
    function (_Levelset& levelset, LevelUI& ui, int i, Rect rect)=>Level build do
        this.levelset = &levelset;
        this.ui       = &ui;
        this.i        = i;
        this.rect     = rect;
    end

    var RectComponent component with
        this.rect = &outer.rect;
    end;
    var float x = rect.left;
    var float y = rect.top;

    event bool pse;
    par do
        pause/if pse do
            par do
                if this.levelset.get_level(i):accessible then
                    par do
                        every component.on_click do
                            emit this.ui.ok => this.i;
                        end
                    with
                        // draw background highlight mark
                        loop do
                            await component.on_pointer_enter;
                            var Rect r = Rect(60+20, y, 0, 0);
                            var Sprite _ = Sprite.build_name(&r, "core/menu/marker2");
                            await component.on_pointer_leave;
                        end
                    end
                else
                    await FOREVER;
                end
            with
                // draw icon
                if (not this.levelset.get_level(i):accessible) then
                    var Rect r = Rect(x, y, 0, 0);
                    do Sprite.build_name(&r, "core/menu/locked_small");
                else/if this.levelset.get_level(i):finished then
                    var Rect r = Rect(x, y, 0, 0);
                    do Sprite.build_name(&r, "core/menu/checkbox_marked_small");
                else
                    var Rect r = Rect(x, y, 0, 0);
                    do Sprite.build_name(&r, "core/menu/checkbox_small");
                end
            with
                every REDRAW do
                    // draw levelname
                    if {globals::developer_mode} then
                        call {Fonts::chalk_normal}.render(
                            _origin_top_left,
                            x+40, y+4,
                            __(this.levelset.get_level(i):plf.get_resname()),
                            *{Display::s_framebuffer}
                        );
                    else
                        call {Fonts::chalk_normal}.render(
                            _origin_top_left,
                            x+40, y+4,
                            __(this.levelset.get_level(i):plf.get_levelname()),
                            *{Display::s_framebuffer}
                        );
                    end
                end
            end
        end
    with
        loop do
            if this.i>=ui.item_at_top and
               this.i<ui.item_at_top+LEVEL_ITEMS_PER_PAGE
            then
                emit pse => false;
            else
                emit pse => true;
            end
            var int v = await ui.go;
            rect.top = rect.top + v;
            y = y + v;
        end
    end
end

////////////////////////////////////////////////////////////////////////////////

class Levelset with
    var LevelUI& ui;
    var int      i;
    var Rect     rect;
    function (LevelUI& ui, int i, Rect rect)=>Levelset build;
do
    function (LevelUI& ui, int i, Rect rect)=>Levelset build do
        this.ui   = &ui;
        this.i    = i;
        this.rect = rect;
    end

    var RectComponent component with
        this.rect = &outer.rect;
    end;
    var float x = rect.left;
    var float y = rect.top;

    event bool pse;
    par do
        pause/if pse do
            par do
                every component.on_click do
                    emit this.ui.ok => this.i;
                end
            with
                // draw background highlight mark
                loop do
                    await component.on_pointer_enter;
                    var Rect r = Rect(60+15, y-5, 0, 0);
                    var Sprite _ = Sprite.build_name(&r, "core/menu/marker");
                    await component.on_pointer_leave;
                end
            with
                var Rect r = Rect(x+10, y, 0, 0);
                var Sprite _ = Sprite.build_name(&r,
                                    (char&&)_XXX_PURE(_levelsets[i]:get_image().c_str()));
                every REDRAW do
                    call {Fonts::chalk_normal}.render(
                        _origin_top_left,
                        rect.left+105, 15+rect.top,
                        __(_levelsets[i]:get_title()),
                        *{Display::s_framebuffer}
                    );

                    call {Fonts::chalk_normal}.render(
                        _origin_top_left,
                        rect.left+105, 40+rect.top,
                        __(_levelsets[i]:get_description()),
                        *{Display::s_framebuffer}
                    );

                    call {Fonts::chalk_normal}.render(
                        _origin_top_right,
                        60+rect.width, 15+rect.top,
                        {(boost::format("%1% %2%%%") % _("Solved:") % levelsets[THIS(CEU_Levelset)->i]->get_completion()).str()},
                        *{Display::s_framebuffer}
                    );

                    call {Fonts::chalk_normal}.render(
                        _origin_top_right,
                        60+rect.width, 40+rect.top,
                        {(boost::format("%1% %2%") % levelsets[THIS(CEU_Levelset)->i]->get_level_count() % _("levels")).str()},
                        *{Display::s_framebuffer}
                    );
                end
            end
        end
    with
        loop do
            if this.i>=ui.item_at_top and
               this.i<ui.item_at_top+LEVELSET_ITEMS_PER_PAGE
            then
                emit pse => false;
            else
                emit pse => true;
            end
            var int v = await ui.go;
            rect.top = rect.top + v;
            y = y + v;
        end
    end
end

////////////////////////////////////////////////////////////////////////////////

class LevelSelector with
    var _Levelset& levelset;
do
    var char[] title = [] .. (char&&)this.levelset.get_title().c_str();
    var char[] image = [] .. (char&&)this.levelset.get_image().c_str();
    var int count = this.levelset.get_level_count();

    //this.levelset.refresh();
    var LevelUI ui = LevelUI.build(outer.levelset.get_level_count(),
                                   LEVEL_ITEMS_PER_PAGE, LEVEL_ITEM_HEIGHT);

    var float yy  = 50+15;

    var Rect    r1 = Rect(0, yy, 0, 0);
    var Sprite s1 = Sprite.build_name(&r1,
                        (char&&)_XXX_PURE(outer.levelset.get_image().c_str()));
        r1.left = 60 + 680/2 - s1.get_width()/2 - 275;

    var Rect    r2 = Rect(0, yy, 0, 0);
    var Sprite s2 = Sprite.build_name(&r2,
                        (char&&)_XXX_PURE(outer.levelset.get_image().c_str()));
        r2.left = 60 + 680/2 - s2.get_width()/2 + 275;

    pool Level[] levels;
    var Rect rect = Rect(60+50, 50+112, 680-90, LEVEL_ITEM_HEIGHT-1);
    loop i in this.levelset.get_level_count() do
        spawn Level.build(&outer.levelset, &ui, i, rect) in levels;
        rect.top = rect.top + LEVEL_ITEM_HEIGHT;
    end

    par do
        var int v = await ui;
        escape v;   // always -1
    with
        var int v = await ui.ok;
        escape v;   // always >= 0
    with
        every REDRAW do
            call {Fonts::chalk_large}.render(
                _origin_top_left,
                680/2, 50+10,
                __(this.levelset.get_title()),
                *{Display::s_framebuffer}
            );
        end
    end
end

class LevelsetSelector with
do
    {
        static auto directory = Pathname("levelsets", Pathname::DATA_PATH).opendir("*.levelset");
        directory = Pathname("levelsets", Pathname::DATA_PATH).opendir("*.levelset");
        levelsets.clear();
        for(auto i = directory.begin(); i != directory.end(); ++i) {
            try {
                std::shared_ptr<Levelset> levelset = Levelset::from_file(*i);
                //current_levelset = levelset;
                if (!levelset->get_developer_only() || globals::developer_mode) {
                    levelsets.push_back(levelset);
                }
            } catch(const std::exception& err) {
                log_error("%1%", err.what());
            }
        }
#if 0
        if (globals::developer_mode) {
            levelsets.push_back(Levelset::from_directory(_("Under Construction"),
                                                   _("Untested, unpolished and broken levels"),
                                                   "levelsets/underconstruction",
                                                   Pathname("levels", Pathname::DATA_PATH)).release());
        }
#endif
        std::sort(levelsets.begin(), levelsets.end(), LevelsetPrioritySorter());
    };

    var LevelUI ui = LevelUI.build(_levelsets.size(),
                                   LEVELSET_ITEMS_PER_PAGE, LEVELSET_ITEM_HEIGHT);

    pool Levelset[] sets;
    var Rect rect = Rect(60+30, 50+70, 680-90, LEVELSET_ITEM_HEIGHT-1);
    loop i in _levelsets.size() do
        spawn Levelset.build(&ui, i, rect) in sets;
        rect.top = rect.top + LEVELSET_ITEM_HEIGHT;
    end

    par do
        var int v = await ui;
        escape v;   // always -1
    with
        var int v = await ui.ok;
        escape v;   // always >= 0
    with
        every REDRAW do
            call {Fonts::chalk_large}.render(
                _origin_top_center,
                60+680/2, 50+10,
                __("Levelsets"),
                *{Display::s_framebuffer}
            );
        end
    end
end

////////////////////////////////////////////////////////////////////////////////

class LevelMenu with
do
    loop do
        var int v = do LevelsetSelector;
        if v == -1 then
            break;
        end
        var _Levelset&? levelset;
        finalize
            levelset = &_XXX_NOHOLD(_levelsets[v].get());
        with
            // TODO
        end
        _current_levelset = _levelsets[v];
        loop do
            var int v = do LevelSelector with
                            this.levelset = &levelset!;
                        end;
            if v == -1 then
                break;
            end
            do Start_Game_Result_Loop with
                this.plf    = &_XXX_PURE(&&levelset!.get_level(v):plf);
                this.result = &_XXX_PURE(&&_result);
            end;
        end
    end
end

#endif
