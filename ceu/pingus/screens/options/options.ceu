#ifdef _OPTIONMENU_CEU
#error multiple include
#else
#define _OPTIONMENU_CEU

native/pos do
    extern tinygettext::DictionaryManager dictionary_manager;
    struct LanguageSorter {
        bool operator()(const tinygettext::Language& lhs,
                      const tinygettext::Language& rhs) {
            return lhs.get_name() < rhs.get_name();
        }
    };
    static std::map<std::string, tinygettext::Language> m_language_map;
    static tinygettext::Language m_language = dictionary_manager.get_language();
end

#include "label.ceu"
#include "check_box.ceu"
#include "choice_box.ceu"
#include "slider_box.ceu"

code/await OptionMenu (void) -> void do
    spawn Wood();

    var Rect rect = val Rect(0,0, 0,0, &outer.main.center);
    spawn Sprite_from_name(&rect, "core/menu/blackboard", &outer.main.dt, &outer.main.redraw);

    var int xx = -315;
    var int yy = -160;

    var Rect r0 = val Rect(xx,yy, 320,32, &outer.main.center);

    // LEFT OPTIONS //

    // Fullscreen
    var Rect r11 = val Rect(r0.x,   r0.y, 32,32, &outer.main.center);
    var Rect r12 = val Rect(r0.x+40,r0.y, 32,32, &outer.main.center);
    var& CheckBox b1 =
        spawn CheckBox(&r11, (_config_manager.get_fullscreen() as bool));
    spawn Label("Fullscreen", &r12);
    spawn do
        var bool v;
        every v in b1.checkbox.go_click do
            _config_manager.set_fullscreen(v);
        end
    end

    r0.y = r0.y + 32;

    // Mouse Grab
    var Rect r21 = val Rect(r0.x,   r0.y, 32,32, &outer.main.center);
    var Rect r22 = val Rect(r0.x+40,r0.y, 32,32, &outer.main.center);
    var& CheckBox b2 =
        spawn CheckBox(&r21, (_config_manager.get_mouse_grab() as bool));
    spawn Label("Mouse Grab", &r22);
    spawn do
        par do
            var bool v;
            every v in outer.config_manager.go_mouse_grab do
                emit b2.checkbox.go_click(v);
            end
        with
            var bool v;
            every v in b2.checkbox.go_click do
                emit outer.config_manager.go_mouse_grab(v);
            end
        end
    end

    r0.y = r0.y + 32;
    r0.y = r0.y + 32;

    // Software Cursor
    var Rect r31 = val Rect(r0.x,   r0.y, 32,32, &outer.main.center);
    var Rect r32 = val Rect(r0.x+40,r0.y, 32,32, &outer.main.center);
    var& CheckBox b3 =
        spawn CheckBox(&r31, (_config_manager.get_software_cursor() as bool));
    spawn Label("Software Cursor", &r32);
    spawn do
        var bool v;
        every v in b3.checkbox.go_click do
            _config_manager.set_software_cursor(v);
        end
    end

    r0.y = r0.y + 32;

    // Auto Scrolling
    var Rect r41 = val Rect(r0.x,   r0.y, 32,32, &outer.main.center);
    var Rect r42 = val Rect(r0.x+40,r0.y, 32,32, &outer.main.center);
    var& CheckBox b4 =
        spawn CheckBox(&r41, (_config_manager.get_auto_scrolling() as bool));
    spawn Label("Autoscrolling", &r42);
    spawn do
        var bool v;
        every v in b4.checkbox.go_click do
            _config_manager.set_auto_scrolling(v);
        end
    end

    r0.y = r0.y + 32;

    // Drag & Drop Scrolling
    var Rect r51 = val Rect(r0.x,   r0.y, 32,32, &outer.main.center);
    var Rect r52 = val Rect(r0.x+40,r0.y, 32,32, &outer.main.center);
    var& CheckBox b5 =
        spawn CheckBox(&r51, (_config_manager.get_drag_drop_scrolling() as bool));
    spawn Label("Drag&Drop Scrolling", &r52);
    spawn do
        var bool v;
        every v in b5.checkbox.go_click do
            _config_manager.set_drag_drop_scrolling(v);
        end
    end

    r0.y = r0.y + 32;
    r0.y = r0.y + 32;

    // Print FPS
    var Rect r61 = val Rect(r0.x,   r0.y, 32,32, &outer.main.center);
    var Rect r62 = val Rect(r0.x+40,r0.y, 32,32, &outer.main.center);
    var& CheckBox b6 =
        spawn CheckBox(&r61, (_config_manager.get_print_fps() as bool));
    spawn Label("Print FPS", &r62);
    spawn do
        var bool v;
        every v in b6.checkbox.go_click do
            _config_manager.set_print_fps(v);
        end
    end

    // RIGHT OPTIONS //

    var Rect left  = val Rect(r0.x+320,     yy, r0.w-180,    r0.h, &outer.main.center);
    var Rect right = val Rect(r0.x+320+140, yy, r0.w-left.w, r0.h, &outer.main.center);

    // Resolution
    var Rect l1 = left;
    var Rect r1 = right;
    spawn Label("Resolution", &l1);
    pool[] ChoiceItem its1;
    var    IChoiceBox cb1 = val IChoiceBox(_,_,_);

    {
        static std::vector<Size> resolutions = Display::get_fullscreen_video_modes();
        static Size fullscreen = config_manager.get_fullscreen_resolution();
        static auto it1 = resolutions.begin();
        it1 = resolutions.begin();
    };
    cb1.current = {resolutions.size()} - 1;
    do
        var int i;
        loop i do
            if {it1} == {resolutions.end()} then
                break;
            end

            // add resolution to the box
            var _char_const_ptr str1 = _;
            {
                {
                    std::ostringstream ostr;
                    ostr << it1->width << "x" << it1->height;
                    @str1 = ostr.str().c_str();
                }
            };
            spawn ChoiceItem(&r1, str1, i, &cb1) in its1;

            if {fullscreen} == {*it1} then
                cb1.current = {it1 - resolutions.begin()};
            end
            {it1++;};
        end
    end
    spawn ChoiceBox(&r1, &its1, &cb1);
    spawn do
        every cb1.go do
            { static Size size_; };
            if _sscanf(&&cb1.value[0] as _char_const_ptr, "%dx%d", {&size_.width}, {&size_.height}) != 2 then
                _log_error("failed to parse: %1%", &&cb1.value[0] as _char_const_ptr);
            else
                _config_manager.set_fullscreen_resolution({size_});
            end
        end
    end

    left.y  = left.y + 32;
    right.y = right.y + 32;

    // Renderer
    var Rect l2 = left;
    var Rect r2 = right;
    spawn Label("Renderer", &l2);
    pool[] ChoiceItem its2;
    var    IChoiceBox cb2 = val IChoiceBox(_,_,_);
    if _config_manager.get_renderer() == {SDL_FRAMEBUFFER} then
        cb2.current = 0;
    else/if _config_manager.get_renderer() == {DELTA_FRAMEBUFFER} then
        cb2.current = 1;
#ifdef HAVE_OPENGL
    else/if _config_manager.get_renderer() == {OPENGL_FRAMEBUFFER} then
        cb2.current = 2;
#endif
    else
        cb2.current = -1;
        _ceu_dbg_assert({!"unknown renderer type"});
    end
    spawn ChoiceItem(&r2, "sdl",    0, &cb2) in its2;
    spawn ChoiceItem(&r2, "delta",  1, &cb2) in its2;
#ifdef HAVE_OPENGL
    spawn ChoiceItem(&r2, "opengl", 2, &cb2) in its2;
#endif
    spawn ChoiceBox(&r2, &its2, &cb2);
    spawn do
        every cb2.go do
            _config_manager.set_renderer(
                _framebuffer_type_from_string(&&cb2.value[0] as _char_const_ptr)
            );
        end
    end

    left.y  = left.y + 32;
    left.y  = left.y + 32;
    right.y = right.y + 32;
    right.y = right.y + 32;

    // Language
    var Rect l3 = left;
    var Rect r3 = right;
    spawn Label("Language", &l3);
    pool[] ChoiceItem its3;
    var    IChoiceBox cb3 = val IChoiceBox(_,_,_);

    {
        static std::set<tinygettext::Language> languages =
            dictionary_manager.get_languages();
        // English is the default language, thus it's not in the list of
        // languages returned by tinygettext and we have to add it manually
        languages.insert(tinygettext::Language::from_name("en"));
        static std::vector<tinygettext::Language> langs(languages.begin(), languages.end());
        std::sort(langs.begin(), langs.end(), LanguageSorter());
        static auto it3 = langs.begin();
        it3 = langs.begin();
    };
    do
        var int i;
        loop i do
            if {it3} == {langs.end()} then
                break;
            end
            {
                static const char* str3;
                str3 = it3->get_name().c_str();
            }
            spawn ChoiceItem(&r3, {str3}, i, &cb3) in its3;
            {
                m_language_map[str3] = *it3;
            }

            if {dictionary_manager.get_language()} == {*it3} then
                cb3.current = {it3 - langs.begin()};
            end
            {it3++;};
        end
    end
    spawn ChoiceBox(&r3, &its3, &cb3);
    spawn do
        every cb3.go do
            {
                static auto it = m_language_map.find(@(&&cb3.value[0] as _char&&));
                it = m_language_map.find(@(&&cb3.value[0] as _char&&));
            }
            if {it} == {m_language_map.end()} then
                _log_error("unknown language: %1%", &&cb3.value[0]);
            else
                {
                    m_language = it->second;
                    config_manager.set_language(it->second);
                }
            end
        end
    end

    left.y  = left.y + 32;
    left.y  = left.y + 32;
    right.y = right.y + 32;
    right.y = right.y + 32;

    // Master Volume
    var Rect l4 = left;
    var Rect r4 = right;
    spawn Label("Master Volume", &l4);
    var& SliderBox box4 = spawn SliderBox(&r4, 25, _config_manager.get_master_volume());
    spawn do
        var int v;
        every v in box4.go do
            _config_manager.set_master_volume(v);
        end
    end

    left.y  = left.y + 32;
    right.y = right.y + 32;

    // Sound Volume
    var Rect l5 = left;
    var Rect r5 = right;
    spawn Label("Sound Volume", &l5);
    var& SliderBox box5 = spawn SliderBox(&r5, 25, _config_manager.get_sound_volume());
    spawn do
        var int v;
        every v in box5.go do
            _config_manager.set_sound_volume(v);
        end
    end

    left.y  = left.y + 32;
    right.y = right.y + 32;

    // Music Volume
    var Rect l6 = left;
    var Rect r6 = right;
    spawn Label("Music Volume", &l6);
    var& SliderBox box6 = spawn SliderBox(&r6, 25, _config_manager.get_music_volume());
    spawn do
        var int v;
        every v in box6.go do
            _config_manager.set_music_volume(v);
        end
    end

    left.y  = left.y + 32;
    right.y = right.y + 32;

    // CLOSE //

    var Rect r7 = val Rect(245,150, 0,0, &outer.main.center);
    var& SurfaceButton button =
        spawn SurfaceButton(&r7, "core/start/ok",
                                 "core/start/ok_clicked",
                                 "core/start/ok_hover");

    par/or do
        every button.component.on_pointer_enter do
            call {Sound::PingusSound::play_sound}("tick");
        end
    with
        await button.component.on_click;
        call {Sound::PingusSound::play_sound}("yipee");
    with
        var _Input__ButtonEvent&& but =
            await ON_BUTTON_PRESSED
            until but:name  == {Input::ESCAPE_BUTTON};
    with
        every outer.main.redraw do
            call {Fonts::chalk_large}.render(
                _origin_top_center,
                outer.main.center.x,
                outer.main.center.y - 240,
                __("Option Menu"),
                *{Display::s_framebuffer}
            );

            call {Fonts::chalk_normal}.render(
                _origin_top_center,
                outer.main.center.x + 245 + 30,
                outer.main.center.y + 150 - 20,
                __("Close"),
                *{Display::s_framebuffer}
            );

            call {Fonts::chalk_normal}.render(
                _origin_top_left,
                outer.main.center.x  - 320,
                outer.main.center.y + 200,
                __("Some options require a restart of the game to take effect."),
                *{Display::s_framebuffer}
            );
        end
    end

    {
        {
            Pathname cfg_filename(System::get_userdir() + "config",
                                  Pathname::SYSTEM_PATH);
            log_info("saving configuration: %1%", cfg_filename);
            config_manager.get_options().save(cfg_filename);
        }
    };
end

#endif
