#ifndef _OPTIONMENU_CEU
#define _OPTIONMENU_CEU

native/pos do
    ##include "util/system.hpp"
    ##include "tinygettext/dictionary_manager.hpp"
    ##include "pingus/config_manager.hpp"
    extern tinygettext::DictionaryManager dictionary_manager;
    struct LanguageSorter {
        bool operator()(const tinygettext::Language& lhs,
                      const tinygettext::Language& rhs) {
            return lhs.get_name() < rhs.get_name();
        }
    };
    static std::map<std::string, tinygettext::Language> m_language_map;
    static tinygettext::Language m_language = dictionary_manager.get_language();
end

#include "../../engine/display/sprite.ceu"
#include "../components/wood.ceu"
#include "../components/check_box.ceu"
#include "../components/label.ceu"
#include "../components/choice_box.ceu"

#if 0
#include "../../engine/gui/surface_button.ceu"
#include "../components/slider_box.ceu"
#endif

code/await OptionMenu (void) -> void do
    var Rect rect = val Rect({Display::get_width()}  / 2,
                             {Display::get_height()} / 2,
                             0, 0
                            );

    spawn Wood();
    var Sprite sprite = _;
    spawn Sprite_from_name(&sprite, &rect, "core/menu/blackboard");

    var int x_offset = ({Display::get_width()}  - 800) / 2;
    var int y_offset = ({Display::get_height()} - 600) / 2;

    var int yy = 140 + y_offset;
    var Rect r0 = val Rect(80+x_offset, yy, 320, 32);

    // LEFT OPTIONS //

    // Fullscreen
    var Rect r11 = val Rect(r0.left,   r0.top, 32,32);
    var Rect r12 = val Rect(r0.left+40,r0.top, 32,32);
    var& ICheckBox b1;
    spawn CheckBox(&r11, (_config_manager.get_fullscreen() as bool)) -> (&b1);
    spawn Label("Fullscreen", &r12);
    spawn do
        var bool v;
        every v in b1.go_click do
            _config_manager.set_fullscreen(v);
        end
    end

    r0.top = r0.top + 32;

    // Mouse Grab
    var Rect r21 = val Rect(r0.left,   r0.top, 32,32);
    var Rect r22 = val Rect(r0.left+40,r0.top, 32,32);
    var& ICheckBox b2;
    spawn CheckBox(&r21, (_config_manager.get_mouse_grab() as bool)) -> (&b2);
    spawn Label("Mouse Grab", &r22);
    spawn do
        par do
            var bool v;
            every v in outer.config_manager.go_mouse_grab do
                emit b2.go_click(v);
            end
        with
            var bool v;
            every v in b2.go_click do
                emit outer.config_manager.go_mouse_grab(v);
            end
        end
    end

    r0.top = r0.top + 32;
    r0.top = r0.top + 32;

    // Software Cursor
    var Rect r31 = val Rect(r0.left,   r0.top, 32,32);
    var Rect r32 = val Rect(r0.left+40,r0.top, 32,32);
    var& ICheckBox b3;
    spawn CheckBox(&r31, (_config_manager.get_software_cursor() as bool)) -> (&b3);
    spawn Label("Software Cursor", &r32);
    spawn do
        var bool v;
        every v in b3.go_click do
            _config_manager.set_software_cursor(v);
        end
    end

    r0.top = r0.top + 32;

    // Auto Scrolling
    var Rect r41 = val Rect(r0.left,   r0.top, 32,32);
    var Rect r42 = val Rect(r0.left+40,r0.top, 32,32);
    var& ICheckBox b4;
    spawn CheckBox(&r41, (_config_manager.get_auto_scrolling() as bool)) -> (&b4);
    spawn Label("Autoscrolling", &r42);
    spawn do
        var bool v;
        every v in b4.go_click do
            _config_manager.set_auto_scrolling(v);
        end
    end

    r0.top = r0.top + 32;

    // Drag & Drop Scrolling
    var Rect r51 = val Rect(r0.left,   r0.top, 32,32);
    var Rect r52 = val Rect(r0.left+40,r0.top, 32,32);
    var& ICheckBox b5;
    spawn CheckBox(&r51, (_config_manager.get_drag_drop_scrolling() as bool)) -> (&b5);
    spawn Label("Drag&Drop Scrolling", &r52);
    spawn do
        var bool v;
        every v in b5.go_click do
            _config_manager.set_drag_drop_scrolling(v);
        end
    end

    r0.top = r0.top + 32;
    r0.top = r0.top + 32;

    // Print FPS
    var Rect r61 = val Rect(r0.left,   r0.top, 32,32);
    var Rect r62 = val Rect(r0.left+40,r0.top, 32,32);
    var& ICheckBox b6;
    spawn CheckBox(&r61, (_config_manager.get_print_fps() as bool)) -> (&b6);
    spawn Label("Print FPS", &r62);
    spawn do
        var bool v;
        every v in b6.go_click do
            _config_manager.set_print_fps(v);
        end
    end

    // RIGHT OPTIONS //

    var Rect left  = val Rect(r0.left+320,         yy,
                              r0.width-180,        r0.height);
    var Rect right = val Rect(r0.left+320+140,     yy,
                              r0.width-left.width, r0.height);

    // Resolution
    spawn Label("Resolution", &left);
    pool[] ChoiceItem its1;
    var    IChoiceBox cb1 = val IChoiceBox(_,_,_);

    {
        static std::vector<Size> resolutions = Display::get_fullscreen_video_modes();
        static Size fullscreen = config_manager.get_fullscreen_resolution();
        static auto it1 = resolutions.begin();
        it1 = resolutions.begin();
    };
    cb1.current = {resolutions.size()} - 1;
    var int i;
    loop i do
        if {it1} == {resolutions.end()} then
            break;
        end

        // add resolution to the box
        var _char_const_ptr str = _;
        {
            {
                std::ostringstream ostr;
                ostr << it1->width << "x" << it1->height;
                @str = ostr.str().c_str();
            }
        };
        spawn ChoiceItem(&right, str, i, &cb1) in its1;

        if {fullscreen} == {*it1} then
            cb1.current = {it1 - resolutions.begin()};
        end
        {it1++;};
    end
    spawn ChoiceBox(&right, &its1, &cb1);
    spawn do
        every cb1.go do
            { static Size size_; };
            if _sscanf(&&cb1.value[0] as _char_const_ptr, "%dx%d", {&size_.width}, {&size_.height}) != 2 then
                _log_error("failed to parse: %1%", &&cb1.value[0] as _char_const_ptr);
            else
                _config_manager.set_fullscreen_resolution({size_});
            end
        end
    end

#if 0
    left.top  = left.top + 32;
    right.top = right.top + 32;

    // Renderer
    var Label _ = Label.build("Renderer", left);
    var int current2;
    if _config_manager.get_renderer() == _SDL_FRAMEBUFFER then
        current2 = 0;
    else/if _config_manager.get_renderer() == _DELTA_FRAMEBUFFER then
        current2 = 1;
#ifdef HAVE_OPENGL
    else/if _config_manager.get_renderer() == _OPENGL_FRAMEBUFFER then
        current2 = 2;
#endif
    else
        current2 = -1;
        _assert(not "unknown renderer type");
    end
    var ChoiceItem&&?[] vec2;
    var ChoiceItem it21 = ChoiceItem.build(right, "sdl");
    vec2 = [] .. vec2 .. [ &&it21 ];
    var ChoiceItem it22 = ChoiceItem.build(right, "delta");
    vec2 = [] .. vec2 .. [ &&it22 ];
#ifdef HAVE_OPENGL
    var ChoiceItem it23 = ChoiceItem.build(right, "opengl");
    vec2 = vec2 .. [ &&it23 ];
#endif
    var ChoiceBox c2 = ChoiceBox.build(right, &vec2, current2);
    spawn do
        var bool v;
        every v in c2.ok_changed do
            _config_manager.set_renderer(
                _framebuffer_type_from_string((_char&&)&&vec2[v]!:value)
                    finalize with end
            );
        end
    end

    left.top  = left.top + 32;
    left.top  = left.top + 32;
    right.top = right.top + 32;
    right.top = right.top + 32;

    // Language
    var Label _ = Label.build("Language", left);
    var ChoiceItem&&?[] vec3;
    pool ChoiceItem[] its2;

    {
        static std::set<tinygettext::Language> languages =
            dictionary_manager.get_languages();
        // English is the default language, thus it's not in the list of
        // languages returned by tinygettext and we have to add it manually
        languages.insert(tinygettext::Language::from_name("en"));
        static std::vector<tinygettext::Language> langs(languages.begin(), languages.end());
        std::sort(langs.begin(), langs.end(), LanguageSorter());
        static auto it2 = langs.begin();
        it2 = langs.begin();
    };
    var int? current3;
    loop do
        if _it2 == _langs.end() then
            break;
        end

        var char&& str = _XXX_PURE((char&&)_it2:get_name().c_str());
        _m_language_map[_XXX_PURE(str)] = *_it2;

        var ChoiceItem&&? it = spawn ChoiceItem.build(right, str) in its2;
        vec3 = []..vec3..[it];

        if _dictionary_manager.get_language() == *_it2 then
            current3 = (_it2 - _langs.begin());
        end
        {it2++;};
    end
    var ChoiceBox c3 = ChoiceBox.build(right, &vec3, current3!);
    spawn do
        var bool v;
        every v in c3.ok_changed do
            { static char* str; };
            _str := (_char&&)&&vec3[v]!:value;
            { static auto it = m_language_map.find(str); };
            { it = m_language_map.find(str); };
            if _it == _m_language_map.end() then
                _log_error("unknown language: %1%", &&vec3[v]!:value);
            else
                _m_language = _it:second;
                _config_manager.set_language(_it:second);
            end
        end
    end

    left.top  = left.top + 32;
    left.top  = left.top + 32;
    right.top = right.top + 32;
    right.top = right.top + 32;

    // Master Volume
    var Label _ = Label.build("Master Volume", left);
    var SliderBox s1 = SliderBox.build(right, 25,
                        _config_manager.get_master_volume());
    spawn do
        var bool v;
        every v in s1.ok_changed do
            _config_manager.set_master_volume(v);
        end
    end

    left.top  = left.top + 32;
    right.top = right.top + 32;

    // Sound Volume
    var Label _ = Label.build("Sound Volume", left);
    var SliderBox s2 = SliderBox.build(right, 25,
                        _config_manager.get_sound_volume());
    spawn do
        var bool v;
        every v in s2.ok_changed do
            _config_manager.set_sound_volume(v);
        end
    end

    left.top  = left.top + 32;
    right.top = right.top + 32;

    // Music Volume
    var Label _ = Label.build("Music Volume", left);
    var SliderBox s3 = SliderBox.build(right, 25,
                        _config_manager.get_music_volume());
    spawn do
        var bool v;
        every v in s3.ok_changed do
            _config_manager.set_music_volume(v);
        end
    end

    left.top  = left.top + 32;
    right.top = right.top + 32;

    // CLOSE //

    var SurfaceButton close with
        this.x = {Display::get_width()/2}  + 245;
        this.y = {Display::get_height()/2} + 150;
        this.button         = "core/start/ok";
        this.button_pressed = "core/start/ok_clicked";
        this.button_over    = "core/start/ok_hover";
    end;

    par/or do
        every close.component.on_pointer_enter do
            call {Sound::PingusSound::play_sound}("tick");
        end
    with
        await close.component.on_click;
        call {Sound::PingusSound::play_sound}("yipee");
    with
        var _Input__ButtonEvent&& but =
            await ON_BUTTON_PRESSED
            until but:name  == {Input::ESCAPE_BUTTON};
    with
        every SDL_REDRAW do
            call {Fonts::chalk_large}.render(
                _origin_top_center,
                {Display::get_width()}/2,
                {Display::get_height()}/2 - 240,
                __("Option Menu"),
                *{Display::s_framebuffer}
            );

            call {Fonts::chalk_normal}.render(
                _origin_top_center,
                {Display::get_width()}/2  + 245 + 30,
                {Display::get_height()}/2 + 150 - 20,
                __("Close"),
                *{Display::s_framebuffer}
            );

            call {Fonts::chalk_normal}.render(
                _origin_top_left,
                {Display::get_width()}/2  - 320,
                {Display::get_height()}/2 + 200,
                __("Some options require a restart of the game to take effect."),
                *{Display::s_framebuffer}
            );
        end
    end

    {
        Pathname cfg_filename(System::get_userdir() + "config",
                              Pathname::SYSTEM_PATH);
    };
    _log_info("saving configuration: %1%", _cfg_filename);
    _config_manager.get_options().save(_cfg_filename);
#endif

    await FOREVER;
end

#endif
