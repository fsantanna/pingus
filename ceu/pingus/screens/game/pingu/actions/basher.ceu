#ifdef _BASHER_CEU
#error multiple include
#else
#define _BASHER_CEU

/* Defines the minimum "wall" height needed for a bash to happen. */
#define BASHER_MIN_BASH_HEIGHT 5

/* Defines the maximum height up to which a check is made to see if there
   is anything to bash.  Best to make this at least (min_bash_height +
   pingu_height). */
#define BASHER_MAX_BASH_HEIGHT 33

/* Defines the maximum no. of steps down a Basher can go down before it
   stops being a Basher and turns into a Faller. */
#define BASHER_MAX_STEPS_DOWN 3

code/await Basher (void) -> _ActionName__Enum
do
    vector[] byte left  = [] .. "pingus/player"
                          .. (call Pingu_Get_Owner_Str() as _char&&)
                          .. "/basher/left";
    vector[] byte right = [] .. "pingus/player"
                          .. (call Pingu_Get_Owner_Str() as _char&&)
                          .. "/basher/right";

    spawn RightLeftSprites(&outer.pingu.rect, &outer.pingu.direction, &left, &right, true);

    var int? bash_reach; // set in bash

    code/tight Bash (void) -> void do
        {
            static CollisionMask bash_radius(
                    "pingus/common/bash_radius_gfx",
                    "pingus/common/bash_radius");
            ceu_dbg_assert(bash_radius.get_width() % 2 == 0);
        };
        outer.bash_reach = {bash_radius.get_width()};

        call Game_Remove({&bash_radius},
                         outer.pingu.rect.left - {bash_radius.get_width() / 2},
                         outer.pingu.rect.top  - {bash_radius.get_height()} + 1);
    end

    // Start a bash even so the action will stops instantly after the first bash
    call Bash();

    /* UPDATE */
    var bool is_first_bash = true;
    loop i do
        await WORLD_UPDATE;
        await WORLD_UPDATE;
        await WORLD_UPDATE;

        if not this.walk_forward() then
            escape {ActionName::FALLER};
        end

        // If walking on to something (i.e. hasn't fallen)
        if this.pingu.rel_getpixel(0,-1) != {Groundtype::GP_NOTHING} then
            // If the Basher has walked into something that it won't be 
            // able to bash
            if this.pingu.rel_getpixel(0,0)             == {Groundtype::GP_SOLID} or
               this.pingu.rel_getpixel(0,_pingu_height) == {Groundtype::GP_SOLID}
            then
                // Change direction and let walk code walk forward/up to get out.
                { Sound::PingusSound::play_sound("chink"); };
                this.pingu.change_direction();
                escape {ActionName::WALKER};
            else/if is_first_bash or this.have_something_to_dig() then
                is_first_bash = false;
                // We only bash every second step, cause the Pingus would
                // get trapped otherwise in the bashing area.
                if i%2 == 1 then
                    this.bash();
                end
            else/if ((float)(sprites.get():get_current_frame())) /
                    ((float)(sprites.get():get_frame_count())) > 0.6
                // FIXME: Game logic must be separate from Sprite
                // FIXME: EVIL! Engine must not relay on graphic
            then
                escape {ActionName::WALKER};
            end
        end
    end

    /* PRIVATE */

    function (void)=>bool walk_forward do
        var int y_inc = 0;

        // Find the correct y position to go to next
        loop i in BASHER_MAX_STEPS_DOWN+1 do
            y_inc = -i;
            // If there is something below, get out of this loop
            if this.pingu.rel_getpixel(0, y_inc - 1) != {Groundtype::GP_NOTHING} then
                break;
            end
        end

        if y_inc < -BASHER_MAX_STEPS_DOWN then
            // The step down is too much.  So stop being a Basher and be a 
            // Faller.
            return false;
        else
            // Note that Pingu::set_pos() is the 'reverse' of the y co-ords of
            // rel_getpixel()
            this.pingu.set_pos(
                this.pingu.get_x() + (float)(this.pingu.direction),
                this.pingu.get_y() - (float)(y_inc)
            );
        end
        return true;
    end

    function (void)=>bool have_something_to_dig do
        // Check that there is something "within" the Basher's reach
        loop x in this.bash_reach!+1 do
            loop i in (BASHER_MAX_BASH_HEIGHT-BASHER_MIN_BASH_HEIGHT+1) do
                var int y = BASHER_MIN_BASH_HEIGHT + i;
                if this.pingu.rel_getpixel(x, y) == {Groundtype::GP_GROUND} then
                    _log_debug("Basher: Found something to dig...");
                    return true;
                end
            end
        end
        return false;
    end
end

#endif
