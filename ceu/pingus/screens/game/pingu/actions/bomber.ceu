#ifdef _BOMBER_CEU
#error multiple include
#else
#define _BOMBER_CEU

code/await Bomber (void) -> _ActionName__Enum
do
    vector[] byte bomber = [] .. "pingus/player"
                              .. (call Pingu_Get_Owner_Str() as _char&&)
                              .. "/bomber/left";
    {
        ##include "../../../src/pingus/collision_mask.hpp"
        static CollisionMask bomber_radius(
                "other/bomber_radius_gfx",
                "other/bomber_radius"
        );
    };

    call {Sound::PingusSound::play_sound}("ohno", 0.5, 0.0);

    var&? Sprite_from_name sprite =
        spawn Sprite_from_name(&outer.pingu.rect, &&bomber[0] as _char&&, true);

    watching sprite do
        spawn Mover();

        /* UPDATE */

        // SOUND
        await WORLD_UPDATE until sprite!.sprite.frame == 10;
        call {Sound::PingusSound::play_sound}("plop", 0.5, 0.0);

        // PARTICLES, TERRAIN, EXPLOSION

        await WORLD_UPDATE until sprite!.sprite.frame == 13;
        var int i;
        loop i in [0 -> 50[ do
            spawn PinguParticle(outer.pingu.rect.left,outer.pingu.rect.top-5) in outer.pingu_particles;
        end

        call Game_Remove({&bomber_radius},
                         outer.pingu.rect.left - {bomber_radius.get_width()/2},
                         outer.pingu.rect.top  - {bomber_radius.get_width()/2} - 16);

        do
            vector[] byte explo = [] .. "pingus/player"
                                     .. (call Pingu_Get_Owner_Str() as _char&&)
                                     .. "/explo";
            var&? Sprite_from_name s =
                spawn Sprite_from_name(&outer.pingu.rect, &&explo[0] as _char&&, true);
            s!.sprite.offset.x = 32;
            s!.sprite.offset.y = 48;
            await WORLD_UPDATE;
        end
    end

    escape {ActionName::DEAD};
end

#endif
