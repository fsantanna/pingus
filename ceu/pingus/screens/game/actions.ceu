#ifdef _BUTTONPANEL_CEU
#error multiple include
#else
#define _BUTTONPANEL_CEU

native/pre do
    std::vector<ActionName::Enum> ButtonPanel_actions;
    void ButtonPanel_load_actions (void) {
        ButtonPanel_actions = GLOBAL_ACTIONHOLDER->get_available_actions();
        std::sort(ButtonPanel_actions.begin(), ButtonPanel_actions.end());
    }
end

code/await Button (var    int x,
                   var    int y,
                   var    int i,
                   var    _ActionName__Enum id_me,
                   var&   int n,
                   event& int e)
            -> FOREVER
do
    var Rect r1 = val Rect(x,y, 60,38);

    var& IRectComponent component;
    spawn RectComponent(&r1) -> (&component);

    vector[] byte name = []
        .. "pingus/player0/"
        ..  ({ActionName::to_string}(id_me).c_str()) as _char&&
        .. "/right";

    par do
        var Rect r2 = val Rect(x+20,y+31, 0,0);   // TODO

        if i == 0 then
            spawn Sprite_from_name(&r1, "core/buttons/buttonbackgroundhl", false);

            var&? ISprite sprite;
            spawn Sprite_from_name(&r2, &&name[0] as _char&&, false)
                    -> (&sprite);
            sprite!.is_loop = true;

            outer.game.action_next = id_me;
            await e;
        end

        loop do
            do
                spawn Sprite_from_name(&r1, "core/buttons/buttonbackground", false);

                var&? ISprite sprite;
                spawn Sprite_from_name(&r2, &&name[0] as _char&&, false)
                        -> (&sprite);
                sprite!.frame_delay = 0;

                par/or do
                    await component.on_primary_button_pressed;
                with
                    var int ii = await e until ii==i;
                end
                outer.game.action_next = id_me;
                n = i;
                emit e(i);
            end
            do
                spawn Sprite_from_name(&r1, "core/buttons/buttonbackgroundhl", false);

                var&? ISprite sprite;
                spawn Sprite_from_name(&r2, &&name[0] as _char&&, false)
                        -> (&sprite);
                sprite!.is_loop = true;

                await e;
            end
        end
    with
        every SDL_REDRAW do
            if {globals::developer_mode} as bool then
#if 0
                {
                    std::ostringstream out;
                    std::string str = StringUtil::to_string(aholder->get_available(buttons[i].name));
                    out << aholder->get_available(buttons[i].name)
                        << " / "
                        << aholder->get_used(buttons[i].name);
                };
                gc:print_left(Fonts::pingus_small, Vector2i(rect.left + 46, rect.top + 5 + 38*static_cast<int>(i)), out.str());
#endif
            else
                call {Fonts::pingus_small}.render(
                    _origin_top_center,
                    x+46, y+5,
                    {StringUtil::to_string(GLOBAL_ACTIONHOLDER->get_available(@id_me))},
                    *{Display::s_framebuffer}
                );
            end
        end
    with
        loop do
            await component.on_pointer_enter;
            watching component.on_pointer_leave do
                every SDL_REDRAW do
                    call {Fonts::pingus_small}.render(
                        _origin_top_left,
                        x+65, y+5,
                        {ActionName::to_screenname}(id_me),
                        *{Display::s_framebuffer}
                    );
                end
            end
        end
    end
end

{ ButtonPanel_load_actions(); }

var   int max = {ButtonPanel_actions.size()};
var   int n = 0;
event int e;

var int x = 0;
var int y = ({Display::get_height()}-150)/2 - /// TODO: screen.size
                (max*38/2);

pool[] Button abs;
var int i;
loop i in [0 -> max[ do
    spawn Button(x, y+38*i, i, {ButtonPanel_actions[@i]}, &n, &e) in abs;
end

var _Input__ButtonEvent&& but;
every but in ON_BUTTON_PRESSED do
    var int inc = 0;
    if but:name >= {Input::ACTION_1_BUTTON} and
       but:name <= {Input::ACTION_10_BUTTON}
    then
        emit e(but:name - {Input::ACTION_1_BUTTON});
    else
        if but:name == {Input::ACTION_DOWN_BUTTON} then
            inc = 1;
        else/if but:name == {Input::ACTION_UP_BUTTON} then
            inc = -1;
        end
        if inc != 0 then
            n = (n+inc) % max;
            if n < 0 then
                n = n + max;
            end
            emit e(n);
        end
    end
end

#endif
