#ifndef _PINGUS_CEU
#define _PINGUS_CEU

#include "../../engine/display/sprite.ceu"
#include "../right_left_sprites.ceu"

native/pre do
    static WorldmapNS::Path edge_path;
end

class MovePath with
    var s8&       direction;
    var Vector3f& pos;
    var float&    cur;
do
    var float velocity = 70;
    loop do
        var int v    = await DELTA;
        var float dt = ((float)v)/1000;
        // Update the edge_path_position
        cur = cur + velocity * dt;

        if cur > _edge_path.length() then
            break; // target reached
        end

        // Recalc pingu position on the screen
        var float prv_x = this.pos.x;
        var float prv_y = this.pos.y;
        this.pos.x = _edge_path.at(cur).x;
        this.pos.y = _edge_path.at(cur).y;

        var float dir = ({Math::atan2}(prv_x-this.pos.x, -(prv_y-this.pos.y))
                            / {Math::pi}*180) + 180;
        if dir>=0 and dir<180 then
            this.direction = _RIGHT;
        else
            this.direction = _LEFT;
        end
    end
end

class Pingus with
    interface  IPositionDirection;
    var _WorldmapNS__NodeId node;

    var s8        direction = _NONE;
    var Rect      rect = Rect(0,0,0,0);
    var Vector3f& pos;

    event _WorldmapNS__NodeId go_walking;
    event _WorldmapNS__NodeId go_directly;

    var _WorldmapNS__PathGraph&& path;
do
    var _WorldmapNS__PathGraph&? path_;
    finalize
        path_ = &_XXX_NOHOLD(this.path);
    with
    end

    var char[] left  = [].."core/worldmap/pingus/left";
    var char[] right = [].."core/worldmap/pingus/right";
    var RightLeftSprites _ with
        this.none   = [].."core/worldmap/pingus_standing";
        this.left   = &left;
        this.right  = &right;
        this.parent = &outer;
    end;

    par do
        every DELTA do
            this.rect.left = this.pos.x;
            this.rect.top = this.pos.y;
        end
    with
        loop do
            par/or do
                var _WorldmapNS__NodeId target = await go_directly;
                this.pos.x = this.path_!.get_dot(target):get_pos().x;
                this.pos.y = this.path_!.get_dot(target):get_pos().y;
                this.node = target;
                this.direction = _NONE;
            with
                var _WorldmapNS__NodeId target = await go_walking;
                var float cur_position = 0;
                var int   cur_length   = 0;
                var _WorldmapNS__NodeId cur_node = this.node;
                loop do
                    {
                        static WorldmapNS::PathfinderResult res;
                        static std::vector<WorldmapNS::NodeId> node_path;
                    };
                    _res = _XXX_PURE(this.path_!.get_path(cur_node, target));
                    _node_path = _res.path;

                    _assert(not _node_path.empty());
                    var _WorldmapNS__NodeId src = _node_path.back();
                    _node_path.pop_back();

                    _assert(not _node_path.empty());
                    var _WorldmapNS__NodeId dst = _node_path.back();
                    _node_path.pop_back();

                    watching target in go_walking do
                        var Rect r = Rect(
                            path_!.get_dot(target):get_pos().x,
                            path_!.get_dot(target):get_pos().y,
                            0, 0
                            // TODO + Vector3f(0, 0, 10));
                        );
                        var Sprite _ = Sprite.build_name(&r, "core/worldmap/arrow");
                        loop i do
                            _edge_path.clear();
                            var _WorldmapNS__Path&& partial_path =
                                _XXX_PURE(path_!.graph.resolve_edge(src,dst).data);
                            _edge_path.push_back(path_!.graph.resolve_node(src).data:get_pos());
                            // Why do we need to reverse this?!
                            _edge_path.reverse_insert(*partial_path)
                                finalize with nothing; end;
                            _edge_path.push_back(path_!.graph.resolve_node(dst).data:get_pos());
                            cur_length = _edge_path.length();
                            this.node = _WorldmapNS__NoNode;
                            do MovePath with
                                this.direction = &outer.direction;
                                this.pos       = &outer.pos;
                                this.cur       = &cur_position;
                            end;
                            cur_position = 0;
                            cur_node = dst;
                            this.node = dst;

                            if _node_path.empty() then
                                break;
                            else
                                src = dst;
                                dst = _node_path.back();
                                _node_path.pop_back();
                            end
                        end
                        this.direction = _NONE;
                        break; // moved and finished normally
                    end

                    // awoke from "go_walking" during traversal

                    if target == dst then
                        // nothing to do
                    else/if target == src then
                        cur_node = dst;
                        cur_position = cur_length - cur_position;
                    else
                        // Pingu between two nodes
                        {
                            static WorldmapNS::PathfinderResult node_path1;
                            static WorldmapNS::PathfinderResult node_path2;
                        };
                        _node_path1 = _XXX_PURE(this.path_!.get_path(src, target));
                        _node_path2 = _XXX_PURE(this.path_!.get_path(dst, target));
                        if (_node_path1.cost+cur_position <
                            _node_path2.cost+(cur_length-cur_position))
                        then
                            _node_path = _node_path1.path;
                            cur_node = dst;
                            cur_position = cur_length - cur_position;
                            _node_path.insert(_node_path.begin(), dst);
                        else
                            _node_path = _node_path2.path;
                        end
                    end
                end
            end
        end
    end
end

#endif
