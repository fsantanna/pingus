#ifndef _WORLDMAP_CEU
#define _WORLDMAP_CEU

native/pre do
    static std::vector<FileReader> object_reader;
    std::vector<FileReader>::const_iterator i;
    static ResDescriptor desc;
    static SpriteDescription* spr;
    static bool          auto_uncover;

    static PingusWorldmap worldmap;
    static FileReader path_graph_reader;
    static std::unique_ptr<WorldmapNS::PathGraph> path_graph;
    static GraphicContextState gc_state;

    struct unlock_nodes
    {
      WorldmapNS::PathGraph* path_graph;

      unlock_nodes(WorldmapNS::PathGraph* g) :
        path_graph(g)
      {
      }

      void operator()(WorldmapNS::Node<WorldmapNS::Dot*>& node)
      {
        if (node.data->finished())
        {
          //log_info("Unlocking neightbours of: " << node.data);
          for (std::vector<WorldmapNS::EdgeId>::iterator i = node.next.begin(); i != node.next.end(); ++i)
          {
            WorldmapNS::Edge<WorldmapNS::Path*>& edge = path_graph->graph.resolve_edge(*i);

            // FIXME: This should be identical to node.data->unlock(), but not sure
            path_graph->graph.resolve_node(edge.source).data->unlock();
            path_graph->graph.resolve_node(edge.destination).data->unlock();
          }
        }
      }
    };

end

///#include "pingus.ceu"

#if 0
bool Worldmap::is_final_map() {
  return false;
  // TODO: return pingus->get_node() == final_node;
}
#endif

{
    worldmap = PingusWorldmap(filename);
    path_graph_reader = worldmap.get_graph();
    path_graph.reset(new WorldmapNS::PathGraph(path_graph_reader));

    //void Worldmap::update_locked_nodes()
    // FIXME: This shouldn't be a polling function
    //_path_graph:graph.for_each_node(_unlock_nodes(_path_graph.get()));
#if 0
  bool credits_unlocked = false;
  StatManager::instance()->get_bool(worldmap.get_short_name() + "-endstory-seen", credits_unlocked);

  if (!credits_unlocked)
  {
    // See if the last level is finished
    Dot* dot = path_graph->get_dot(final_node);
    if (dot)
    {
      if (dot->finished())
      {
        ScreenManager::instance()->push_screen(new StoryScreen(worldmap.get_end_story()));
      }
    }
    else
    {
      log_info("Error: Worldmap: Last level missing");
    }
  }
#endif

    gc_state.set_limit(
        Rect(Vector2i(0, 0),
        Size(worldmap.get_width(), worldmap.get_height())));

    Sound::PingusSound::play_music(worldmap.get_music());

    // Determine starting node
    // See if the user has played this map before.
    // If not, use the <default-node> tag from the XML file.
    static WorldmapNS__NodeId id;
    id = path_graph->lookup_node(worldmap.get_default_node());
    static std::string node_name;
    if (StatManager::instance()->get_string(worldmap.get_short_name() + "-current-node", node_name)) {
        // Just in case that level doesn't exist, look it up.
        id = path_graph->lookup_node(node_name);
    }
}

var Vector3f pst = val Vector3f({path_graph->get_dot(id)->get_pos().x},
                                {path_graph->get_dot(id)->get_pos().y},
                                0); 

code/tight Get_Offset (void)-> Vector2i;

code/tight Get_Offset (void)-> Vector2i do
    var int x = 0;
    do
        var int min;
        var int max;
        var int width  = {worldmap.get_width()};
        if width >= {Display::get_width()} then
            min = {Display::get_width()}/2;
            max = width - {Display::get_width()}/2;
        else
            min = width - {Display::get_width()}/2;
            max = {Display::get_width()}/2;
        end
        x = {Math::clamp}(min, outer.pst.x as int, max);
    end

    var int y = 0;
    do
        var int min;
        var int max;
        var int height = {worldmap.get_height()};
        if height >= {Display::get_height()} then
            min = {Display::get_height()}/2;
            max = height - {Display::get_height()}/2;
        else
            min = height - {Display::get_height()}/2;
            max = {Display::get_height()}/2;
        end
        y = {Math::clamp}(min, outer.pst.y as int, max);
    end

    var Vector2i ret = val Vector2i(x - {Display::get_width()}/2,
                                    y - {Display::get_height()}/2);
    escape ret;
end

// TODO
#if 0
  LevelDot* leveldot = dynamic_cast<LevelDot*>(path_graph->get_dot(id));
  if (leveldot) {
    leveldot->unlock();
  }
#endif

par do
    every outer.main.redraw do
        var Vector2i off = call Get_Offset();
        outer.main.offset = off;
        {gc_state.set_pos(Vector2i(@off.x, @off.y));}
    end
with
    { static FileReader* file_reader; }
    #include "sprite_drawable.ceu"
    // Create all objects
    pool[] SpriteDrawable draws;
    {
        static std::vector<FileReader> object_reader;
        static std::vector<FileReader>::const_iterator i1;
        object_reader = worldmap.get_objects();
        i1 = object_reader.begin();
    };
    loop do
        if {i1 == object_reader.end()} as bool then
            break;
        end
        //log_info("Worldmap::parse_objects: Parse Error");
        {
            DO
                const FileReader& f = *i1;
                file_reader = (FileReader*) &f;
        };
        spawn SpriteDrawable() in draws;
        {i1++;}
        {
            END
        }
    end

    // Create graph
    #include "dots.ceu"
    var EDot1 e = _;
    //pool IDot[] dots;
    pool[] StoryDot sds;
    {
        static const std::vector<FileReader>& childs =
            worldmap.get_graph().read_section("nodes").get_sections();
        static std::vector<FileReader>::const_iterator i2;
        i2 = childs.begin();
    };
    loop do
        if {i2 == childs.end()} as bool then
            break;
        end
        {
            DO
                const FileReader& f = *i2;
                file_reader = (FileReader*) &f;
        }
        if {file_reader->get_name() == "storydot"} as bool then
            spawn StoryDot(&e) in sds;
                //this.pos    = &pst;
                //this.e      = &dot;
                //this.is_story = true;
        else/if {file_reader->get_name() == "leveldot"} as bool then
#if 0
            spawn LevelDot in dots with
                this.reader = reader;
                this.pos    = &pst;
                this.e      = &dot;
                this.is_story = false;
            end;
#endif
        else
            _ceu_dbg_assert({!"DotFactory: unknown tag: "});// <<  reader.get_name());
        end
        {i2++;}
        {
            END
        }
    end

    spawn () do
        #include "pingus.ceu"
    end
#if 0
    var Pingus pingus with
        this.path = _XXX_PURE(_path_graph.get());
        this.node = id;
        this.pos  = &pst;
    end;
#endif

await FOREVER;
    //every (but,id_,status) in dot.ok_clicked do
#if 0
    loop do
        var int  id_;
        var int  status;
        var bool is_story;
        var bool show_credits;
        (id_,is_story,show_credits,status) = await dot.ok_clicked;
        if id_ == pingus.node then
            if {globals::developer_mode} then
                _log_info("Worldmap: Pingu is on node, issue on_click()");
            end
            if is_story then
                if show_credits then
                    escape _WORLDMAP_RETURN_STORY_CREDITS;
                else
                    escape _WORLDMAP_RETURN_STORY_MAP;
                end
            else
                escape _WORLDMAP_RETURN_LEVEL;
            end
        else
            if status == {Savegame::NONE} then
                call {Sound::PingusSound::play_sound}("chink");
            else
                call {StatManager::instance()}:set_string(
                    {worldmap.get_short_name() + "-current-node"},
                    _path_graph:lookup_node(id_)
                );
                emit pingus.go_walking => id_;
            end
        end
    end
#endif
#if 0
with
    every (x,y) in ON_PRIMARY_BUTTON_PRESSED do
        var Vector2i off = this.get_offset();
//_printf(">> xy=%d,%d, off=%d,%d\n", x,y, off.x,off.y);
        { static Vector2f click_pos; };
        _click_pos = _XXX_PURE(_Vector2i(off.x+x,off.y+y));
        {
            if (globals::developer_mode)
            {
                SExprFileWriter writer(std::cout);
                writer.begin_section("leveldot");
                writer.write_string("levelname", "");
                writer.begin_section("dot");
                writer.write_string("name", "leveldot_X");
                writer.write_vector("position", click_pos);
                writer.end_section();
                writer.end_section();
                std::cout << std::endl;
                std::cout << std::endl;
            }
        };
    end
with
    native do
        struct draw_edges
        {
            WorldmapNS::PathGraph* graph;
            Vector2i               off;

            draw_edges (WorldmapNS::PathGraph* graph, Vector2i off) :
                off(off), graph(graph)
            {}

            void operator()(WorldmapNS::Edge<WorldmapNS::Path*>& edge) {
                WorldmapNS::Dot* src = graph->get_dot(edge.source);
                WorldmapNS::Dot* dst = graph->get_dot(edge.destination);
                Display::s_framebuffer->draw_line(
                    Vector2i(off.x+src->get_pos().x,
                             off.y+src->get_pos().y),
                    Vector2i(off.x+dst->get_pos().x,
                             off.y+dst->get_pos().y),
                    Color(255, 255, 255)
                );
            }
        };
    end
    every REDRAW do
        if {globals::developer_mode} then
            var Vector2i off = global:worldmap!:get_offset();
            _path_graph:graph.for_each_edge(
                _draw_edges(_path_graph.get(), _Vector2i(off.x,off.y)));
        end
    end
#endif
with
    every outer.main.redraw do
        outer.main.offset = val Vector2i(0,0);
    end
end

#endif
