#ifndef _WORLD_CEU
#define _WORLD_CEU

native/pre do
    ///struct CEU_World;
    ##include "engine/display/graphic_context_state.hpp"
    ##include "pingus/ground_map.hpp"
    ##define Groundtype__GPType     Groundtype::GPType

    typedef CollisionMap* CollisionMap_ptr;
end

native/plain _Groundtype__GPType, _SmallMap, _SceneContext, _GroundMap, _CollisionMask;
native/plain _ActionName__Enum;

data IWorld with
    var  Rect                   rect;
    var& _GraphicContextState   state;
    var& int                    game_time;
    var  float                  gravity;

    event int                   ok_pingu;
    event (int,int,s8,int)      go_create_pingu;
    event (int,int)             go_create_pingu_particles;
    event (int,int,float,float) go_create_smoke_particles;
#if 0
    event void go_options;
    event void go_pause_toggle;
    event bool go_forward;
    event void go_armageddon;

    //var IWorldMap&&? worldmap;
    //var IWorld&&? world;

    //var char[] worldmap_return_filename;
#endif
end

data IVisible;
data IVisible.Aa;
code/await Visible (var& IVisible vis) -> FOREVER do
    await FOREVER;
end

#if 0
#include "particles/smoke_particle_holder.ceu"

#include "components/pingus_counter.ceu"
#include "smallmap_image.ceu"

#include "worldobjs/exit.ceu"
#include "worldobjs/guillotine.ceu"
#include "worldobjs/hotspot.ceu"
#include "worldobjs/laser_exit.ceu"
#include "worldobjs/liquid.ceu"
#include "worldobjs/spike.ceu"

#endif

#if 0
    function (void)=>Vector2i get_offset do
        var Vector2i ret =
            Vector2i(
                -(this.rect.left - this.rect.width/2),
                -(this.rect.top  - this.rect.height/2)
            );
        return ret;
    end
#endif

#include "world/action_button.ceu"
#include "world/button_panel.ceu"

code/await World (void) -> void
do
    var int w = {@outer.game_session.plf.get_size().width};
    var int h = {@outer.game_session.plf.get_size().height};

    var&? _GroundMap gfx_map_ =
        &{new GroundMap}(w, h)
            finalize (gfx_map_) with
                _delete(&&gfx_map_!);
            end;
    var& _GroundMap gfx_map = &gfx_map_!;

    var&? _GraphicContextState state =
        &{new GraphicContextState}({Math::min}({Display::get_width()},  w),
                                   {Math::min}({Display::get_height()}, h))
            finalize (state) with
                _delete(&&state!);
            end;

    var IWorld world = val IWorld(Rect(0,0,w,h), &state!, &outer.game_session.game_time,
                                  0.2, _,_,_,_);
    world.game_time = 0;

    world.state.set_limit({Rect(Vector2i(0,0), Size(@w,@h))});

    code/tight World_Get_Offset (void) -> Vector2i do
        var Vector2i ret = val Vector2i(
                                (outer.world.state.get_pos().x - outer.world.state.get_width()/2),
                                (outer.world.state.get_pos().y - outer.world.state.get_height()/2),
                           );
        escape ret;
    end

    code/tight World_Put (var _CollisionMask&& mask,var int x, var int y, var _Groundtype__GPType type) -> void do
        outer.gfx_map.put(mask:get_surface(), x, y);
        outer.gfx_map.get_colmap():put(*mask, x, y, type);
    end

    code/tight World_Remove (var _CollisionMask&& mask,var int x,var int y) -> void do
        outer.gfx_map.remove(mask:get_surface(), x, y);
        outer.gfx_map.get_colmap():remove(*mask, x, y);
    end

    code/tight World_Get_Colmap (void) -> _CollisionMap_ptr do
        escape outer.gfx_map.get_colmap();
    end

    #include "world/pingu.ceu"
    #include "world/pingu_holder.ceu"

    spawn do
        par do
            every SDL_REDRAW do
                outer.main.offset = call World_Get_Offset();
            end
        with
            every WORLD_UPDATE do
                world.game_time = world.game_time + 1;
            end
        with
            var Color ambient_light = val Color({@outer.game_session.plf.get_ambient_light()}.r,
                                                {@outer.game_session.plf.get_ambient_light()}.g,
                                                {@outer.game_session.plf.get_ambient_light()}.b,
                                                {@outer.game_session.plf.get_ambient_light()}.a);
            every SDL_REDRAW do
                call {Display::s_framebuffer}:fill_rect(
                    _Rect(0,0, {Display::get_width()},{Display::get_height()}),
                    _Color(ambient_light.r,
                           ambient_light.g,
                           ambient_light.b,
                           ambient_light.a)
                );
            end
        end
    end

    pool[] Visible layer_bg_0;          // background
    spawn do
        every SDL_REDRAW do             // groundpiece
            var Vector2i off = outer.main.offset;
            gfx_map.draw({Vector2i(-@off.x,-@off.y)});
        end
    end
    pool[] Visible layer_bg_1;          // liquid, hotspot
    pool[] Pingu pingus;

    spawn PinguHolder(&pingus, &outer.game_session.counter);

    #include "world/pingu_particle_holder.ceu"
    pool[] PinguParticle pingu_particles;

    #include "world/smoke_particle_holder.ceu"
    pool[] SmokeParticle smoke_particles;

    #include "world/time_display.ceu"
    spawn TimeDisplay();

    #include "world/pingus_counter.ceu"
    spawn PingusCounter();

    var int dwidth  = {Display::get_width()};
    var int dheight = {Display::get_height()};
    spawn ArmageddonButton(dwidth-40*1, dheight-62);
    spawn ForwardButton   (dwidth-40*2, dheight-62);
    spawn PauseButton     (dwidth-40*3, dheight-62);

    var& _ActionName__Enum buttonpanel_action;
    spawn ButtonPanel() -> (&buttonpanel_action);

    #include "world/playfield.ceu"
    spawn Playfield(&buttonpanel_action);

    var Vector2i pos_start = _;
    #include "world/objs.ceu"
    spawn WorldObj_Factory();

    world.state.set_pos(_Vector2i(pos_start.x,pos_start.y));
    world.rect.left = pos_start.x;
    world.rect.top  = pos_start.y;

    #include "world/goal_manager.ceu"
    watching GoalManager() do
        par do
            var int x,y;
            every (x,y) in world.go_create_pingu_particles do
                var int i;
                loop i in [0 -> 50[ do
                    spawn PinguParticle(x,y) in pingu_particles;
                end
            end
        with
            var int   x,y;
            var float vel_x,vel_y;
            every (x,y,vel_x,vel_y) in world.go_create_smoke_particles do
                spawn SmokeParticle(x,y, vel_x,vel_y) in smoke_particles;
            end
        with
            await outer.main.go_armageddon;

            {Sound::PingusSound::play_sound("goodidea");};

            var&? IPingu pingu;
            loop (pingu) in pingus do
                await WORLD_UPDATE;
                await WORLD_UPDATE;
                await WORLD_UPDATE;
                await WORLD_UPDATE;
                if pingu!.current_action != {ActionName::BOMBER} then
                    emit pingu!.go_action({ActionName::BOMBER});
                end
            end

            await FOREVER;
        with
            every SDL_REDRAW do
                outer.main.offset = val Vector2i(0,0);
            end
        end
    end
end

#endif
