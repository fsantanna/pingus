#ifndef _WORLD_CEU
#define _WORLD_CEU

native/pre do
    ///struct CEU_World;
    ##include "engine/display/graphic_context_state.hpp"
    ##include "pingus/ground_map.hpp"
    ##define Groundtype__GPType     Groundtype::GPType
end

native/plain _Groundtype__GPType, _SmallMap, _SceneContext, _GroundMap, _CollisionMask;
native/plain _ActionName__Enum;

data IWorld with
    var  Rect                 rect;
    var& _GraphicContextState state;
    var  Vector2i             offset;
    var& int                  game_time;

    event int                 ok_pingu;
    event (int,int,s8,int)    go_create_pingu;
#if 0
    var  float                gravity;
    event void go_options;
    event void go_pause_toggle;
    event bool go_forward;
    event void go_armageddon;
    event (float,float)             go_create_pingu_particles;
    event (float,float,float,float) go_create_smoke_particles;

    //var IWorldMap&&? worldmap;
    //var IWorld&&? world;

    //var char[] worldmap_return_filename;
#endif
end

data IVisible;
data IVisible.Aa;
code/await Visible (var& IVisible vis) -> FOREVER do
    await FOREVER;
end

#if 0
#include "particles/pingu_particle_holder.ceu"
#include "particles/smoke_particle_holder.ceu"

#include "components/playfield.ceu"
#include "components/smallmap.ceu"
#include "components/time_display.ceu"
#include "components/pingus_counter.ceu"
#include "capture_rectangle.ceu"
#include "smallmap_image.ceu"

#include "worldobjs/exit.ceu"
#include "worldobjs/guillotine.ceu"
#include "worldobjs/hotspot.ceu"
#include "worldobjs/laser_exit.ceu"
#include "worldobjs/liquid.ceu"
#include "worldobjs/smasher.ceu"
#include "worldobjs/spike.ceu"

#endif

#if 0
    function (void)=>Vector2i get_offset do
        var Vector2i ret =
            Vector2i(
                -(this.rect.left - this.rect.width/2),
                -(this.rect.top  - this.rect.height/2)
            );
        return ret;
    end
#endif

#include "world/action_button.ceu"
#include "world/button_panel.ceu"

code/await World (void) -> void
do
    var int w = {@outer.game_session.plf.get_size().width};
    var int h = {@outer.game_session.plf.get_size().height};

    var float gravity = 0.2;

    var&? _GroundMap gfx_map_ =
        &{new GroundMap}(w, h)
            finalize (gfx_map_) with
                _delete(&&gfx_map_!);
            end;
    var& _GroundMap gfx_map = &gfx_map_!;

    var&? _GraphicContextState state =
        &{new GraphicContextState}({Math::min}({Display::get_width()},  w),
                                   {Math::min}({Display::get_height()}, h))
            finalize (state) with
                _delete(&&state!);
            end;

    var IWorld world = val IWorld(Rect(0,0,w,h), &state!, _, &outer.game_session.game_time,
                                  _,_);
    world.game_time = 0;

    world.state.set_limit({Rect(Vector2i(0,0), Size(@w,@h))});

    code/tight World_Get_Offset (void) -> Vector2i do
        var Vector2i ret = val Vector2i(
                                (outer.world.state.get_pos().x - outer.world.state.get_width()/2),
                                (outer.world.state.get_pos().y - outer.world.state.get_height()/2),
                           );
        escape ret;
    end

    code/tight World_Put (var _CollisionMask&& mask,var int x,var int y,var _Groundtype__GPType type) -> void do
        outer.gfx_map.put(mask:get_surface(), x, y);
        outer.gfx_map.get_colmap():put(*mask, x, y, type);
    end

    code/tight World_Remove (var _CollisionMask&& mask,var int x,var int y) -> void do
        outer.gfx_map.remove(mask:get_surface(), x, y);
        outer.gfx_map.get_colmap():remove(*mask, x, y);
    end

    #include "world/pingu.ceu"
    #include "world/pingu_holder.ceu"

    spawn do
        par do
            every SDL_REDRAW do
                world.offset = call World_Get_Offset();
            end
        with
            every WORLD_UPDATE do
                world.game_time = world.game_time + 1;
            end
        with
            var Color ambient_light = val Color({@outer.game_session.plf.get_ambient_light()}.r,
                                                {@outer.game_session.plf.get_ambient_light()}.g,
                                                {@outer.game_session.plf.get_ambient_light()}.b,
                                                {@outer.game_session.plf.get_ambient_light()}.a);
            every SDL_REDRAW do
                call {Display::s_framebuffer}:fill_rect(
                    _Rect(0,0, {Display::get_width()},{Display::get_height()}),
                    _Color(ambient_light.r,
                           ambient_light.g,
                           ambient_light.b,
                           ambient_light.a)
                );
            end
        end
    end

    pool[] Visible layer_bg_0;          // background
    spawn do
        every SDL_REDRAW do             // groundpiece
            var Vector2i off = world.offset;
            gfx_map.draw({Vector2i(-@off.x,-@off.y)});
        end
    end
    pool[] Visible layer_bg_1;          // liquid, hotspot
    pool[] Pingu pingus;

    spawn PinguHolder(&pingus, &outer.game_session.counter);

#if 0
    pool PinguParticle[] pingu_particles;
    pool SmokeParticle[] smoke_particles;

    var TimeDisplay      _ = TimeDisplay.build(plf.get_time(), &game_time);
    var CPingusCounter   _ = CPingusCounter.build(&counter);
#endif

    var int dwidth  = {Display::get_width()};
    var int dheight = {Display::get_height()};
    spawn ArmageddonButton(dwidth-40*1, dheight-62);
    spawn ForwardButton   (dwidth-40*2, dheight-62);
    spawn PauseButton     (dwidth-40*3, dheight-62);

    var& _ActionName__Enum buttonpanel_action;
    spawn ButtonPanel() -> (&buttonpanel_action);
#if 0

    var Rect rect_big = Rect(
        {Math::max}(({Display::get_width()}-width)/2, 0),
        {Math::max}(({Display::get_height()}-height)/2, 0),
        {Math::min}({Display::get_width()},  width),
        {Math::min}({Display::get_height()}, height)
    );
    var Playfield playfield with
        this.action_next = &button_panel.action;
        this.pingus      = &pingus;
        this.rect        = &rect_big;
    end;

    var Rect rect_small = Rect(6,{Display::get_size}().height-105, 175,100);
    var SmallMapImage _ = SmallMapImage.build(&rect_small);
    var SmallMap smallmap with
        this.rect      = &rect_small;
        this.pingus    = &pingus;
        this.playfield = &playfield;
    end;

    var CaptureRectangle _ = CaptureRectangle.build(&playfield);
#endif

    var Vector2i pos_start = _;
    #include "world/objs.ceu"
    spawn WorldObj_Factory();

    await FOREVER;
#if 0
    this.state.set_pos(_Vector2i(pos_start.x,pos_start.y));
    this.rect.left = pos_start.x;
    this.rect.top  = pos_start.y;

    par/or do
        do GoalManager with
            this.plf = &plf;
            this.counter = &outer.counter;
            this.game_time = &game_time;
        end;
    with
        every (x_,y_) in global:go_create_pingu_particles do
            loop i in 50 do
                spawn PinguParticle in pingu_particles with
                    this.x = x_;
                    this.y = y_;
                end;
            end
        end
    with
        every (x_,y_,vel_x_,vel_y_) in global:go_create_smoke_particles do
            spawn SmokeParticle in smoke_particles with
                this.x     = x_;
                this.y     = y_;
                this.vel_x = vel_x_;
                this.vel_y = vel_y_;
            end;
        end
    with
        await global:go_armageddon;

        {Sound::PingusSound::play_sound("goodidea");};

        loop do
            loop i in 4 do
                await WORLD_UPDATE;
            end

            var IPingu&&? pingu;
            loop p in pingus do
                if p:current_action != {ActionName::BOMBER} then
                    pingu = p;
                    break;
                end
            end
            if pingu? then
                emit pingu!:go_action => {ActionName::BOMBER};
            else
                await FOREVER;
            end
        end
    with
        every REDRAW do
            global:offset = Vector2i(0,0);
        end
    end

    /* PUBLIC */

    function (void)=>_CollisionMap&& get_colmap do
        return _XXX_PURE(this.gfx_map!.get_colmap());
    end
#endif
end

#endif
