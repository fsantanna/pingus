#ifndef _SMALLMAP_CEU
#define _SMALLMAP_CEU

code/await SmallMap (void) -> FOREVER
do
    code/tight Is_At (var int x, var int y) -> bool do
        escape (x > outer.rect.left and
                x < outer.rect.left + outer.rect.width and
                y > outer.rect.top and
                y < outer.rect.top + outer.rect.height);
    end

    #include "smallmap_image.ceu"
    spawn SmallMapImage();

    par do
        loop do
            var int x,y;
            (x,y) = await ON_PRIMARY_BUTTON_PRESSED until call Is_At(x,y);
            watching ON_PRIMARY_BUTTON_RELEASED do
                loop do
                    // set view to the given COs
                    var int cx, cy;
                    cx = (x - outer.rect.left) * outer.world.rect.width / outer.rect.width;
                    cy = (y - outer.rect.top) * outer.world.rect.height / outer.rect.height;
                    call Playfield_Set_Viewpoint(cx, cy);
                    (x,y) = await ON_POINTER_MOVE until call Is_At(x,y);
                end
            end
        end
    with
        every SDL_REDRAW do
            var Vector2i vec = call Playfield_Get_Pos();
            {
                static Rect view_rect;
            };

            if (outer.world.rect.width > {Display::get_width()}) then
                var int rwidth = {Display::get_width()} * outer.rect.width / outer.world.rect.width;
                {
                    view_rect.left = @(outer.rect.left + (vec.x * outer.rect.width / outer.world.rect.width) - rwidth/2);
                    view_rect.right = view_rect.left + @rwidth;
                }
            else
                {
                    view_rect.left  = @outer.rect.left;
                    view_rect.right = @(outer.rect.left + outer.rect.width);
                }
            end

            if (outer.world.rect.height > {Display::get_height()}) then
                var int rheight = {Display::get_height()} * outer.rect.height / outer.world.rect.height;
                {
                    view_rect.top = @(outer.rect.top + (vec.y * outer.rect.height / outer.world.rect.height) - rheight/2);
                    view_rect.bottom = view_rect.top + @rheight;
                }
            else
                {
                    view_rect.top    = @outer.rect.top;
                    view_rect.bottom = @(outer.rect.top + outer.rect.height);
                }
            end

            {Display::s_framebuffer->draw_rect(view_rect, Color(255,255,0));}

            // Draw Pingus
            var&? IPingu pingu;
            loop (pingu) in outer.pingus do
                var int x = outer.rect.left + (pingu!.rect.left * outer.rect.width / outer.world.rect.width);
                var int y = outer.rect.top + (pingu!.rect.top * outer.rect.height / outer.world.rect.height);
                {Display::s_framebuffer->draw_line(Vector2i(@x, @y), Vector2i(@x, @y-2), Color(255,255,0));}
            end
        end
    end
end

#endif
