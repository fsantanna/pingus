#ifndef _SMALLMAP_CEU
#define _SMALLMAP_CEU

var Rect rect = val Rect(6,{Display::get_size}().height-105, 175,100);

code/tight Is_At (var int x, var int y) -> bool do
    escape (x > outer.rect.left and
            x < outer.rect.left + outer.rect.width and
            y > outer.rect.top and
            y < outer.rect.top + outer.rect.height);
end

par do
    do ()
        #include "smallmap_image.ceu"
    end
with
    loop do
        var int x,y;
        (x,y) = await ON_PRIMARY_BUTTON_PRESSED until call Is_At(x,y);
        watching ON_PRIMARY_BUTTON_RELEASED do
            loop do
                // set view to the given COs
                var int cx, cy;
                cx = (x - rect.left) * outer.world.rect.width / rect.width;
                cy = (y - rect.top) * outer.world.rect.height / rect.height;
                call World_Set_Viewpoint(cx, cy);
                (x,y) = await ON_POINTER_MOVE until call Is_At(x,y);
            end
        end
    end
with
    every SDL_REDRAW do
        var Vector2i vec = call World_Get_Pos();
        {
            static Rect view_rect;
        };

        if (outer.world.rect.width > {Display::get_width()}) then
            var int rwidth = {Display::get_width()} * rect.width / outer.world.rect.width;
            {
                view_rect.left = @(rect.left + (vec.x * rect.width / outer.world.rect.width) - rwidth/2);
                view_rect.right = view_rect.left + @rwidth;
            }
        else
            {
                view_rect.left  = @rect.left;
                view_rect.right = @(rect.left + rect.width);
            }
        end

        if (outer.world.rect.height > {Display::get_height()}) then
            var int rheight = {Display::get_height()} * rect.height / outer.world.rect.height;
            {
                view_rect.top = @(rect.top + (vec.y * rect.height / outer.world.rect.height) - rheight/2);
                view_rect.bottom = view_rect.top + @rheight;
            }
        else
            {
                view_rect.top    = @rect.top;
                view_rect.bottom = @(rect.top + rect.height);
            }
        end

        {Display::s_framebuffer->draw_rect(view_rect, Color(255,255,0));}

        // Draw Pingus
        var&? IPingu pingu;
        loop (pingu) in outer.pingus do
            var int x = rect.left + (pingu!.rect.left * rect.width  / outer.world.rect.width);
            var int y = rect.top  + (pingu!.rect.top  * rect.height / outer.world.rect.height);
            {Display::s_framebuffer->draw_line(Vector2i(@x, @y), Vector2i(@x, @y-2), Color(255,255,0));}
        end
    end
end

#endif
