#ifndef _PLAYFIELD_CEU
#define _PLAYFIELD_CEU

#include "engine/gui/rect_component.ceu"

code/await Playfield (var& _ActionName__Enum action_next) -> FOREVER
#if 0
    var   IPingu&&? current_pingu;
    event void      ok_pingu;
    pool IPingu[]& pingus;

    var Rect& rect;

    function (void)=>Vector2i get_pos;
    function (int x, int y)=>void set_viewpoint;
    function (int x, int y)=>void scroll;
    function (void)=>void update_layout;
#endif
do
    #define POS2VEC(m) _Vector2i(m.x,m.y)

    var Rect rect = val Rect(
        {Math::max}(({Display::get_width()}-outer.world.rect.width)/2, 0),
        {Math::max}(({Display::get_height()}-outer.world.rect.height)/2, 0),
        {Math::min}({Display::get_width()},  outer.world.rect.width),
        {Math::min}({Display::get_height()}, outer.world.rect.height)
    );

    var& IRectComponent component;
    spawn RectComponent(&rect) -> (&component);

    var Position mouse_pos = val Position(0,0);
    spawn do
        var int x, y;
        every (x,y) in ON_POINTER_MOVE do
            mouse_pos.x = x - rect.left;
            mouse_pos.y = y - rect.top;
        end
    end

    par do
        var int x, y;
        every (x,y) in component.on_primary_button_pressed do
            x = x - rect.left;
            y = y - rect.top;
            x = outer.world.state.screen2world(_Vector2i(x,y)).x;
            y = outer.world.state.screen2world(_Vector2i(x,y)).y;

            var float min_dist = 500.0;
            var bool? check;
            var&? IPingu pingu = do
                var&? IPingu p;
                loop (p) in outer.pingus do
                    if (call Pingu_Is_Over(x,y) in outer.pingus) then
                        var float dist = (call Pingu_Dist(x,y) in outer.pingus);
                        if (dist < min_dist) then
                            min_dist = dist;
                            check = (call Pingu_Check_Action(action_next) in outer.pingus);
                            escape &p;
                        end
                    end
                end
            end;

            if pingu? and check! then
                if {GLOBAL_ACTIONHOLDER->pop_action(@action_next)} as bool then
                    emit pingu!.go_action(action_next);
                end
            end
        end
    with
#if 0
        loop do
            var int x,y;
            (x,y) = await ON_SECONDARY_BUTTON_PRESSED;

            var Vector2i old_state_pos = val Vector2i(outer.world.state.get_pos().x,
                                                      outer.world.state.get_pos().y);

            var Vector2i scroll = val Vector2i(x - rect.left,
                                               y - rect.top);

            watching ON_SECONDARY_BUTTON_RELEASED do
                par do
                    every DELTA do
                        // FIXME: This should be delta dependant
                        if {globals::drag_drop_scrolling} then
                            outer.world.state.set_pos(
                                _Vector2i(old_state_pos.x,old_state_pos.y)
                                    + (_Vector2i(scroll.x,scroll.y)
                                        - POS2VEC(mouse_pos)));
                            outer.world.rect.left =
                                old_state_pos.x + scroll.x - mouse_pos.x;
                            outer.world.rect.top =
                                old_state_pos.y + scroll.y - mouse_pos.y;
                        else
                            outer.world.state.set_pos(
                                _Vector2i(outer.world.state.get_pos().x
                                            - (int)((float)(scroll.x - 
                                              mouse_pos.x) * 0.2),
                                          outer.world.state.get_pos().y
                                            - (int)((float)(scroll.y - 
                                              mouse_pos.y) * 0.2)
                                )
                            );
                            outer.world.rect.left =
                                outer.world.rect.left -
                                    ((float)(scroll.x - mouse_pos.x) * 0.2);
                            outer.world.rect.top =
                                outer.world.rect.top -
                                    ((float)(scroll.y - mouse_pos.y) * 0.2);
                        end
                    end
                with
                    every REDRAW do
                        if {globals::drag_drop_scrolling} then
                            continue;
                        end
                        call {Display::s_framebuffer}:draw_line(
                            _Vector2i(10,10),
                            _Vector2i(300,300),
                            _Color(0, 255, 0)
                        );
                        call {Display::s_framebuffer}:draw_line(
                            POS2VEC(mouse_pos),
                            _Vector2i(scroll.x, scroll.y-15),
                            _Color(0, 255, 0)
                        );
                        call {Display::s_framebuffer}:draw_line(
                            POS2VEC(mouse_pos),
                            _Vector2i(scroll.x, scroll.y+15),
                            _Color(0, 0, 255)
                        );
                        call {Display::s_framebuffer}:draw_line(
                            POS2VEC(mouse_pos),
                            _Vector2i(scroll.x+15, scroll.y),
                            _Color(0, 255, 255)
                        );
                        call {Display::s_framebuffer}:draw_line(
                            POS2VEC(mouse_pos),
                            _Vector2i(scroll.x-15, scroll.y),
                            _Color(255, 255, 0)
                        );
                        call {Display::s_framebuffer}:draw_line(
                            POS2VEC(mouse_pos),
                            _Vector2i(scroll.x, scroll.y),
                            _Color(255, 0, 0)
                        );
                    end
                end
            end
        end
    with
        var bool was_empty = true;
            // having current_pingu&&? is not enough because it can die and 
            // clear the variable

        every DELTA do
            var Position pos = Position(
                                outer.world.state.screen2world(POS2VEC(mouse_pos)).x,
                                outer.world.state.screen2world(POS2VEC(mouse_pos)).y
                               );

            var float min_dist = 500.0;
            var IPingu&&? cur;
            loop p in pingus do
                if p:is_over((int)pos.x, (int)pos.y) then
                    var float dist = p:dist((int)pos.x, (int)pos.y);
                    if (dist < min_dist) then
                        min_dist = dist;
                        cur = p;
                    end
                end
            end

            var bool has_changed;
            if cur? then
                has_changed = was_empty or
                              (current_pingu? and (cur! != current_pingu!));
            else
                has_changed = (not was_empty);
            end

            current_pingu = cur;
            was_empty = (not cur?);
            if has_changed then
                emit ok_pingu;
            end
        end
    with
        every v in DELTA do
            var float dt = ((float)v)/1000;
            if ({globals::auto_scrolling} and
                ({Display::is_fullscreen()} or 
                    _SDL_WM_GrabInput(_SDL_GRAB_QUERY) == _SDL_GRAB_ON))
            then
                var int scroll_speed = (int)(800 * dt);

                if (mouse_pos.x < 10) then
                    outer.world.state.set_pos(outer.world.state.get_pos() - _Vector2i(scroll_speed, 0));
                    outer.world.rect.left = outer.world.rect.left - scroll_speed;
                else/if (mouse_pos.x > {Display::get_width()} - 10) then
                    outer.world.state.set_pos(outer.world.state.get_pos() + _Vector2i(scroll_speed, 0));
                    outer.world.rect.left = outer.world.rect.left + scroll_speed;
                end

                if (mouse_pos.y < 10) then
                    outer.world.state.set_pos(outer.world.state.get_pos() - _Vector2i(0, scroll_speed));
                    outer.world.rect.top = outer.world.rect.top - scroll_speed;
                else/if (mouse_pos.y > {Display::get_height()} - 10) then
                    outer.world.state.set_pos(outer.world.state.get_pos() + _Vector2i(0, scroll_speed));
                    outer.world.rect.top = outer.world.rect.top + scroll_speed;
                end
            end
        end
#endif
    end

    /* PUBLIC */

#if 0
    function (void)=>Vector2i get_pos do
        var Vector2i ret = Vector2i((int)(outer.world.state.get_pos().x),
                                    (int)(outer.world.state.get_pos().y));
        return ret;
    end

    function (int x, int y)=>void set_viewpoint do
        outer.world.state.set_pos(_Vector2i(x, y));
        outer.world.rect.left = x;
        outer.world.rect.top  = y;
    end

    function (int x, int y)=>void scroll do
        outer.world.state.set_pos(outer.world.state.get_pos() + _Vector2i(x, y));
        outer.world.rect.left = outer.world.rect.left + x;
        outer.world.rect.top  = outer.world.rect.top  + y;
    end

    function (void)=>void update_layout do
        outer.world.state.set_size(outer.rect.width, outer.rect.height);
    end
#endif
end

#endif
