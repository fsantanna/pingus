#ifndef _PINGU_CEU
#define _PINGU_CEU

native/pre do
    ##define ActionName__Enum ActionName::Enum
    ##define Pingu__PinguStatus Pingu::PinguStatus
    ##define PinguAction_shared_ptr std::shared_ptr<PinguAction>
    enum {
        PS_ALIVE, PS_EXITED, PS_DEAD
    };
end
native/plain _Pingu__PinguStatus;

native/pre do
    ##include "pingus/collision_map.hpp"
    ##include "pingus/pingu_enums.hpp"
    ///##define GC_COLOR_DRAW(gc,x,y) gc->color().draw(x,y)
    enum Dir { LEFT = -1, NONE = 0, RIGHT = +1 };
end
///native @nohold _GC_COLOR_DRAW();

native/pre do
    class Vector3f;
    class GroundMap;
    class PinguHolder;
    class PingusLevel;
    class CollisionMap;
    class Pingu;
    class SmallMap;
    class SceneContext;
    ##include "pingus/collision_mask.hpp"
    ##include "../src/pingus/groundtype.hpp"
    ##include "../src/pingus/action_name.hpp"
end

#if 0
#include "../engine/display/sprite.ceu"
#include "actions/basher.ceu"
#include "actions/blocker.ceu"
#include "actions/bomber.ceu"
#include "actions/bridger.ceu"
#include "actions/climber.ceu"
#include "actions/digger.ceu"
#include "actions/drown.ceu"
#include "actions/exiter.ceu"
#include "actions/floater.ceu"
#include "actions/jumper.ceu"
#include "actions/laser_kill.ceu"
#include "actions/miner.ceu"
#include "actions/splashed.ceu"
#include "actions/slider.ceu"
#include "actions/waiter.ceu"
#endif

#include "pingus/right_left_sprites.ceu"

data IPingu with
    var Rect     rect;
    var s8       direction;
    var Vector3f velocity = val Vector3f(0, 0, 0);

    vector[] byte name;

    event _ActionName__Enum go_action;
end

code/await Pingu (pool&[] Pingu  pingus,
                  var     uint   id,
                  var     int    owner_id,
                  var     Rect   rect_,
                  var     s8?    direction_)
                    -> (var&? IPingu pingu_)
                        -> void
do
    if not direction_? then
        direction_ = {LEFT};
    end

    var IPingu pingu = val IPingu(rect_, direction_!, _,_,_);
    pingu_ = &pingu;

    var _ActionName__Enum current_action = {ActionName::FALLER};
    var _ActionName__Enum wall_action    = {ActionName::NONE};
    var _ActionName__Enum fall_action    = {ActionName::NONE};

    #include "pingu/tights.ceu"
    #include "pingu/mover.ceu"
    #include "pingu/actions/walker.ceu"
    #include "pingu/actions/faller.ceu"
    #include "pingu/actions/splashed.ceu"

    var int ret =
    do
        event _ActionName__Enum e_set_action;
        par do
            loop do
                await WORLD_UPDATE;

                // FIXME: Out of screen check is ugly
                /* The Pingu has hit the edge of the screen, a good time to let
                   him die.
                 */
                if call Pingu_Rel_Getpixel(0,-1) == {Groundtype::GP_OUTOFSCREEN} then
                    //Sound::PingusSound::play_sound("die");
    // TODO: copied from walker.ceu
                    pingu.rect.left = (pingu.rect.left + (pingu.direction as int));
                    escape {PS_DEAD};
                end

                if call Pingu_Rel_Getpixel(0,-1) == {Groundtype::GP_WATER} or
                   call Pingu_Rel_Getpixel(0,-1) == {Groundtype::GP_LAVA}
                then
                    emit e_set_action({ActionName::DROWN});
                    break;  // no more checks, will die
                end


                // if it has hit the ground too quickly
                if call Pingu_Rel_Getpixel(0,-1) != {Groundtype::GP_NOTHING} and
                        pingu.velocity.y > {deadly_velocity}
                then
                    emit e_set_action({ActionName::SPLASHED});
                    break;  // no more checks, will die
                end
            end
            await FOREVER;
        with
            var _ActionName__Enum new_action;
            every new_action in pingu.go_action do
                if new_action!={ActionName::EXITER} and new_action!={ActionName::LASERKILL} then
                    _ceu_dbg_assert(call Pingu_Check_Action(new_action));
                end
                if not call Pingu_Check_Action(new_action) then
                    continue;
                end

                var int mode = {ActionName::ACTIVATION_MODE}[new_action];

                if mode == {ActionType::INSTANT} then
                    if new_action != current_action and
                       ({ActionName::CHANGE_ALLOWED}
                            [current_action][new_action] as bool)
                    then
                        emit e_set_action(new_action);
                    end
                else/if mode == {ActionType::WALL_TRIGGERED} then
                    wall_action = new_action;
                else/if mode == {ActionType::FALL_TRIGGERED} then
                    fall_action = new_action;
                end
            end
        with
            loop do
                pingu.name = [] .. {ActionName::to_screenname}(current_action) as _char&&;
                par/or do
                    current_action = await e_set_action;
                with
                    if current_action == {ActionName::NONE} then
                        _ceu_dbg_assert({!"invalid action"});
                        await FOREVER;
                    else/if current_action == {ActionName::DEAD} then
                        escape {PS_DEAD};
#if 0
                    else/if current_action == {ActionName::BASHER} then
                        current_action = DO_PINGU_ACTION(Basher);
                    else/if current_action == {ActionName::BLOCKER} then
                        current_action = DO_PINGU_ACTION(Blocker);
                    else/if current_action == {ActionName::BOMBER} then
                        current_action = DO_PINGU_ACTION(Bomber);
                    else/if current_action == {ActionName::BRIDGER} then
                        current_action = DO_PINGU_ACTION(Bridger);
                    else/if current_action == {ActionName::CLIMBER} then
                        current_action = DO_PINGU_ACTION(Climber);
                    else/if current_action == {ActionName::DIGGER} then
                        current_action = DO_PINGU_ACTION(Digger);
                    else/if current_action == {ActionName::DROWN} then
                        current_action = DO_PINGU_ACTION(Drown);
                    else/if current_action == {ActionName::EXITER} then
                        current_action = DO_PINGU_ACTION(Exiter);
                        escape _PS_EXITED;
#endif
                    else/if current_action == {ActionName::FALLER} then
                        current_action = await Faller();
                    else/if current_action == {ActionName::FLOATER} then
                        current_action = DO_PINGU_ACTION(Floater);
#if 0
                    else/if current_action == {ActionName::JUMPER} then
                        current_action = DO_PINGU_ACTION(Jumper);
                    else/if current_action == {ActionName::LASERKILL} then
                        current_action = DO_PINGU_ACTION(LaserKill);
                    else/if current_action == {ActionName::MINER} then
                        current_action = DO_PINGU_ACTION(Miner);
                    else/if current_action == {ActionName::SLIDER} then
                        current_action = DO_PINGU_ACTION(Slider);
#endif
                    else/if current_action == {ActionName::SPLASHED} then
                        current_action = await Splashed();
#if 0
                    else/if current_action == {ActionName::WAITER} then
                        current_action = DO_PINGU_ACTION(Waiter);
#endif
                    else/if current_action == {ActionName::WALKER} then
                        current_action = await Faller();
                    else
_printf(">>> %d\n", current_action);
                        _ceu_dbg_assert({!"Invalid action name provied"});
                        await FOREVER;
                    end
                end
            end
        end
    end;

    _ceu_dbg_assert(ret != {PS_ALIVE});
    emit outer.world.ok_pingu(ret);

#if 0
    /* END-OF-BODY */

    /* PUBLIC */

    function (void)=>int get_xi do
        return (int)this.rect.left;
    end
    function (void)=>int get_yi do
        return (int)this.rect.top;
    end

    function (s8 d)=>void set_direction do
        this.direction = d;
    end

    function (int x1, int y1, int x2, int y2)=>bool is_inside do
        _assert (x1 < x2);
        _assert (y1 < y2);

        return (this.rect.left > x1 and
                this.rect.left < x2 and
                this.rect.top > y1 and
                this.rect.top < y2);
    end

    function (void)=>int get_id do
        return this.id;
    end

    function (void)=>int get_owner do
        return this.owner_id;
    end

    void
    Pingu::apply_force (Vector3f arg_v)
    {
      velocity += arg_v;
      // Moving the pingu on pixel up, so that the force can take effect
      // FIXME: this should be handled by a state-machine
      --rect.top;
    }
#endif
end

#endif
