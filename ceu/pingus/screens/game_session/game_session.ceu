#ifndef _GAME_SESSION
#define _GAME_SESSION

native/pre do
    ##include "pingus/result.hpp"
    ##include "pingus/savegame.hpp"
    ##include "pingus/savegame_manager.hpp"
    ##include "engine/screen/screen_manager.hpp"
    ##include "pingus/action_holder.hpp"
    ##include "engine/display/graphic_context_state.hpp"
    ##include "pingus/ground_map.hpp"
    ##define Groundtype__GPType     Groundtype::GPType
    typedef CollisionMap* CollisionMap_ptr;
    static ActionHolder* GLOBAL_ACTIONHOLDER = NULL;
end

native/plain _Groundtype__GPType, _SmallMap, _SceneContext, _GroundMap, _CollisionMask;
native/plain _ActionName__Enum;

data PingusCounter with
    var int number_of_exited;
    var int number_of_killed;
    var int number_of_alive;
    var int number_of_released;
    var int number_of_allowed;
    var int number_to_save;
end

data IGameSession with
    var&  _PingusLevel  plf;
    var   int           game_time;
    var   PingusCounter counter;
    event void          go_armageddon;
end

data IWorld with
    var  Rect                   rect;
    var& _GraphicContextState   state;
    var  float                  gravity     = 0.2;
    var  _ActionName__Enum      action_next = {ActionName::WALKER};
end

code/await GameSession (var& _PingusLevel plf_) -> void
do
    var bool is_paused         = false;
    var bool is_fast_forwarded = false;
    var bool do_single_step    = false;

    {
        GLOBAL_ACTIONHOLDER = new ActionHolder(@plf_);
        result.plf = @plf_;
    }

    /// TODO: from "on_startup", called on creation and when popped back
    if {globals::developer_mode} as bool then
        _log_info("Starting Music: %1%", plf_.get_music());
    end
    if plf_.get_music()=="none" or (plf_.get_music().empty() as bool) then
        {Sound::PingusSound::stop_music();};
    else
        call {Sound::PingusSound::play_music}(plf_.get_music());
    end

    var IGameSession game_session =
        val IGameSession(&plf_, 0,
                         PingusCounter(0,0,0,0,
                                       plf_.get_number_of_pingus(),
                                       plf_.get_number_to_save()),
                         _);

    code/tight GameSession_Pingu_In (void) -> bool
    do
        if outer.game_session.counter.number_of_released < outer.game_session.counter.number_of_allowed then
            outer.game_session.counter.number_of_released = outer.game_session.counter.number_of_released + 1;
            outer.game_session.counter.number_of_alive    = outer.game_session.counter.number_of_alive    + 1;
            escape true;
        else
            escape false;
        end
    end

    code/tight GameSession_Pingu_Out (var int status) -> void do
        if status == {PS_DEAD} then
//_assert(0);
            outer.game_session.counter.number_of_killed = outer.game_session.counter.number_of_killed + 1;
        else/if status == {PS_EXITED} then
            outer.game_session.counter.number_of_exited = outer.game_session.counter.number_of_exited + 1;
        else
            _ceu_dbg_assert(status != {PS_ALIVE});
        end
        outer.game_session.counter.number_of_alive = outer.game_session.counter.number_of_alive - 1;
        _ceu_dbg_assert(outer.game_session.counter.number_of_released == outer.game_session.counter.number_of_alive  +
                                                      outer.game_session.counter.number_of_killed +
                                                      outer.game_session.counter.number_of_exited);
    end

    par/or do
        every WORLD_UPDATE do
            game_session.game_time = game_session.game_time + 1;
        end
    with
        do ()
            #include "world.ceu"
        end
    with
        #include "input.ceu"
    end

    {
        result.saved     = @game_session.counter.number_of_exited;
        result.killed    = @game_session.counter.number_of_killed;
        result.total     = result.plf.get_number_of_pingus();
        result.needed    = result.plf.get_number_to_save();
        result.max_time  = result.plf.get_time();
        result.used_time = @game_session.game_time;

        // Write the savegame
        {
            Savegame savegame(result.plf.get_resname(),
                            (result.saved >= result.needed) ?  Savegame::FINISHED : 
                            Savegame::ACCESSIBLE,
                            result.used_time,
                            result.saved);
            SavegameManager::instance()->store(savegame);
        }
    };
end

#endif
