#ifndef _GAME_SESSION
#define _GAME_SESSION

native/pre do
    ##include "pingus/result.hpp"
    ##include "pingus/savegame.hpp"
    ##include "pingus/savegame_manager.hpp"
    ##include "engine/screen/screen_manager.hpp"
    ##include "pingus/action_holder.hpp"
    ##include "engine/display/graphic_context_state.hpp"
    ##include "pingus/ground_map.hpp"
    ##define Groundtype__GPType     Groundtype::GPType
    typedef CollisionMap* CollisionMap_ptr;
    static ActionHolder* GLOBAL_ACTIONHOLDER = NULL;
end

native/plain _Groundtype__GPType, _SmallMap, _SceneContext, _GroundMap, _CollisionMask;
native/plain _ActionName__Enum;

data PingusCounter with
    var int number_of_exited;
    var int number_of_killed;
    var int number_of_alive;
    var int number_of_released;
    var int number_of_allowed;
    var int number_to_save;
end

data IGameSession with
    var&  _PingusLevel  plf;
    var   int           game_time;
    var   PingusCounter counter;
    event void          go_armageddon;
end

data IWorld with
    var  Rect                   rect;
    var& _GraphicContextState   state;
    var  float                  gravity     = 0.2;
    var  _ActionName__Enum      action_next = {ActionName::WALKER};
end

code/await GameSession (var& _PingusLevel plf_) -> void
do
    {
        GLOBAL_ACTIONHOLDER = new ActionHolder(@plf_);
        result.plf = @plf_;
    }

    /// TODO: from "on_startup", called on creation and when popped back
    if {globals::developer_mode} as bool then
        _log_info("Starting Music: %1%", plf_.get_music());
    end
    if plf_.get_music()=="none" or (plf_.get_music().empty() as bool) then
        {Sound::PingusSound::stop_music();};
    else
        call {Sound::PingusSound::play_music}(plf_.get_music());
    end

    var IGameSession game_session =
        val IGameSession(&plf_, 0,
                         PingusCounter(0,0,0,0,
                                       plf_.get_number_of_pingus(),
                                       plf_.get_number_to_save()),
                         _);

    code/tight GameSession_Pingu_In (void) -> bool
    do
        if outer.game_session.counter.number_of_released < outer.game_session.counter.number_of_allowed then
            outer.game_session.counter.number_of_released = outer.game_session.counter.number_of_released + 1;
            outer.game_session.counter.number_of_alive    = outer.game_session.counter.number_of_alive    + 1;
            escape true;
        else
            escape false;
        end
    end

    code/tight GameSession_Pingu_Out (var int status) -> void do
        if status == {PS_DEAD} then
//_assert(0);
            outer.game_session.counter.number_of_killed = outer.game_session.counter.number_of_killed + 1;
        else/if status == {PS_EXITED} then
            outer.game_session.counter.number_of_exited = outer.game_session.counter.number_of_exited + 1;
        else
            _ceu_dbg_assert(status != {PS_ALIVE});
        end
        outer.game_session.counter.number_of_alive = outer.game_session.counter.number_of_alive - 1;
        _ceu_dbg_assert(outer.game_session.counter.number_of_released == outer.game_session.counter.number_of_alive  +
                                                      outer.game_session.counter.number_of_killed +
                                                      outer.game_session.counter.number_of_exited);
    end

    var int w = {@game_session.plf.get_size().width};
    var int h = {@game_session.plf.get_size().height};

    var&? _GroundMap gfx_map_ =
        &{new GroundMap}(w, h)
            finalize (gfx_map_) with
                _delete(&&gfx_map_!);
            end;
    var& _GroundMap gfx_map = &gfx_map_!;

    var&? _GraphicContextState state =
        &{new GraphicContextState}({Math::min}({Display::get_width()},  w),
                                   {Math::min}({Display::get_height()}, h))
            finalize (state) with
                _delete(&&state!);
            end;

    var IWorld world = val IWorld(Rect(0,0,w,h), &state!, _,_);

    world.state.set_limit({Rect(Vector2i(0,0), Size(@w,@h))});

    code/tight World_Get_Offset (void) -> Vector2i do
        var Vector2i ret = val Vector2i(
                                (outer.world.state.get_pos().x - outer.world.state.get_width()/2),
                                (outer.world.state.get_pos().y - outer.world.state.get_height()/2),
                           );
        escape ret;
    end

    code/tight World_Put (var _CollisionMask&& mask,var int x, var int y, var _Groundtype__GPType type) -> void do
        outer.gfx_map.put(mask:get_surface(), x, y);
        outer.gfx_map.get_colmap():put(*mask, x, y, type);
    end

    code/tight World_Remove (var _CollisionMask&& mask,var int x,var int y) -> void do
        outer.gfx_map.remove(mask:get_surface(), x, y);
        outer.gfx_map.get_colmap():remove(*mask, x, y);
    end

    code/tight World_Get_Colmap (void) -> _CollisionMap_ptr do
        escape outer.gfx_map.get_colmap();
    end

    code/tight World_Get_Pos (void) -> Vector2i do
        var Vector2i ret = val Vector2i(outer.world.state.get_pos().x,
                                        outer.world.state.get_pos().y);
        escape ret;
    end

    code/tight World_Set_Viewpoint (var int x, var int y) -> void do
        outer.world.state.set_pos(_Vector2i(x, y));
        outer.world.rect.left = x;
        outer.world.rect.top  = y;
    end

    var Rect rect_play = val Rect(
        {Math::max}(({Display::get_width()}-world.rect.width)/2, 0),
        {Math::max}(({Display::get_height()}-world.rect.height)/2, 0),
        {Math::min}({Display::get_width()},  world.rect.width),
        {Math::min}({Display::get_height()}, world.rect.height)
    );

    par/or do
        do ()
            #include "goal_manager.ceu"
        end
    with
        every WORLD_UPDATE do
            game_session.game_time = game_session.game_time + 1;
        end
    with
        do ()
            #include "input.ceu"
        end
    with
        every SDL_REDRAW do
            outer.main.offset = call World_Get_Offset();
        end
    with
        var Color ambient_light = val Color({@game_session.plf.get_ambient_light()}.r,
                                            {@game_session.plf.get_ambient_light()}.g,
                                            {@game_session.plf.get_ambient_light()}.b,
                                            {@game_session.plf.get_ambient_light()}.a);
        every SDL_REDRAW do
            call {Display::s_framebuffer}:fill_rect(
                _Rect(0,0, {Display::get_width()},{Display::get_height()}),
                _Color(ambient_light.r,
                       ambient_light.g,
                       ambient_light.b,
                       ambient_light.a)
            );
        end
    with
        data IVisible;
        data IVisible.Aa;
        code/await Visible (var& IVisible vis) -> FOREVER do
            await FOREVER;
        end

        pool[] Visible layer_bg_0;          // background
        spawn do
            every SDL_REDRAW do             // groundpiece
                var Vector2i off = outer.main.offset;
                gfx_map.draw({Vector2i(-@off.x,-@off.y)});
            end
        end
        pool[] Visible layer_bg_1;          // liquid, hotspot

        #include "pingu/pingu.ceu"
        pool[] Pingu pingus;

        var uint id = 0;
        code/await Pingu_Spawn (var int owner_id, var int x, var int y, var s8 dir) -> void
        do
            if call GameSession_Pingu_In() then
                outer.id = outer.id+1;
                var Rect r = val Rect(x,y,0,0);
                spawn Pingu(&outer.pingus,outer.id,owner_id,r,dir) in outer.pingus;
            end
        end

        par do
            do ()
                #include "objs/objs.ceu"
            end
        with
            await game_session.go_armageddon;

            {Sound::PingusSound::play_sound("goodidea");};

            var&? IPingu pingu;
            loop (pingu) in pingus do
                await WORLD_UPDATE;
                await WORLD_UPDATE;
                await WORLD_UPDATE;
                await WORLD_UPDATE;
                if pingu!.current_action != {ActionName::BOMBER} then
                    emit pingu!.go_action({ActionName::BOMBER});
                end
            end

            await FOREVER;
        with
            do ()
                #include "smallmap.ceu"
            end
#if 0
        with
            do ()
                #include "capture_rectangle.ceu"
            end
#endif
        with
            do ()
                #include "time_display.ceu"
            end
        with
            do ()
                #include "pingus_counter.ceu"
            end
        with
            do ()
                #include "action_button.ceu"
            end
        with
            do ()
                #include "button_panel.ceu"
            end
        with
            do ()
                #include "playfield.ceu"
            end
        end
    with
        every SDL_REDRAW do
            outer.main.offset = val Vector2i(0,0);
        end
    end

    {
        result.saved     = @game_session.counter.number_of_exited;
        result.killed    = @game_session.counter.number_of_killed;
        result.total     = result.plf.get_number_of_pingus();
        result.needed    = result.plf.get_number_to_save();
        result.max_time  = result.plf.get_time();
        result.used_time = @game_session.game_time;

        // Write the savegame
        {
            Savegame savegame(result.plf.get_resname(),
                            (result.saved >= result.needed) ?  Savegame::FINISHED : 
                            Savegame::ACCESSIBLE,
                            result.used_time,
                            result.saved);
            SavegameManager::instance()->store(savegame);
        }
    };
end

#endif
