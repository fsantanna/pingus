#ifndef _GAME_SESSION
#define _GAME_SESSION

native/pre do
    ##include "pingus/result.hpp"
    ##include "pingus/savegame.hpp"
    ##include "pingus/savegame_manager.hpp"
    ##include "engine/screen/screen_manager.hpp"
    ##include "pingus/action_holder.hpp"

    static ActionHolder* GLOBAL_ACTIONHOLDER = NULL;
end

#if 0
#include "../goal_manager.ceu"
#endif

data PingusCounter with
    var int number_of_exited;
    var int number_of_killed;
    var int number_of_alive;
    var int number_of_released;
    var int number_of_allowed;
    var int number_to_save;
end

data IGameSession with
    var& _PingusLevel plf;
    var  int          game_time;
    var PingusCounter counter;
end

code/await GameSession (var& _PingusLevel plf_) -> void
do
    var bool is_paused         = false;
    var bool is_fast_forwarded = false;
    var bool do_single_step    = false;

    {
        GLOBAL_ACTIONHOLDER = new ActionHolder(@plf_);
        result.plf = @plf_;
    }

    /// TODO: from "on_startup", called on creation and when popped back
    if {globals::developer_mode} as bool then
        _log_info("Starting Music: %1%", plf_.get_music());
    end
    if plf_.get_music()=="none" or (plf_.get_music().empty() as bool) then
        {Sound::PingusSound::stop_music();};
    else
        call {Sound::PingusSound::play_music}(plf_.get_music());
    end

    var IGameSession game_session =
        val IGameSession(&plf_, 0,
                         PingusCounter(0,0,0,0,
                                       plf_.get_number_of_pingus(),
                                       plf_.get_number_to_save()));

    #include "game_session/world.ceu"

    par/or do
        await World();
    with
        var int world_delay = 0; // the world is initially on time
        loop do
            var int dt = await SDL_DT;
            // how much time we have to account for while doing world updates
            var int time_passed = dt + world_delay;
            // how much time each world update represents
            var int update_time = {globals::game_speed};

            // update the world (and the objects in it) in constant steps 
            // to account for the time the previous frame took

            // invariant: world_updates - the number of times the world
            // has been updated during this frame
            var int world_updates = 0;

            loop do
                if ((world_updates+1)*update_time > time_passed) then
                    break;
                end
                if (not is_paused) or do_single_step then
                    do_single_step = false;
                    if is_fast_forwarded then
                        var int i;
                        loop i in [0 -> {globals::fast_forward_time_scale}[ do
                            await async do
                                emit WORLD_UPDATE;
                            end
                        end
                    else
                        await async do
                            emit WORLD_UPDATE;
                        end
                    end
                end
                world_updates = world_updates + 1;
            end
            // save how far behind is the world compared to the actual time
            // so that we can account for that while updating in the next frame
            world_delay = time_passed - (world_updates*update_time);
        end
    with
        loop do
            var _Input__ButtonEvent&& but = await ON_BUTTON_PRESSED;
            if but:name == {Input::PAUSE_BUTTON} then
                emit outer.main.go_pause_toggle;
            else/if but:name == {Input::SINGLE_STEP_BUTTON} then
                if not is_paused then
                    emit outer.main.go_pause_toggle;
                end
                do_single_step = true;
            else/if but:name == {Input::FAST_FORWARD_BUTTON} then
                emit outer.main.go_forward(true);
            else/if but:name == {Input::ARMAGEDDON_BUTTON} then
                emit outer.main.go_armageddon;
            else/if but:name == {Input::ESCAPE_BUTTON} then
                break;
            end
        end
    with
        var _Input__ButtonEvent&& but;
        every but in ON_BUTTON_RELEASED do
            if but:name == {Input::FAST_FORWARD_BUTTON} then
                emit outer.main.go_forward(false);
            end
        end
    with
        every outer.main.go_pause_toggle do
            is_paused = not is_paused;
            emit outer.main.go_forward(false);
        end
    with
        var bool v;
        every v in outer.main.go_forward do
            is_fast_forwarded = v;
            if v==true and is_paused then
                emit outer.main.go_pause_toggle;
            end
        end
    end

    {
        result.saved     = @game_session.counter.number_of_exited;
        result.killed    = @game_session.counter.number_of_killed;
        result.total     = result.plf.get_number_of_pingus();
        result.needed    = result.plf.get_number_to_save();
        result.max_time  = result.plf.get_time();
        result.used_time = @game_session.game_time;

        // Write the savegame
        {
            Savegame savegame(result.plf.get_resname(),
                            (result.saved >= result.needed) ?  Savegame::FINISHED : 
                            Savegame::ACCESSIBLE,
                            result.used_time,
                            result.saved);
            SavegameManager::instance()->store(savegame);
        }
    };
end

#endif
