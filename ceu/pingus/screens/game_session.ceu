#ifndef _GAME_SESSION
#define _GAME_SESSION

native/pre do
    ##include "pingus/result.hpp"
    ##include "pingus/savegame.hpp"
    ##include "pingus/savegame_manager.hpp"
    ##include "engine/screen/screen_manager.hpp"
    ##include "pingus/screens/result_screen.hpp"
    ##include "pingus/action_holder.hpp"

    static ActionHolder* GLOBAL_ACTIONHOLDER = NULL;
end

#include "../goal_manager.ceu"
#include "../world.ceu"

input (_PingusLevel&&,bool) GAMESESSION_NEW;

class GameSession with
    var _PingusLevel&& plf_;
    var bool show_result_screen;
do
    var bool is_paused         = false;
    var bool is_fast_forwarded = false;
    var bool do_single_step    = false;

    var _PingusLevel&? plf;
    finalize
        this.plf = &_XXX_NOHOLD(this.plf_);
    with
        // TODO
    end

    _GLOBAL_ACTIONHOLDER = _XXX_PURE({new ActionHolder}(this.plf!));

    {
        static Result GAMESESSION_RESULT;
    };
    _GAMESESSION_RESULT.plf = _XXX_PURE(this.plf!);

    /// TODO: from "on_startup", called on creation and when popped back
    if {globals::developer_mode} then
        _log_info("Starting Music: %1%", this.plf!.get_music());
    end
    if this.plf!.get_music()=="none"
    or this.plf!.get_music().empty()
    then
        {Sound::PingusSound::stop_music();};
    else
        call {Sound::PingusSound::play_music}(this.plf!.get_music());
    end

    var PingusCounter counter = PingusCounter(0,0,0,0,
                                    this.plf!.get_number_of_pingus(),
                                    this.plf!.get_number_to_save());

    var World world with
        this.plf = &plf!;
        this.counter = &counter;
    end;

    par/or do
        await world;
    with
        var int world_delay = 0; // the world is initially on time
        every dt in SCREENMANAGER_UPDATE do

            // how much time we have to account for while doing world updates
            var int time_passed = dt*1000 + world_delay;
            // how much time each world update represents
            var int update_time = {globals::game_speed};

            // update the world (and the objects in it) in constant steps 
            // to account for the time the previous frame took

            // invariant: world_updates - the number of times the world
            // has been updated during this frame
            var int world_updates = 0;

            loop do
                if ((world_updates+1)*update_time > time_passed) then
                    break;
                end
                if (not is_paused) or do_single_step then
                    do_single_step = false;
                    if is_fast_forwarded then
                        loop i in {globals::fast_forward_time_scale} do
                            async do
                                emit WORLD_UPDATE;
                            end
                        end
                    else
                        async do
                            emit WORLD_UPDATE;
                        end
                    end
                end
                world_updates = world_updates + 1;
            end
            // save how far behind is the world compared to the actual time
            // so that we can account for that while updating in the next frame
            world_delay = time_passed - (world_updates*update_time);
        end
    with
        every e in ON_INPUT_EVENT do
            if e:type != {Input::BUTTON_EVENT_TYPE} then
                continue;
            end

            var _Input__ButtonEvent&& but = &&e:button;
            if but:state == {Input::BUTTON_PRESSED} then
                if but:name == {Input::PAUSE_BUTTON} then
                    emit global:go_pause_toggle;
                else/if but:name == {Input::SINGLE_STEP_BUTTON} then
                    if not is_paused then
                        emit global:go_pause_toggle;
                    end
                    do_single_step = true;
                else/if but:name == {Input::FAST_FORWARD_BUTTON} then
                    emit global:go_forward => true;
                else/if but:name == {Input::ARMAGEDDON_BUTTON} then
                    emit global:go_armageddon;
                else/if but:name == {Input::ESCAPE_BUTTON} then
                    kill world;  // aborts everything
                end
            else
                _assert(but:state == {Input::BUTTON_RELEASED});
                if but:name == {Input::FAST_FORWARD_BUTTON} then
                    emit global:go_forward => false;
                end
            end
        end
    with
        every global:go_pause_toggle do
            is_paused = not is_paused;
            emit global:go_forward => false;
        end
    with
        every v in global:go_forward do
            is_fast_forwarded = v;
            if v==true and is_paused then
                emit global:go_pause_toggle;
            end
        end
    end

    _GAMESESSION_RESULT.saved     = counter.number_of_exited;
    _GAMESESSION_RESULT.killed    = counter.number_of_killed;
    _GAMESESSION_RESULT.total     = (int)_GAMESESSION_RESULT.plf.get_number_of_pingus();
    _GAMESESSION_RESULT.needed    = (int)_GAMESESSION_RESULT.plf.get_number_to_save();
    _GAMESESSION_RESULT.max_time  = (int)_GAMESESSION_RESULT.plf.get_time();
    _GAMESESSION_RESULT.used_time = world.game_time;

    { // Write the savegame
        Savegame savegame(GAMESESSION_RESULT.plf.get_resname(),
                        (GAMESESSION_RESULT.saved >= GAMESESSION_RESULT.needed) ? Savegame::FINISHED : 
                        Savegame::ACCESSIBLE,
                        GAMESESSION_RESULT.used_time,
                        GAMESESSION_RESULT.saved);
        SavegameManager::instance()->store(savegame);
    };

    if this.show_result_screen then
        {ScreenManager::instance()->replace_screen(std::make_shared<ResultScreen>(GAMESESSION_RESULT));};
    else
        {ScreenManager::instance()->pop_screen();};
    end
end

spawn do
    every (plf_,show_) in GAMESESSION_NEW do
        spawn GameSession with
            this.plf_ = plf_;
            this.show_result_screen = show_;
        end;
    end
end

#endif
