#ifndef _GAME_SESSION
#define _GAME_SESSION

native/pre do
    ##include "pingus/result.hpp"
    ##include "pingus/savegame.hpp"
    ##include "pingus/savegame_manager.hpp"
    ##include "engine/screen/screen_manager.hpp"
    ##include "pingus/action_holder.hpp"

    static ActionHolder* GLOBAL_ACTIONHOLDER = NULL;
end

#include "../goal_manager.ceu"
#include "../world.ceu"

class GameSession with
    var _PingusLevel& plf;
do
    var bool is_paused         = false;
    var bool is_fast_forwarded = false;
    var bool do_single_step    = false;

    _GLOBAL_ACTIONHOLDER = _XXX_PURE({new ActionHolder}(this.plf));

    _result.plf = _XXX_PURE(this.plf);

    /// TODO: from "on_startup", called on creation and when popped back
    if {globals::developer_mode} then
        _log_info("Starting Music: %1%", this.plf.get_music());
    end
    if this.plf.get_music()=="none"
    or this.plf.get_music().empty()
    then
        {Sound::PingusSound::stop_music();};
    else
        call {Sound::PingusSound::play_music}(this.plf.get_music());
    end

    var PingusCounter counter = PingusCounter(0,0,0,0,
                                    this.plf.get_number_of_pingus(),
                                    this.plf.get_number_to_save());

    var World world with
        this.plf = &plf;
        this.counter = &counter;
    end;

    par/or do
        await world;
    with
        var int world_delay = 0; // the world is initially on time
        every v in DELTA do
            var float dt = ((float)v)/1000;

            // how much time we have to account for while doing world updates
            var int time_passed = dt*1000 + world_delay;
            // how much time each world update represents
            var int update_time = {globals::game_speed};

            // update the world (and the objects in it) in constant steps 
            // to account for the time the previous frame took

            // invariant: world_updates - the number of times the world
            // has been updated during this frame
            var int world_updates = 0;

            loop do
                if ((world_updates+1)*update_time > time_passed) then
                    break;
                end
                if (not is_paused) or do_single_step then
                    do_single_step = false;
                    if is_fast_forwarded then
                        loop i in {globals::fast_forward_time_scale} do
                            async do
                                emit WORLD_UPDATE;
                            end
                        end
                    else
                        async do
                            emit WORLD_UPDATE;
                        end
                    end
                end
                world_updates = world_updates + 1;
            end
            // save how far behind is the world compared to the actual time
            // so that we can account for that while updating in the next frame
            world_delay = time_passed - (world_updates*update_time);
        end
    with
        every but in ON_BUTTON_PRESSED do
            if but:name == {Input::PAUSE_BUTTON} then
                emit global:go_pause_toggle;
            else/if but:name == {Input::SINGLE_STEP_BUTTON} then
                if not is_paused then
                    emit global:go_pause_toggle;
                end
                do_single_step = true;
            else/if but:name == {Input::FAST_FORWARD_BUTTON} then
                emit global:go_forward => true;
            else/if but:name == {Input::ARMAGEDDON_BUTTON} then
                emit global:go_armageddon;
            else/if but:name == {Input::ESCAPE_BUTTON} then
                kill world;  // aborts everything
            end
        end
    with
        every but in ON_BUTTON_RELEASED do
            if but:name == {Input::FAST_FORWARD_BUTTON} then
                emit global:go_forward => false;
            end
        end
    with
        every global:go_pause_toggle do
            is_paused = not is_paused;
            emit global:go_forward => false;
        end
    with
        every v in global:go_forward do
            is_fast_forwarded = v;
            if v==true and is_paused then
                emit global:go_pause_toggle;
            end
        end
    end

    _result.saved     = counter.number_of_exited;
    _result.killed    = counter.number_of_killed;
    _result.total     = (int)_result.plf.get_number_of_pingus();
    _result.needed    = (int)_result.plf.get_number_to_save();
    _result.max_time  = (int)_result.plf.get_time();
    _result.used_time = world.game_time;

    { // Write the savegame
        Savegame savegame(result.plf.get_resname(),
                        (result.saved >= result.needed) ?  Savegame::FINISHED : 
                        Savegame::ACCESSIBLE,
                        result.used_time,
                        result.saved);
        SavegameManager::instance()->store(savegame);
    };
end

#endif
