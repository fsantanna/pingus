#ifndef _WORLDOBJ_FACTORY_CEU
#define _WORLDOBJ_FACTORY_CEU

// TODO: use spawn directly instead of ceu_sys_go
//          - requires flatmap or traverse

native/pre do
    static std::vector<std::pair<FileReader,Vector3f>> WORLDOBJ_FACTORY_VECTOR;
    static FileReader                                  WORLDOBJ_FACTORY_READER;
end

native do
    ##include "src/pingus/prefab_file.hpp"
    ##include "src/util/overrride_file_reader.hpp"
    Vector3f WORLDOBJ_FACTORY_pos = Vector3f(0,0,0);

    void WORLDOBJ_FACTORY_create (const FileReader& reader) {
        if (reader.get_name()=="prefab")
        {
            std::string name;
            reader.read_string("name", name);

            Vector3f pos;
            reader.read_vector("position", pos);
            WORLDOBJ_FACTORY_pos += pos;

            PrefabFile prefab = PrefabFile::from_resource(name);
            FileReader overrides;
            reader.read_section("overrides", overrides);

            const std::vector<FileReader>& objects = prefab.get_objects();
            for(auto it = objects.begin(); it != objects.end(); ++it) {
                OverrideFileReader override_reader(*it, overrides);
                WORLDOBJ_FACTORY_create(override_reader);
            }
            WORLDOBJ_FACTORY_pos -= pos;
        }
        else if (reader.get_name()=="group")
        {
            FileReader objects = reader.read_section("objects");
            std::vector<FileReader> sections = objects.get_sections();
            for(auto it = sections.begin(); it != sections.end(); ++it) {
                WORLDOBJ_FACTORY_create(*it);
            }
        } else {
            WORLDOBJ_FACTORY_VECTOR.push_back(std::make_pair(reader,WORLDOBJ_FACTORY_pos));
        }
    }
end

class WorldObjFactory with
    var _PingusLevel& plf;  // TODO: private
    var Vector2i pos_start = Vector2i(0,0);
    function (_PingusLevel& plf)=>WorldObjFactory build;
do
    function (_PingusLevel& plf)=>WorldObjFactory build do
        this.plf = &plf;
    end

    loop i in this.plf.get_objects().size() do
        _WORLDOBJ_FACTORY_create(this.plf.get_objects().at(i));
    end

    #define id_     _WORLDOBJ_FACTORY_VECTOR.at(i).first.get_name()
    #define reader_ &&_WORLDOBJ_FACTORY_READER

    pool Entrance[] entrances;

    loop i in _WORLDOBJ_FACTORY_VECTOR.size() do
        _WORLDOBJ_FACTORY_READER = _XXX_PURE(_WORLDOBJ_FACTORY_VECTOR.at(i).first);
        var Vector3f pos_offset = Vector3f(_WORLDOBJ_FACTORY_VECTOR.at(i).second.x,
                                           _WORLDOBJ_FACTORY_VECTOR.at(i).second.y,
                                           _WORLDOBJ_FACTORY_VECTOR.at(i).second.z);
        if id_ == "entrance" then
            spawn Entrance in entrances with
                this.reader     = reader_;
                this.pos_offset = pos_offset;
            end;
        else/if id_ == "exit" then
            spawn Exit with
                this.reader = reader_;
            end;
        else/if id_ == "groundpiece" then
            spawn Groundpiece with
                this.reader = reader_;
            end;
        else/if id_ == "guillotine" then
            spawn Guillotine with
                this.reader = reader_;
            end;
        else/if id_ == "hotspot" then
            spawn Hotspot with
                this.reader     = reader_;
                this.pos_offset = pos_offset;
            end;
        else/if id_ == "laser_exit" then
            spawn LaserExit with
                this.reader = reader_;
            end;
        else/if id_ == "liquid" then
            spawn Liquid with
                this.reader = reader_;
            end;
        else/if id_ == "smasher" then
            spawn Smasher with
                this.reader = reader_;
            end;
        else/if id_ == "spike" then
            spawn Spike with
                this.reader = reader_;
            end;
        else/if id_ == "surface-background" then
            spawn SurfaceBackground with
                this.reader = reader_;
            end;
        end
    end

    // FIXME: Workaround for lack of start-pos
    var int num_entrances = 0;
    loop e in entrances do
        num_entrances = num_entrances + 1;
        var _Vector3f pos_ = e:get_pos();
        pos_start.x = pos_start.x + (int)pos_.x;
        pos_start.y = pos_start.y + (int)pos_.y;
    end

    if (num_entrances > 0) then
        pos_start.x = pos_start.x / num_entrances;
        pos_start.y = pos_start.y / num_entrances;
        pos_start.y = pos_start.y + 100;
    end

    await FOREVER;

#if 0
    {
        static const std::vector<FileReader>& objects =
            THIS(CEU_World)->plf->get_objects();
        for (std::vector<FileReader>::const_iterator i = objects.begin();
             i != objects.end ();
             ++i)
            WorldObjFactory::instance()->create(*i);
    };
#endif

end

#endif
