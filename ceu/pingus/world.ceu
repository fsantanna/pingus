#ifndef _WORLD_CEU
#define _WORLD_CEU

native/pre do
    struct CEU_World;
    ##include "engine/display/graphic_context_state.hpp"
end

native do
    ##include "pingus/ground_map.hpp"
end
native @plain _SmallMap, _SceneContext, _GroundMap;

#include "particles/pingu_particle_holder.ceu"
#include "particles/smoke_particle_holder.ceu"

#include "pingu_holder.ceu"
#include "components/playfield.ceu"
#include "components/smallmap.ceu"
#include "components/button_panel.ceu"
#include "components/time_display.ceu"
#include "components/pingus_counter.ceu"
#include "components/action_button.ceu"
#include "capture_rectangle.ceu"
#include "smallmap_image.ceu"

#include "worldobjs/entrance.ceu"
#include "worldobjs/exit.ceu"
#include "worldobjs/groundpiece.ceu"
#include "worldobjs/guillotine.ceu"
#include "worldobjs/hotspot.ceu"
#include "worldobjs/laser_exit.ceu"
#include "worldobjs/liquid.ceu"
#include "worldobjs/smasher.ceu"
#include "worldobjs/spike.ceu"
#include "worldobjs/surface_background.ceu"

#include "worldobj_factory.ceu"

class World with
    interface IWorld;
    var _PingusLevel& plf;
    var PingusCounter& counter;
    var int game_time = 0;
    var Rect state = Rect(0,0,0,0);
do
    global:world = &&this;

    var int width  = this.plf.get_size().width;
    var int height = this.plf.get_size().height;

    var Rect rect = Rect(
        {Math::max}(({Display::get_width()}-width)/2, 0),
        {Math::max}(({Display::get_height()}-height)/2, 0),
        {Math::min}({Display::get_width()},  width),
        {Math::min}({Display::get_height()}, height)
    );

    var _GroundMap&? gfx_map;
    finalize
        gfx_map = &{new GroundMap}(width, height);
    with
        _delete(&&gfx_map!);
    end

    var _GraphicContextState&? state_;
    finalize
        state_ = &{new GraphicContextState}(
                    {Math::min}({Display::get_width()},  width),
                    {Math::min}({Display::get_height()}, height));
    with
        _delete(&&state_!);
    end
    this.state_!.set_limit(_Rect(_Vector2i(0,0), _Size(width, height)));
    state = Rect(0,0, width,height);

    var Color ambient_light = Color(this.plf.get_ambient_light().r,
                                    this.plf.get_ambient_light().g,
                                    this.plf.get_ambient_light().b,
                                    this.plf.get_ambient_light().a);

    spawn do
        par do
            every REDRAW do
                global:offset = this.get_offset();
            end
        with
            every WORLD_UPDATE do
                this.game_time = this.game_time + 1;
            end
        with
            // Playfield
            every REDRAW do
#if 0
                call {Display::s_framebuffer}:fill_rect(
                    _Rect(0,0, {Display::get_width()},{Display::get_height()}),
                    _Color(ambient_light.r,
                           ambient_light.g,
                           ambient_light.b,
                           ambient_light.a)
                );
#endif
                var Vector2i off = global:world!:get_offset();
                this.gfx_map!.draw(_Vector2i(off.x,off.y));
            end
        end
    end

    pool IPingu[] pingus;

    var GoalManager goal_manager with
        this.plf = &plf;
        this.counter = &outer.counter;
        this.game_time = &game_time;
    end;

    var PinguHolder pingu_holder with
        this.pingus  = &pingus;
        this.counter = &outer.counter;
    end;
    pool PinguParticle[] pingu_particles;
    pool SmokeParticle[] smoke_particles;

    var TimeDisplay      _ = TimeDisplay.build(plf.get_time(), &game_time);
    var CPingusCounter   _ = CPingusCounter.build(&counter);


    var int dwidth  = {Display::get_width()};
    var int dheight = {Display::get_height()};
    var Rect r = Rect(dwidth-40*1, dheight-62, 0,0);
    var ArmageddonButton _ = ArmageddonButton.build(&r);
    var ForwardButton    _ = ForwardButton.build   (dwidth-40*2, dheight-62);
    var PauseButton      _ = PauseButton.build     (dwidth-40*3, dheight-62);
    var ButtonPanel button_panel;

    var Playfield playfield with
        this.action_next = &button_panel.action;
        this.pingus      = &pingus;
        this.rect        = &rect;
    end;

    var Rect rect_small = Rect(6,{Display::get_size}().height-105, 175,100);
    var SmallMapImage _ = SmallMapImage.build(&rect_small);
    var SmallMap smallmap with
        this.rect      = &rect_small;
        this.pingus    = &pingus;
        this.playfield = &playfield;
    end;

    var CaptureRectangle _ = CaptureRectangle.build(&playfield);

    var WorldObjFactory objs with
        this.plf = &plf;
        this.pingus = &pingus;
        this.game_time = &game_time;
        this.smallmap = &smallmap;
    end;

    this.state_!.set_pos(_Vector2i(objs.pos_start.x,objs.pos_start.y));
    state.left = objs.pos_start.x;
    state.top  = objs.pos_start.y;

    par/or do
        await goal_manager;
    with
        every (x_,y_) in global:go_create_pingu_particles do
            loop i in 50 do
                spawn PinguParticle in pingu_particles with
                    this.x = x_;
                    this.y = y_;
                end;
            end
        end
    with
        every (x_,y_,vel_x_,vel_y_) in global:go_create_smoke_particles do
            spawn SmokeParticle in smoke_particles with
                this.x     = x_;
                this.y     = y_;
                this.vel_x = vel_x_;
                this.vel_y = vel_y_;
            end;
        end
    with
        await global:go_armageddon;
        ///_GLOBAL_SERVER:send_armageddon_event();

        {Sound::PingusSound::play_sound("goodidea");};

        loop do
            loop i in 4 do
                await WORLD_UPDATE;
            end

            var IPingu&&? pingu;
            loop p in pingus do
                if p:current_action != {ActionName::BOMBER} then
                    pingu = p;
                    break;
                end
            end
            if pingu? then
                emit pingu!:go_action => {ActionName::BOMBER};
            end
        end
    with
        every REDRAW do
            global:offset = Vector2i(0,0);
        end
    end

    /* PUBLIC */

    function (void)=>int get_width do
        return this.width;
    end
    function (void)=>int get_height do
        return this.height;
    end

    function (void)=>_CollisionMap&& get_colmap do
        return _XXX_PURE(this.gfx_map!.get_colmap());
    end
    function (void)=>_GraphicContextState& get_state do
        return &this.state_!;
    end

    function (_CollisionMask&& mask,int x,int y,_Groundtype__GPType type)=>void put do
        this.gfx_map!.put(mask:get_surface(), x, y);
        this.gfx_map!.get_colmap():put(*mask, x, y, type);
    end
    function (_CollisionMask&& mask,int x,int y)=>void remove do
        this.gfx_map!.remove(mask:get_surface(), x, y);
        this.gfx_map!.get_colmap():remove(*mask, x, y);
    end

#if 0
    function (void)=>Vector2i get_offset do
        var Vector2i ret =
            Vector2i(
                -(state.left - state.width/2),
                -(state.top  - state.height/2)
            );
        return ret;
    end
#endif
    function (void)=>Vector2i get_offset do
        var Vector2i ret =
            Vector2i(
                -(state_!.get_pos().x - state_!.get_width()/2),
                -(state_!.get_pos().y - state_!.get_height()/2)
            );
        return ret;
    end
end

#endif
