#ifndef _WORLD_CEU
#define _WORLD_CEU

native/pre do
    struct CEU_World;
    extern CEU_World* GLOBAL_CEU_WORLD;
    ##include "engine/display/graphic_context_state.hpp"
end

native do
    ##include "src/pingus/screens/game_session.hpp"
    ##include "pingus/ground_map.hpp"
    extern GameSession* GLOBAL_SESSION;
    extern Server* GLOBAL_SERVER;
end
native @plain _SmallMap, _SceneContext, _GroundMap;

input _PingusLevel&& WORLD_NEW;
input void WORLD_UPDATE;
input void WORLD_ARMAGEDDON;

#include "particles/pingu_particle_holder.ceu"
#include "particles/smoke_particle_holder.ceu"

#define WORLD_gravitational_acceleration 0.2

interface IWorldObj with
end

#include "pingu_holder.ceu"
#include "components/playfield.ceu"
#include "components/smallmap.ceu"
#include "components/action_button.ceu"
#include "components/pingus_counter.ceu"
#include "smallmap_image.ceu"

#include "worldobjs/entrance.ceu"
#include "worldobjs/exit.ceu"
#include "worldobjs/groundpiece.ceu"
#include "worldobjs/guillotine.ceu"
#include "worldobjs/hotspot.ceu"
#include "worldobjs/laser_exit.ceu"
#include "worldobjs/liquid.ceu"
#include "worldobjs/smasher.ceu"
#include "worldobjs/spike.ceu"
#include "worldobjs/surface_background.ceu"

#include "worldobj_factory.ceu"

class World with
    interface IWorld;
    var _PingusLevel&& plf;
    function (void)=>PinguHolder&  get_pingus;
do
    _GLOBAL_CEU_WORLD := &&this;
    global:world = &&this;

    var int width  = this.plf:get_size().width;
    var int height = this.plf:get_size().height;

    var Rect rect = Rect(
        {Math::max}(({Display::get_width()}-width)/2, 0),
        {Math::max}(({Display::get_height()}-height)/2, 0),
        {Math::min}({Display::get_width()},  width),
        {Math::min}({Display::get_height()}, height)
    );

    var _GroundMap&? gfx_map;
    finalize
        gfx_map = &{new GroundMap}(width, height);
    with
        _delete(&&gfx_map!);
    end

    var _GraphicContextState&? state;
    finalize
        state = &{new GraphicContextState}(
                    {Math::min}({Display::get_width()},  width),
                    {Math::min}({Display::get_height()}, height));
    with
        _delete(&&state!);
    end
    this.state!.set_limit(_Rect(_Vector2i(0,0), _Size(width, height)));

    var _SceneContext&? scene_context;
    finalize
        scene_context = &{new SceneContext}(
            _Rect(_Vector2i(rect.left,rect.top), _Size(rect.width,rect.height))
        );
    with
        _delete(&&scene_context!);
    end

    var int game_time = 0;
    var Color ambient_light = Color(this.plf:get_ambient_light().r,
                                    this.plf:get_ambient_light().g,
                                    this.plf:get_ambient_light().b,
                                    this.plf:get_ambient_light().a);

    spawn do
        par do
            // Playfield
            every gc in SCREENMANAGER_DRAW do
                this.scene_context!.clear();
                this.state!.push(this.scene_context!);
            end
        with
            every WORLD_UPDATE do
                this.game_time = this.game_time + 1;
            end
        with
            // Playfield
            every gc in SCREENMANAGER_DRAW do
                this.get_scene_context().light().fill_screen(
                    _Color(ambient_light.r,
                           ambient_light.g,
                           ambient_light.b,
                           ambient_light.a));
                this.gfx_map!.draw(this.get_scene_context());
                this.get_scene_context().color().draw(*_GLOBAL_SESSION, _Vector2i(0,0));
            end
        end
    end

    var SmallMapImage _ with
        this.width  = 175;      /// TODO: take from SmallMap
        this.height = 100;      /// TODO: take from SmallMap
    end;

    var WorldObjFactory objs with
        this.plf = outer.plf;
    end;

    var PinguHolder pingu_holder with
        this.number_of_allowed = plf:get_number_of_pingus();
    end;

    var Playfield playfield with
        this.pingu_holder = &pingu_holder;
        this.rect         = &rect;
    end;
    this.state!.set_pos(this.get_start_pos(0));

    var Rect rect_small = Rect(6,{Display::get_size}().height-105, 175,100);
        // TODO: height originally comes from Screen/GUIScreen/SmallMap

    var SmallMap smallmap with
        this.rect         = rect_small;
        this.pingu_holder = &pingu_holder;
        this.playfield    = &playfield;
    end;

    var bool in_armageddon = false;
    var ArmageddonButton armageddon with
        this.x = {Display::get_width()}  - 40*1;
        this.y = {Display::get_height()} - 62;
    end;
    var ForwardButton _ with
        this.x = {Display::get_width()}  - 40*2;
        this.y = {Display::get_height()} - 62;
    end;
    var PauseButton _ with
        this.x = {Display::get_width()}  - 40*3;
        this.y = {Display::get_height()} - 62;
    end;

    var PingusCounter _ with
        this.pingu_holder = &pingu_holder;
    end;

    par/or do
        every (x_,y_) in this.create_pingu_particles do
            loop i in 50 do
                spawn PinguParticle with
                    this.x = x_;
                    this.y = y_;
                end;
            end
        end
    with
        every (x_,y_,vel_x_,vel_y_) in this.create_smoke_particles do
            spawn SmokeParticle with
                this.x     = x_;
                this.y     = y_;
                this.vel_x = vel_x_;
                this.vel_y = vel_y_;
            end;
        end
    with
        await armageddon.ok;
        this.in_armageddon = true;
        _GLOBAL_SERVER:send_armageddon_event();

        {Sound::PingusSound::play_sound("goodidea");};

        loop do
            loop i in 4 do
                await WORLD_UPDATE;
            end

            var IPingu&&? pingu;
            loop p in pingu_holder.pingus do
                if p:current_action != {ActionName::BOMBER} then
                    pingu = p;
                    break;
                end
            end
            if pingu? then
                emit pingu!:go_action => {ActionName::BOMBER};
            end
        end
    with
        // Playfield
        every gc in SCREENMANAGER_DRAW do
            this.state!.pop(this.scene_context!);
            gc:draw(
                {new SceneContextDrawingRequest}(
                    &&this.scene_context!,
                    _Vector2i(0,0),
                    -10000)
                finalize with nothing; end
            );
        end
    end

    /* PUBLIC */

    function (void)=>IPinguHolderPool& get_pingu_holder do
        return &this.pingu_holder;
    end

    function (int player_id)=>_Vector2i get_start_pos do
        // FIXME: Workaround for lack of start-pos
        var int num_entrances = 0;
        var Vector2i pos = Vector2i(0,0);
        loop entrance in this.objs.entrances do
            num_entrances = num_entrances + 1;
            var _Vector3f pos_ = entrance:get_pos();
            pos.x = pos.x + (int)pos_.x;
            pos.y = pos.y + (int)pos_.y;
        end

        if (num_entrances > 0) then
            pos.x = pos.x / num_entrances;
            pos.y = pos.y / num_entrances;
            pos.y = pos.y + 100;
        end

        return _Vector2i(pos.x, pos.y);
    end

    function (void)=>int get_time do
        return this.game_time;
    end

    function (void)=>PinguHolder& get_pingus do
        return &this.pingu_holder;
    end
    function (void)=>IComponent& get_smallmap do
        return &this.smallmap;
    end

    function (void)=>int get_width do
        return this.width;
    end
    function (void)=>int get_height do
        return this.height;
    end

    function (void)=>bool check_armageddon do
        return this.in_armageddon;
    end

    function (_std__string name, _Vector3f pos, float volume)=>void play_sound do
        var float panning = 0.0;
        return {Sound::PingusSound::play_sound}(name, volume, panning);
    end

    function (void)=>float get_gravity do
        return WORLD_gravitational_acceleration;
    end

    function (void)=>_GroundMap&& get_gfx_map do
        return _XXX_PURE(&&this.gfx_map!);
    end
    function (void)=>_CollisionMap&& get_colmap do
        return _XXX_PURE(this.gfx_map!.get_colmap());
    end
    function (void)=>_GraphicContextState& get_state do
        return &this.state!;
    end
    function (void)=>_SceneContext& get_scene_context do
        return &this.scene_context!;
    end

    function (_CollisionMask&& mask,int x,int y,_Groundtype__GPType type)=>void put do
        this.gfx_map!.put(mask:get_surface(), x, y);
        this.gfx_map!.get_colmap():put(*mask, x, y, type);
    end
    function (_CollisionMask&& mask,int x,int y)=>void remove do
        this.gfx_map!.remove(mask:get_surface(), x, y);
        this.gfx_map!.get_colmap():remove(*mask, x, y);
    end
end

spawn do
    every plf_ in WORLD_NEW do
        spawn World with
            this.plf = plf_;
        end;
    end
end

#endif
