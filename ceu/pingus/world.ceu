#ifndef _WORLD_CEU
#define _WORLD_CEU

native/pre do
    class Playfield;
end

native do
    ##include "src/pingus/world.hpp"
    ##include "src/pingus/components/playfield.hpp"
    ##include "src/pingus/components/smallmap.hpp"
    extern Playfield* GLOBAL_PLAYFIELD;
    extern SmallMap*  GLOBAL_SMALLMAP;
end
native @plain _World;
native @plain _Playfield, _SmallMap;

input (_World&&, _PingusLevel&&) WORLD_NEW;
input (_World&&) WORLD_DELETE;
input (_SceneContext&&) WORLD_DRAW;
input (_SmallMap&&) WORLD_DRAW_SMALLMAP;

input (_char&&, _FileReader&&) WORLD_NEWOBJ;

input void WORLD_ARMAGEDDON;

#include "particles/pingu_particle_holder.ceu"
#include "particles/smoke_particle_holder.ceu"

interface IWorldObj with
end

#include "worldobjs/entrance.ceu"
#include "worldobjs/exit.ceu"
#include "worldobjs/groundpiece.ceu"
#include "worldobjs/guillotine.ceu"
#include "worldobjs/hotspot.ceu"
#include "worldobjs/laser_exit.ceu"
#include "worldobjs/liquid.ceu"
#include "worldobjs/smasher.ceu"
#include "worldobjs/spike.ceu"
#include "worldobjs/surface_background.ceu"

#include "pingu_holder.ceu"
#include "components/playfield.ceu"
#include "components/smallmap.ceu"

class WorldObjFactory with
    pool Entrance[] entrances;
do
    every (id_,reader_) in WORLD_NEWOBJ do
        if _strcmp(id_,"entrance")==0 then
            spawn Entrance in this.entrances with
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"exit")==0 then
            spawn Exit with
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"groundpiece")==0 then
            spawn Groundpiece with
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"guillotine")==0 then
            spawn Guillotine with
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"hotspot")==0 then
            spawn Hotspot with
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"laser_exit")==0 then
            spawn LaserExit with
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"liquid")==0 then
            spawn Liquid with
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"smasher")==0 then
            spawn Smasher with
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"spike")==0 then
            spawn Spike with
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"surface-background")==0 then
            spawn SurfaceBackground with
                this.reader = reader_;
            end;
        end
    end
end

class World with
    interface IWorld;

    var _PingusLevel&& plf;
    function (void)=>_Vector2i get_start_pos;
do
    this.me.ceu = &&this;
    global:world = &&this;

    var WorldObjFactory objs;
    loop i in this.plf:get_objects().size() do
        call {WorldObjFactory::instance()}:create(
            this.plf:get_objects().at(i)
        );
    end

#if 0
    {
        static const std::vector<FileReader>& objects =
            THIS(CEU_World)->plf->get_objects();
        for (std::vector<FileReader>::const_iterator i = objects.begin();
             i != objects.end ();
             ++i)
            WorldObjFactory::instance()->create(*i);
    };
#endif

    var PinguHolder pingu_holder with
        this.number_of_allowed = plf:get_number_of_pingus();
    end;
    this.me.pingus = &&pingu_holder;

    await SDL_DT;   // TODO: World is created before Playfield in C++

    var _Playfield&? playfield_ := &_XXX_PURE(_GLOBAL_PLAYFIELD);
    var Playfield playfield with
        this.pingu_holder = &pingu_holder;
        this.me           = &playfield_!;
    end;

    var _SmallMap&? smallmap_ := &_XXX_PURE(_GLOBAL_SMALLMAP);
    var SmallMap smallmap with
        this.pingu_holder = &pingu_holder;
        this.me           = &smallmap_!;
    end;

    par/or do
        AWAIT_UNTIL_MYSELF(_World, WORLD_DELETE);
    with
        every (x_,y_) in this.create_pingu_particles do
            loop i in 50 do
                spawn PinguParticle with
                    this.x = x_;
                    this.y = y_;
                end;
            end
        end
    with
        every (x_,y_,vel_x_,vel_y_) in this.create_smoke_particles do
            spawn SmokeParticle with
                this.x     = x_;
                this.y     = y_;
                this.vel_x = vel_x_;
                this.vel_y = vel_y_;
            end;
        end
    with
        me.do_armageddon = false;
        await WORLD_ARMAGEDDON;
        me.do_armageddon = true;

        {Sound::PingusSound::play_sound("goodidea");};

        loop do
            loop i in 4 do
                await WORLD_UPDATE;
            end

            var IPingu&&? pingu;
            loop p in pingu_holder.pingus do
                if p:current_action != {ActionName::BOMBER} then
                    pingu = p;
                    break;
                end
            end
            if pingu? then
                emit pingu!:go_action => {ActionName::BOMBER};
            end
        end
    end

    /* PUBLIC */

    function (void)=>IPinguHolderPool& get_pingu_holder do
        return &this.pingu_holder;
    end

    function (void)=>_Vector2i get_start_pos do
        // FIXME: Workaround for lack of start-pos
        var int num_entrances = 0;
        var Vector2i pos = Vector2i(0,0);
        loop entrance in this.objs.entrances do
            num_entrances = num_entrances + 1;
            var _Vector3f pos_ = entrance:get_pos();
            pos.x = pos.x + (int)pos_.x;
            pos.y = pos.y + (int)pos_.y;
        end

        if (num_entrances > 0) then
            pos.x = pos.x / num_entrances;
            pos.y = pos.y / num_entrances;
            pos.y = pos.y + 100;
        end

        return _Vector2i(pos.x, pos.y);
    end
end

class WorldFactory with
do
    every (me_,plf_) in WORLD_NEW do
        spawn World with
            this.me  = &_XXX_PTR2REF(me_);
            this.plf = plf_;
        end;
    end
end
var WorldFactory _;

#endif
