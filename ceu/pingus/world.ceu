#ifndef _WORLD_CEU
#define _WORLD_CEU

native/pre do
    class Playfield;
end

native do
    ##include "src/pingus/world.hpp"
    ##include "src/pingus/components/playfield.hpp"
    ##include "src/pingus/components/smallmap.hpp"
    extern Playfield* GLOBAL_PLAYFIELD;
    extern SmallMap*  GLOBAL_SMALLMAP;
end
native @plain _World;
native @plain _Playfield, _SmallMap;

input (_World&&) WORLD_NEW;
input (_World&&) WORLD_DELETE;
input (_SceneContext&&) WORLD_DRAW;

input void WORLD_ARMAGEDDON;

#include "worldobjs/entrance.ceu"
#include "worldobjs/exit.ceu"
#include "worldobjs/groundpiece.ceu"
#include "worldobjs/guillotine.ceu"
#include "worldobjs/laser_exit.ceu"
#include "worldobjs/smasher.ceu"
#include "worldobjs/spike.ceu"
#include "worldobjs/surface_background.ceu"

#include "pingu_holder.ceu"
#include "components/playfield.ceu"
#include "components/smallmap.ceu"

class World with
    interface IWorld;
do
    this.me.ceu = &&this;

    var PinguHolder pingu_holder with
        this.me = &_XXX_PTR2REF(outer.me.pingus);
        this.number_of_allowed = this.me.number_of_allowed;
    end;

    await SDL_DT;   // TODO: World is created before Playfield in C++

    var _Playfield&? playfield_ := &_XXX_PURE(_GLOBAL_PLAYFIELD);
    var Playfield playfield with
        this.pingu_holder = &pingu_holder;
        this.me           = &playfield_!;
    end;

    var _SmallMap&? smallmap_ := &_XXX_PURE(_GLOBAL_SMALLMAP);
    var SmallMap smallmap with
        this.pingu_holder = &pingu_holder;
        this.me           = &smallmap_!;
    end;

    par/or do
        AWAIT_UNTIL_MYSELF(_World, WORLD_DELETE);
    with
        me.do_armageddon = false;
        await WORLD_ARMAGEDDON;
        me.do_armageddon = true;

        {Sound::PingusSound::play_sound("goodidea");};

        loop do
            loop i in 4 do
                await WORLD_UPDATE;
            end

            var IPingu&&? pingu;
            loop p in pingu_holder.pingus do
                if p:current_action != {ActionName::BOMBER} then
                    pingu = p;
                    break;
                end
            end
            if pingu? then
                emit pingu!:go_action => {ActionName::BOMBER};
            end
        end
    end

    /* PUBLIC */

    function (void)=>IPinguHolderPool& get_pingu_holder do
        return &this.pingu_holder;
    end
end

class WorldFactory with
do
    every me_ in WORLD_NEW do
        spawn World with
            this.me = &_XXX_PTR2REF(me_);
        end;
    end
end
var WorldFactory _;

#endif
