#ifndef _WORLD_CEU
#define _WORLD_CEU

native/pre do
    struct CEU_World;
    ##include "engine/display/graphic_context_state.hpp"
end

native do
    ##include "pingus/ground_map.hpp"
end
native @plain _SmallMap, _SceneContext, _GroundMap;

#include "particles/pingu_particle_holder.ceu"
#include "particles/smoke_particle_holder.ceu"

#include "pingu_holder.ceu"
#include "components/playfield.ceu"
#include "components/smallmap.ceu"
#include "components/button_panel.ceu"
#include "components/time_display.ceu"
#include "components/pingus_counter.ceu"
#include "components/action_button.ceu"
#include "capture_rectangle.ceu"
#include "smallmap_image.ceu"

#include "worldobjs/entrance.ceu"
#include "worldobjs/exit.ceu"
#include "worldobjs/groundpiece.ceu"
#include "worldobjs/guillotine.ceu"
#include "worldobjs/hotspot.ceu"
#include "worldobjs/laser_exit.ceu"
#include "worldobjs/liquid.ceu"
#include "worldobjs/smasher.ceu"
#include "worldobjs/spike.ceu"
#include "worldobjs/surface_background.ceu"

#include "worldobj_factory.ceu"

class World with
    interface IWorld;
    var _PingusLevel& plf;
    var PingusCounter& counter;
    var int game_time = 0;
do
    global:world = &&this;

    var int width  = this.plf.get_size().width;
    var int height = this.plf.get_size().height;

    var Rect rect = Rect(
        {Math::max}(({Display::get_width()}-width)/2, 0),
        {Math::max}(({Display::get_height()}-height)/2, 0),
        {Math::min}({Display::get_width()},  width),
        {Math::min}({Display::get_height()}, height)
    );

    var _GroundMap&? gfx_map;
    finalize
        gfx_map = &{new GroundMap}(width, height);
    with
        _delete(&&gfx_map!);
    end

    var _GraphicContextState&? state;
    finalize
        state = &{new GraphicContextState}(
                    {Math::min}({Display::get_width()},  width),
                    {Math::min}({Display::get_height()}, height));
    with
        _delete(&&state!);
    end
    this.state!.set_limit(_Rect(_Vector2i(0,0), _Size(width, height)));

    var _SceneContext&? scene_context;
    finalize
        scene_context = &{new SceneContext}(
            _Rect(_Vector2i(rect.left,rect.top), _Size(rect.width,rect.height))
        );
    with
        _delete(&&scene_context!);
    end

    var Color ambient_light = Color(this.plf.get_ambient_light().r,
                                    this.plf.get_ambient_light().g,
                                    this.plf.get_ambient_light().b,
                                    this.plf.get_ambient_light().a);

    spawn do
        par do
            // Playfield
            every gc in SCREENMANAGER_DRAW do
                this.scene_context!.clear();
                this.state!.push(this.scene_context!);
            end
        with
            every WORLD_UPDATE do
                this.game_time = this.game_time + 1;
            end
        with
            // Playfield
            every gc in SCREENMANAGER_DRAW do
                this.get_scene_context().light().fill_screen(
                    _Color(ambient_light.r,
                           ambient_light.g,
                           ambient_light.b,
                           ambient_light.a));
                this.gfx_map!.draw(this.get_scene_context());
                this.get_scene_context().color().draw(*gc, _Vector2i(0,0));
            end
        end
    end

    pool IPingu[] pingus;

    var GoalManager goal_manager with
        this.plf = &plf;
        this.counter = &outer.counter;
        this.game_time = &game_time;
    end;

    var PinguHolder pingu_holder with
        this.pingus  = &pingus;
        this.counter = &outer.counter;
    end;

    var Rect rect_small = Rect(6,{Display::get_size}().height-105, 175,100);
        // TODO: height originally comes from Screen/GUIScreen/SmallMap

    var TimeDisplay      _ = TimeDisplay.build(plf.get_time(), &game_time);
    var CPingusCounter   _ = CPingusCounter.build(&counter);

    var int dwidth  = {Display::get_width()};
    var int dheight = {Display::get_height()};
    var ArmageddonButton _ = ArmageddonButton.build(dwidth-40*1, dheight-62);
    var ForwardButton    _ = ForwardButton.build   (dwidth-40*2, dheight-62);
    var PauseButton      _ = PauseButton.build     (dwidth-40*3, dheight-62);
    var ButtonPanel button_panel;

    var Playfield playfield with
        this.action_next = &button_panel.action;
        this.pingus      = &pingus;
        this.rect        = &rect;
    end;

    var SmallMap smallmap  = SmallMap.build(rect_small, &pingu_holder, &playfield);
    var SmallMapImage    _ = SmallMapImage.build(&smallmap);
    var CaptureRectangle _ = CaptureRectangle.build(&playfield);

    var WorldObjFactory objs with
        this.plf = &plf;
        this.pingus = &pingus;
        this.game_time = &game_time;
        this.smallmap = &smallmap;
    end;

    this.state!.set_pos(_Vector2i(objs.pos_start.x,objs.pos_start.y));

    par/or do
        await goal_manager;
    with
        every (x_,y_) in global:go_create_pingu_particles do
            loop i in 50 do
                spawn PinguParticle with
                    this.x = x_;
                    this.y = y_;
                end;
            end
        end
    with
        every (x_,y_,vel_x_,vel_y_) in global:go_create_smoke_particles do
            spawn SmokeParticle with
                this.x     = x_;
                this.y     = y_;
                this.vel_x = vel_x_;
                this.vel_y = vel_y_;
            end;
        end
    with
        await global:go_armageddon;
        ///_GLOBAL_SERVER:send_armageddon_event();

        {Sound::PingusSound::play_sound("goodidea");};

        loop do
            loop i in 4 do
                await WORLD_UPDATE;
            end

            var IPingu&&? pingu;
            loop p in pingus do
                if p:current_action != {ActionName::BOMBER} then
                    pingu = p;
                    break;
                end
            end
            if pingu? then
                emit pingu!:go_action => {ActionName::BOMBER};
            end
        end
    with
        // Playfield
        every gc in SCREENMANAGER_DRAW do
            this.state!.pop(this.scene_context!);
            gc:draw(
                {new SceneContextDrawingRequest}(
                    &&this.scene_context!,
                    _Vector2i(0,0),
                    -10000)
                finalize with nothing; end
            );
        end
    end

    /* PUBLIC */

    function (void)=>int get_width do
        return this.width;
    end
    function (void)=>int get_height do
        return this.height;
    end

    function (void)=>_CollisionMap&& get_colmap do
        return _XXX_PURE(this.gfx_map!.get_colmap());
    end
    function (void)=>_GraphicContextState& get_state do
        return &this.state!;
    end
    function (void)=>_SceneContext& get_scene_context do
        return &this.scene_context!;
    end

    function (_CollisionMask&& mask,int x,int y,_Groundtype__GPType type)=>void put do
        this.gfx_map!.put(mask:get_surface(), x, y);
        this.gfx_map!.get_colmap():put(*mask, x, y, type);
    end
    function (_CollisionMask&& mask,int x,int y)=>void remove do
        this.gfx_map!.remove(mask:get_surface(), x, y);
        this.gfx_map!.get_colmap():remove(*mask, x, y);
    end
end

#endif
