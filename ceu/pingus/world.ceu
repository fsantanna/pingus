#ifndef _WORLD_CEU
#define _WORLD_CEU

native/pre do
    class Playfield;
end

native do
    ##include "src/pingus/world.hpp"
    ##include "src/pingus/components/playfield.hpp"
    ##include "src/pingus/components/smallmap.hpp"
    extern Playfield* GLOBAL_PLAYFIELD;
    extern SmallMap*  GLOBAL_SMALLMAP;
end
native @plain _World;
native @plain _Playfield, _SmallMap;

input (_World&&, _PingusLevel&&) WORLD_NEW;
input (_World&&) WORLD_DELETE;
input (_SceneContext&&) WORLD_DRAW;
input (_SmallMap&&) WORLD_DRAW_SMALLMAP;

input (_char&&, _WorldObj&&, _FileReader&&) WORLD_NEWOBJ;

input void WORLD_ARMAGEDDON;

#include "particles/pingu_particle_holder.ceu"
#include "particles/smoke_particle_holder.ceu"

interface IWorldObj with
end

#include "worldobjs/entrance.ceu"
#include "worldobjs/exit.ceu"
#include "worldobjs/groundpiece.ceu"
#include "worldobjs/guillotine.ceu"
#include "worldobjs/hotspot.ceu"
#include "worldobjs/laser_exit.ceu"
#include "worldobjs/liquid.ceu"
#include "worldobjs/smasher.ceu"
#include "worldobjs/spike.ceu"
#include "worldobjs/surface_background.ceu"

#include "pingu_holder.ceu"
#include "components/playfield.ceu"
#include "components/smallmap.ceu"

class WorldObjFactory with
do
    every (id_,obj_,reader_) in WORLD_NEWOBJ do
        if _strcmp(id_,"entrance")==0 then
            spawn Entrance with
                this.me     = &_XXX_PURE((_WorldObjs__Entrance&&)obj_);
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"exit")==0 then
            spawn Exit with
                this.me     = &_XXX_PURE((_WorldObjs__Exit&&)obj_);
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"groundpiece")==0 then
            spawn Groundpiece with
                this.me     = &_XXX_PURE((_WorldObjs__Groundpiece&&)obj_);
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"hotspot")==0 then
            spawn Hotspot with
                this.me     = &_XXX_PURE((_WorldObjs__Hotspot&&)obj_);
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"liquid")==0 then
            spawn Liquid with
                this.me     = &_XXX_PURE((_WorldObjs__Liquid&&)obj_);
                this.reader = reader_;
            end;
        else/if _strcmp(id_,"surface-background")==0 then
            spawn SurfaceBackground with
                this.me     = &_XXX_PURE((_WorldObjs__SurfaceBackground&&)obj_);
                this.reader = reader_;
            end;
        end
    end
end

class World with
    interface IWorld;

    var _PingusLevel&& plf;
do
    global:world = &&this;

    pool IWorldObj[] objs;

    var WorldObjFactory _;

    var PinguHolder pingu_holder with
        this.me = &_XXX_PTR2REF(outer.me.pingus);
        this.number_of_allowed = this.me.number_of_allowed;
    end;

    await SDL_DT;   // TODO: World is created before Playfield in C++

    var _Playfield&? playfield_ := &_XXX_PURE(_GLOBAL_PLAYFIELD);
    var Playfield playfield with
        this.pingu_holder = &pingu_holder;
        this.me           = &playfield_!;
    end;

    var _SmallMap&? smallmap_ := &_XXX_PURE(_GLOBAL_SMALLMAP);
    var SmallMap smallmap with
        this.pingu_holder = &pingu_holder;
        this.me           = &smallmap_!;
    end;

    par/or do
        AWAIT_UNTIL_MYSELF(_World, WORLD_DELETE);
    with
        every (x_,y_) in this.create_pingu_particles do
            loop i in 50 do
                spawn PinguParticle with
                    this.x = x_;
                    this.y = y_;
                end;
            end
        end
    with
        every (x_,y_,vel_x_,vel_y_) in this.create_smoke_particles do
            spawn SmokeParticle with
                this.x     = x_;
                this.y     = y_;
                this.vel_x = vel_x_;
                this.vel_y = vel_y_;
            end;
        end
    with
        me.do_armageddon = false;
        await WORLD_ARMAGEDDON;
        me.do_armageddon = true;

        {Sound::PingusSound::play_sound("goodidea");};

        loop do
            loop i in 4 do
                await WORLD_UPDATE;
            end

            var IPingu&&? pingu;
            loop p in pingu_holder.pingus do
                if p:current_action != {ActionName::BOMBER} then
                    pingu = p;
                    break;
                end
            end
            if pingu? then
                emit pingu!:go_action => {ActionName::BOMBER};
            end
        end
    end

    /* PUBLIC */

    function (void)=>IPinguHolderPool& get_pingu_holder do
        return &this.pingu_holder;
    end
end

class WorldFactory with
do
    every (me_,plf_) in WORLD_NEW do
        spawn World with
            this.me  = &_XXX_PTR2REF(me_);
            this.plf = plf_;
        end;
    end
end
var WorldFactory _;

#endif
