#ifndef _WORLD_CEU
#define _WORLD_CEU

native/pre do
    class Playfield;
end

native do
    ##include "src/pingus/world.hpp"
    ##include "src/pingus/components/playfield.hpp"
    ##include "src/pingus/components/smallmap.hpp"
    ##include "pingus/ground_map.hpp"
    extern Playfield* GLOBAL_PLAYFIELD;
    extern SmallMap*  GLOBAL_SMALLMAP;
end
native @plain _World;
native @plain _Playfield, _SmallMap, _SceneContext, _GroundMap;

input (_World&&, _PingusLevel&&) WORLD_NEW;
input (_World&&) WORLD_DELETE;
input void WORLD_UPDATE;
input (_SceneContext&&) WORLD_DRAW;

input (_char&&, _FileReader&&) WORLD_NEWOBJ;

input void WORLD_ARMAGEDDON;

input float GAMESESSION_UPDATE;

#include "particles/pingu_particle_holder.ceu"
#include "particles/smoke_particle_holder.ceu"

#define WORLD_gravitational_acceleration 0.2

interface IWorldObj with
end

#include "pingu_holder.ceu"
#include "components/smallmap.ceu"
#include "smallmap_image.ceu"

#include "worldobjs/entrance.ceu"
#include "worldobjs/exit.ceu"
#include "worldobjs/groundpiece.ceu"
#include "worldobjs/guillotine.ceu"
#include "worldobjs/hotspot.ceu"
#include "worldobjs/laser_exit.ceu"
#include "worldobjs/liquid.ceu"
#include "worldobjs/smasher.ceu"
#include "worldobjs/spike.ceu"
#include "worldobjs/surface_background.ceu"

#include "worldobj_factory.ceu"
#include "components/playfield.ceu"

class WorldFirst with
    var IWorld&        world;
    var _PingusLevel&& plf;
    var _GroundMap&    gfx_map;
    var int&           game_time;
do
    var Color ambient_light = Color(plf:get_ambient_light().r,
                                    plf:get_ambient_light().g,
                                    plf:get_ambient_light().b,
                                    plf:get_ambient_light().a);
    par do
        every WORLD_UPDATE do
            this.game_time = this.game_time + 1;
        end
    with
        every gc in WORLD_DRAW do
            gc:light().fill_screen(_Color(ambient_light.r,
                                          ambient_light.g,
                                          ambient_light.b,
                                          ambient_light.a));
            gfx_map.draw(*gc);
            gc:color().draw(world.me, _Vector2i(0,0));
        end
    end
end

class World with
    interface IWorld;

    var _PingusLevel&& plf;
    function (int)=>_Vector2i     get_start_pos;
    function (void)=>PinguHolder& get_pingus;
do
    this.me.ceu = &&this;
    global:world = &&this;

    var _GroundMap&? gfx_map;
    finalize
        gfx_map = &{new GroundMap}(this.plf:get_size().width,
                                   this.plf:get_size().height);
    with
        _delete(&&gfx_map!);
    end
    this.me.colmap  = gfx_map!.get_colmap();

    var int game_time = 0;
    var WorldFirst _ with
        this.world     = &outer;
        this.plf       = outer.plf;
        this.gfx_map   = &gfx_map!;
        this.game_time = &game_time;
    end;

    var SmallMapImage _ with
        this.width  = 175;      /// TODO: take from SmallMap
        this.height = 100;      /// TODO: take from SmallMap
    end;

    var WorldObjFactory objs with
        this.plf = outer.plf;
    end;

    var PinguHolder pingu_holder with
        this.number_of_allowed = plf:get_number_of_pingus();
    end;

/// TODO
await SDL_DT;   // TODO: World is created before Playfield in C++

    var _Playfield&? playfield_ := &_XXX_PURE(_GLOBAL_PLAYFIELD);
    var Playfield playfield with
        this.pingu_holder = &pingu_holder;
        this.me           = &playfield_!;
    end;

    var Rect rect = Rect(6,{Display::get_size}().height-105, 175,100);
        // TODO: height originally comes from Screen/GUIScreen/SmallMap

    var _SmallMap&? smallmap_ := &_XXX_PURE(_GLOBAL_SMALLMAP);
    var SmallMap smallmap with
        this.pingu_holder = &pingu_holder;
        this.me           = &smallmap_!;
        this.rect         = rect;
    end;

    var bool in_armageddon = false;

    par/or do
        AWAIT_UNTIL_MYSELF(_World, WORLD_DELETE);
    with
        every (x_,y_) in this.create_pingu_particles do
            loop i in 50 do
                spawn PinguParticle with
                    this.x = x_;
                    this.y = y_;
                end;
            end
        end
    with
        every (x_,y_,vel_x_,vel_y_) in this.create_smoke_particles do
            spawn SmokeParticle with
                this.x     = x_;
                this.y     = y_;
                this.vel_x = vel_x_;
                this.vel_y = vel_y_;
            end;
        end
    with
        await WORLD_ARMAGEDDON;
        this.in_armageddon = true;

        {Sound::PingusSound::play_sound("goodidea");};

        loop do
            loop i in 4 do
                await WORLD_UPDATE;
            end

            var IPingu&&? pingu;
            loop p in pingu_holder.pingus do
                if p:current_action != {ActionName::BOMBER} then
                    pingu = p;
                    break;
                end
            end
            if pingu? then
                emit pingu!:go_action => {ActionName::BOMBER};
            end
        end
    end

    /* PUBLIC */

    function (void)=>IPinguHolderPool& get_pingu_holder do
        return &this.pingu_holder;
    end

    function (int player_id)=>_Vector2i get_start_pos do
        // FIXME: Workaround for lack of start-pos
        var int num_entrances = 0;
        var Vector2i pos = Vector2i(0,0);
        loop entrance in this.objs.entrances do
            num_entrances = num_entrances + 1;
            var _Vector3f pos_ = entrance:get_pos();
            pos.x = pos.x + (int)pos_.x;
            pos.y = pos.y + (int)pos_.y;
        end

        if (num_entrances > 0) then
            pos.x = pos.x / num_entrances;
            pos.y = pos.y / num_entrances;
            pos.y = pos.y + 100;
        end

        return _Vector2i(pos.x, pos.y);
    end

    function (void)=>int get_time do
        return this.game_time;
    end

    function (void)=>PinguHolder& get_pingus do
        return &this.pingu_holder;
    end

    function (void)=>int get_width do
        return this.gfx_map!.get_width();
    end
    function (void)=>int get_height do
        return this.gfx_map!.get_height();
    end

    function (void)=>bool check_armageddon do
        return this.in_armageddon;
    end

    function (_std__string name, _Vector3f pos, float volume)=>void play_sound do
        var float panning = 0.0;
        return {Sound::PingusSound::play_sound}(name, volume, panning);
    end

    function (void)=>float get_gravity do
        return WORLD_gravitational_acceleration;
    end

    function (void)=>_GroundMap&& get_gfx_map do
        return _XXX_PURE(&&this.gfx_map!);
    end
    function (void)=>_CollisionMap&& get_colmap do
        return _XXX_PURE(this.gfx_map!.get_colmap());
    end

    function (_CollisionMask&& mask,int x,int y,_Groundtype__GPType type)=>void put do
        this.gfx_map!.put(mask:get_surface(), x, y);
        this.gfx_map!.get_colmap():put(*mask, x, y, type);
    end
    function (_CollisionMask&& mask,int x,int y)=>void remove do
        this.gfx_map!.remove(mask:get_surface(), x, y);
        this.gfx_map!.get_colmap():remove(*mask, x, y);
    end
end

class WorldFactory with
do
    every (me_,plf_) in WORLD_NEW do
        spawn World with
            this.me  = &_XXX_PTR2REF(me_);
            this.plf = plf_;
        end;
    end
end
var WorldFactory _;

#endif
