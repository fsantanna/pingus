#ifndef _PINGU_CEU
#define _PINGU_CEU

native/pre do
    ##define ActionName__Enum ActionName::Enum
    ##define Pingu__PinguStatus Pingu::PinguStatus
    ##define PinguAction_shared_ptr std::shared_ptr<PinguAction>
    enum {
        PS_ALIVE, PS_EXITED, PS_DEAD
    };
end
native/plain _ActionName__Enum, _Pingu__PinguStatus;

native/pre do
    ##include "pingus/collision_map.hpp"
    ##include "pingus/pingu_enums.hpp"
    ///##define GC_COLOR_DRAW(gc,x,y) gc->color().draw(x,y)
    enum Dir { LEFT = -1, NONE = 0, RIGHT = +1 };
end
///native @nohold _GC_COLOR_DRAW();

native/pre do
    class Vector3f;
    class GroundMap;
    class PinguHolder;
    class PingusLevel;
    class CollisionMap;
    class Pingu;
    class SmallMap;
    class SceneContext;
    ##include "pingus/collision_mask.hpp"
    ##include "../src/pingus/groundtype.hpp"
    ##include "../src/pingus/action_name.hpp"
end

#if 0
#include "../engine/display/sprite.ceu"
#include "actions/basher.ceu"
#include "actions/blocker.ceu"
#include "actions/bomber.ceu"
#include "actions/bridger.ceu"
#include "actions/climber.ceu"
#include "actions/digger.ceu"
#include "actions/drown.ceu"
#include "actions/exiter.ceu"
#include "actions/floater.ceu"
#include "actions/jumper.ceu"
#include "actions/laser_kill.ceu"
#include "actions/miner.ceu"
#include "actions/splashed.ceu"
#include "actions/slider.ceu"
#include "actions/waiter.ceu"
#endif

#include "right_left_sprites.ceu"

code/await Pingu (pool&[] Pingu  pingus,
                  var     uint   id,
                  var     int    owner_id,
                  var     Rect   rect,
                  var     s8?    direction_)
                    -> (vector&[] byte name)
                        -> int
#if 0
    interface IPingu;
#endif
do
    var s8 direction = do
        if direction_? then
            escape direction_!;
        else
            escape {LEFT};
        end
    end;

    var Vector3f velocity = val Vector3f(0, 0, 0);

    vector[] byte name_;
    name = &name_;

    var _ActionName__Enum current_action = {ActionName::FALLER};
    var _ActionName__Enum wall_action    = {ActionName::NONE};
    var _ActionName__Enum fall_action    = {ActionName::NONE};

    #include "pingu_tights.ceu"
    #include "movers/linear_mover.ceu"
    #include "actions/walker.ceu"
    #include "actions/faller.ceu"

    watching 5s do
        //await Walker(current_action);
        await Faller(current_action);
    end
    emit outer.world.ok_pingu({PS_DEAD});

#if 0
    var int ret =
    do
        event _ActionName__Enum e_set_action;
        par do
            loop do
                await WORLD_UPDATE;

                // FIXME: Out of screen check is ugly
                /* The Pingu has hit the edge of the screen, a good time to let
                   him die.
                 */
                if this.rel_getpixel(0,-1) == {Groundtype::GP_OUTOFSCREEN} then
                    //Sound::PingusSound::play_sound("die");
    // TODO: copied from walker.ceu
                    this.set_x(this.get_x() + (float)(this.direction));
                    escape _PS_DEAD;
                end

                if this.rel_getpixel(0,-1) == {Groundtype::GP_WATER} or
                   this.rel_getpixel(0,-1) == {Groundtype::GP_LAVA}
                then
                    emit e_set_action => {ActionName::DROWN};
                    break;  // no more checks, will die
                end


                // if it has hit the ground too quickly
                if this.rel_getpixel(0,-1) != {Groundtype::GP_NOTHING} and
                        this.velocity.y > _deadly_velocity
                then
                    emit e_set_action => {ActionName::SPLASHED};
                    break;  // no more checks, will die
                end
            end
            await FOREVER;
        with
            every new_action in this.go_action do
                if new_action!={ActionName::EXITER} and new_action!={ActionName::LASERKILL} then
                    _assert(this.check_action(new_action));
                end
                if not this.check_action(new_action) then
                    continue;
                end

                var int mode = {ActionName::ACTIVATION_MODE}[new_action];

                if mode == {ActionType::INSTANT} then
                    if new_action != this.current_action and
                       {ActionName::CHANGE_ALLOWED}
                            [this.current_action][new_action]
                    then
                        emit e_set_action => new_action;
                    end
                else/if mode == {ActionType::WALL_TRIGGERED} then
                    this.wall_action = new_action;
                else/if mode == {ActionType::FALL_TRIGGERED} then
                    this.fall_action = new_action;
                end
            end
        with
            loop do
                name = [] .. (_char&&){ActionName::to_screenname}
                                (this.current_action);
                par/or do
                    this.current_action = await e_set_action;
                with
                    #define DO_PINGU_ACTION(T)                              \
                    do                                                      \
                        var int a = do T with                               \
                            this.pingus = &outer.pingus;                    \
                            this.pingu = &outer;                            \
                            this.previous_action = outer.current_action;    \
                        end;                                                \
                        escape (_ActionName__Enum)a;                        \
                    end
                    if this.current_action == {ActionName::NONE} then
                        _assert(not "invalid action");
                        await FOREVER;
                    else/if this.current_action == {ActionName::DEAD} then
                        escape _PS_DEAD;
                    else/if this.current_action == {ActionName::BASHER} then
                        this.current_action = DO_PINGU_ACTION(Basher);
                    else/if this.current_action == {ActionName::BLOCKER} then
                        this.current_action = DO_PINGU_ACTION(Blocker);
                    else/if this.current_action == {ActionName::BOMBER} then
                        this.current_action = DO_PINGU_ACTION(Bomber);
                    else/if this.current_action == {ActionName::BRIDGER} then
                        this.current_action = DO_PINGU_ACTION(Bridger);
                    else/if this.current_action == {ActionName::CLIMBER} then
                        this.current_action = DO_PINGU_ACTION(Climber);
                    else/if this.current_action == {ActionName::DIGGER} then
                        this.current_action = DO_PINGU_ACTION(Digger);
                    else/if this.current_action == {ActionName::DROWN} then
                        this.current_action = DO_PINGU_ACTION(Drown);
                    else/if this.current_action == {ActionName::EXITER} then
                        this.current_action = DO_PINGU_ACTION(Exiter);
                        escape _PS_EXITED;
                    else/if this.current_action == {ActionName::FALLER} then
                        this.current_action = DO_PINGU_ACTION(Faller);
                    else/if this.current_action == {ActionName::FLOATER} then
                        this.current_action = DO_PINGU_ACTION(Floater);
                    else/if this.current_action == {ActionName::JUMPER} then
                        this.current_action = DO_PINGU_ACTION(Jumper);
                    else/if this.current_action == {ActionName::LASERKILL} then
                        this.current_action = DO_PINGU_ACTION(LaserKill);
                    else/if this.current_action == {ActionName::MINER} then
                        this.current_action = DO_PINGU_ACTION(Miner);
                    else/if this.current_action == {ActionName::SLIDER} then
                        this.current_action = DO_PINGU_ACTION(Slider);
                    else/if this.current_action == {ActionName::SPLASHED} then
                        this.current_action = DO_PINGU_ACTION(Splashed);
                    else/if this.current_action == {ActionName::WAITER} then
                        this.current_action = DO_PINGU_ACTION(Waiter);
                    else/if this.current_action == {ActionName::WALKER} then
                        this.current_action = DO_PINGU_ACTION(Walker);
                    else
                        _assert({!"Invalid action name provied"});
                        await FOREVER;
                    end
                end
            end
        end
    end;

    _assert(ret != _PS_ALIVE);
    emit global:ok_pingu => ret;

    /* END-OF-BODY */

    /* PUBLIC */

    function (void)=>int get_xi do
        return (int)this.rect.left;
    end
    function (void)=>int get_yi do
        return (int)this.rect.top;
    end

    function (void)=>Vector3f get_center_pos do
        var Vector3f vec = Vector3f(this.rect.left, this.rect.top-16, 0);
        return vec;
    end

    function (s8 d)=>void set_direction do
        this.direction = d;
    end

    // Returns true if the given koordinates are above the pingu
    function (int x, int y)=>bool is_over do
        var Vector3f center = this.get_center_pos();
        return (center.x+16 > x and
                center.x-16 < x and
                center.y+16 > y and
                center.y-16 < y);
    end

    function (int x1, int y1, int x2, int y2)=>bool is_inside do
        _assert (x1 < x2);
        _assert (y1 < y2);

        return (this.rect.left > x1 and
                this.rect.left < x2 and
                this.rect.top > y1 and
                this.rect.top < y2);
    end

    // Returns the distance between the Pingu and a given coordinate
    function (int x, int y)=>float dist do
        var Vector3f p = this.get_center_pos();

        return {Math::sqrt}(((p.x - (float)(x)) * (p.x - (float)(x)) +
                             (p.y - (float)(y)) * (p.y - (float)(y))));
    end

    function (void)=>int get_id do
        return this.id;
    end

    function (void)=>int get_owner do
        return this.owner_id;
    end

    function (_ActionName__Enum new_action)=>bool check_action do
        var int mode = {ActionName::ACTIVATION_MODE}[new_action];

        if mode == {ActionType::INSTANT} then
            return (new_action!=this.current_action) and
                   {ActionName::CHANGE_ALLOWED}[this.current_action][new_action];
        else/if mode == {ActionType::WALL_TRIGGERED} then
            return (this.wall_action != new_action);
        else/if mode == {ActionType::FALL_TRIGGERED} then
            return (this.fall_action != new_action);
        else //if mode == {ActionType::COUNTDOWN_TRIGGERED} then
            _assert(not "DEAD CODE???");
        end
    end

#if 0
    void
    Pingu::apply_force (Vector3f arg_v)
    {
      velocity += arg_v;
      // Moving the pingu on pixel up, so that the force can take effect
      // FIXME: this should be handled by a state-machine
      --rect.top;
    }
#endif
#endif
end

#endif
