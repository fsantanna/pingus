#ifndef _PINGU_CEU
#define _PINGU_CEU

input (_Pingu&&) PINGU_NEW;
input (_Pingu&&) PINGU_DELETE;
input (_Pingu&&) PINGU_UPDATE;

input (_Pingu&&, bool&&, _ActionName__Enum) PINGU_REQUEST_SET_ACTION;
input (_Pingu&&, _ActionName__Enum)         PINGU_SET_ACTION;

#include "actions/basher.ceu"
#include "actions/blocker.ceu"
#include "actions/bomber.ceu"
#include "actions/bridger.ceu"
#include "actions/digger.ceu"
#include "actions/drown.ceu"
#include "actions/exiter.ceu"
#include "actions/faller.ceu"
#include "actions/floater.ceu"
#include "actions/jumper.ceu"
#include "actions/miner.ceu"
#include "actions/waiter.ceu"
#include "actions/walker.ceu"

native/pre do
    using namespace Actions;
    ##define ActionName__Enum ActionName::Enum
    ##define PinguAction_shared_ptr std::shared_ptr<PinguAction>
end
native @plain _Pingu, _ActionName__Enum;

interface IAction with
    var _PinguAction& me;
end

class Pingu with
    var _Pingu& me;
    pool IAction[]& actions;
do
    event _ActionName__Enum e_set_action;
    par/or do
        AWAIT_UNTIL_MYSELF(_Pingu,PINGU_DELETE);
    with
        loop do
            AWAIT_UNTIL_MYSELF(_Pingu,PINGU_UPDATE);

            /// TODO(control)
            // FIXME: Out of screen check is ugly
            /* The Pingu has hit the edge of the screen, a good time to let
               him die.
             */
            if me.rel_getpixel(0,-1) == {Groundtype::GP_OUTOFSCREEN} then
                //Sound::PingusSound::play_sound("die");
                me.status = {Pingu::PS_DEAD};
            end
            if me.status == {Pingu::PS_DEAD} then
                break;
            end

            // if an countdown action is set, update the countdown time
            if me.action_time > -1 then
                me.action_time = me.action_time - 1;
            end
            if me.action_time==0 and (me.countdown_action!={ActionName::NONE}) then
                // Reset the countdown action handlers
                me.countdown_action = {ActionName::NONE};
                me.set_action(me.countdown_action);
                me.action_time = -1;
                break;
            end

            me.action:update();
        end
        await FOREVER;
    with
        loop do
            var _Pingu&& ptr;
            var bool&&   ret_val;
            var _ActionName__Enum action_name;
            (ptr, ret_val, action_name) = await PINGU_REQUEST_SET_ACTION
                                          until ptr == &&this.me;
            *ret_val = false;

            if me.status == {Pingu::PS_DEAD} then
                _log_debug("Setting action to a dead pingu");
                continue;
            end

            var int mode = {PinguAction::get_activation_mode}(action_name);

            if mode == {ActionType::INSTANT} then
                if action_name == me.action:get_type() then
                    _log_debug("Pingu: Already have action");
                    *ret_val = false;
                else/if me.action:change_allowed(action_name) then
                    _log_debug("setting instant action");
                    *ret_val = true;
                    emit e_set_action => action_name;
                else
                    _log_debug("change from action %1% not allowed",
                               me.action:get_name());
                    *ret_val = false;
                end
            else/if mode == {ActionType::WALL_TRIGGERED} then
                if me.wall_action == action_name then
                    _log_debug("Not using wall action, we have already");
                    *ret_val = false;
                else
                    _log_debug("Setting wall action");
                    me.wall_action = action_name;
                    *ret_val = true;
                end
            else/if mode == {ActionType::FALL_TRIGGERED} then
                if me.fall_action == action_name then
                    _log_debug("Not using fall action, we have already");
                    *ret_val = false;
                else
                    _log_debug("Setting fall action");
                    me.fall_action = action_name;
                    *ret_val = true;
                end
            else/if mode == {ActionType::COUNTDOWN_TRIGGERED} then
                if me.countdown_action == action_name then
                    _log_debug("Not using countdown action, we have already");
                    *ret_val = false;
                else
                    _log_debug("Setting countdown action");
                    // We set the action and start the countdown
                    ///std::shared_ptr<PinguAction> act = me.create_action(action_name);
                    me.action_time = -1;///me.act:activation_time();
                    me.countdown_action = action_name;
                    *ret_val = true;
                end
            else
                _log_debug("unknown action activation_mode");
                *ret_val = false;
                _assert(0);
            end
        end
    with
//_printf(">>> OK\n");
        var int bad = 0;
par do
    every (ptr,action) in PINGU_SET_ACTION do
        if ptr == &&this.me then
            bad = bad + 1;
            emit e_set_action => action;
        end
    end
with
        var   _ActionName__Enum action = {ActionName::FALLER};
        loop do
            par/or do
                action = await e_set_action;
                bad = bad - 1;
            with
                #define DO_PINGU_ACTION(T)                          \
                do                                                  \
                    var _##T&& ptr = _XXX_PURE({new T}(&&this.me)   \
                                                     finalize with nothing; end); \
                    me.action.reset(ptr)                            \
                        finalize with nothing; end;                 \
                    var int a = do T with                           \
                        this.me = &_XXX_PTR2REF(ptr);               \
                    end;                                            \
                    escape (_ActionName__Enum)a;                    \
                end
                if action == {ActionName::NONE} then
                    await FOREVER;
                else/if action == {ActionName::DEAD} then
                    me.set_status({Pingu::PS_DEAD});
                    break;
                    ///escape {Pingu:PS_DEAD};
                else/if action == {ActionName::BASHER} then
                    action = DO_PINGU_ACTION(Basher);
                else/if action == {ActionName::BLOCKER} then
                    action = DO_PINGU_ACTION(Blocker);
                else/if action == {ActionName::BOMBER} then
                    action = DO_PINGU_ACTION(Bomber);
                else/if action == {ActionName::BRIDGER} then
                    action = DO_PINGU_ACTION(Bridger);
                else/if action == {ActionName::DIGGER} then
                    action = DO_PINGU_ACTION(Digger);
                else/if action == {ActionName::DROWN} then
                    action = DO_PINGU_ACTION(Drown);
                else/if action == {ActionName::EXITER} then
                    action = DO_PINGU_ACTION(Exiter);
                    me.set_status({Pingu::PS_EXITED});
                    await FOREVER;
                    ///escape {Pingu:PS_EXITED};
                else/if action == {ActionName::FALLER} then
                    action = DO_PINGU_ACTION(Faller);
                else/if action == {ActionName::FLOATER} then
                    action = DO_PINGU_ACTION(Floater);
                else/if action == {ActionName::MINER} then
                    action = DO_PINGU_ACTION(Miner);
                else/if action == {ActionName::WAITER} then
                    action = DO_PINGU_ACTION(Waiter);
                else/if action == {ActionName::WALKER} then
                    action = DO_PINGU_ACTION(Walker);
                else
                    _assert({!"Invalid action name provied"});
                    await FOREVER;
                end
            end
        end
with
    every e_set_action do
        if bad > 0 then
            _assert({!"MISSED SET_ACTION"});
        end
    end
end
    end
//_printf(">>> DEAD\n");
end

pool IAction[] actions;

class PinguFactory with
    pool IAction[]& actions;
do
    every me_ in PINGU_NEW do
        spawn Pingu with
            this.me      = &_XXX_PTR2REF(me_);
            this.actions = &outer.actions;
        end;
    end
end

var PinguFactory _ with
    this.actions = &actions;
end;

#endif
