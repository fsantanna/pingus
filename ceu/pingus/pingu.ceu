#ifndef _PINGU_CEU
#define _PINGU_CEU

native do
    ##include "../src/engine/display/scene_context.hpp"
    ##include "pingus/collision_map.hpp"
    ##include "pingus/direction.hpp"
    ##define GC_COLOR_DRAW(gc,x,y) gc->color().draw(x,y)
    enum Dir { LEFT = -1, NONE = 0, RIGHT = +1 };
end
native @nohold _GC_COLOR_DRAW();

native/pre do
    ##include "../src/pingus/world.hpp"
    ##include "../src/pingus/action_name.hpp"
end

#include "../engine/display/sprite.ceu"
#include "actions/basher.ceu"
#include "actions/blocker.ceu"
#include "actions/bomber.ceu"
#include "actions/bridger.ceu"
#include "actions/climber.ceu"
#include "actions/digger.ceu"
#include "actions/drown.ceu"
#include "actions/exiter.ceu"
#include "actions/faller.ceu"
#include "actions/floater.ceu"
#include "actions/jumper.ceu"
#include "actions/laser_kill.ceu"
#include "actions/miner.ceu"
#include "actions/splashed.ceu"
#include "actions/slider.ceu"
#include "actions/waiter.ceu"
#include "actions/walker.ceu"

native/pre do
    ##define ActionName__Enum ActionName::Enum
    ##define Pingu__PinguStatus Pingu::PinguStatus
    ##define PinguAction_shared_ptr std::shared_ptr<PinguAction>
    enum {
        PS_ALIVE, PS_EXITED, PS_DEAD
    };
end
native @plain _ActionName__Enum, _Pingu__PinguStatus;

class Pingu with
    interface IPingu;

    var  uint id;
    var  int  owner_id;
    var  s8   direction = _LEFT;

    var _ActionName__Enum current_action = {ActionName::FALLER};
    var _ActionName__Enum wall_action    = {ActionName::NONE};
    var _ActionName__Enum fall_action    = {ActionName::NONE};
do
    var Vector3f velocity = Vector3f(0, 0, 0);
    var char[] name;

    var int ret =
    do
        event _ActionName__Enum e_set_action;
        par do
            loop do
                await WORLD_UPDATE;

                // FIXME: Out of screen check is ugly
                /* The Pingu has hit the edge of the screen, a good time to let
                   him die.
                 */
                if this.rel_getpixel(0,-1) == {Groundtype::GP_OUTOFSCREEN} then
                    //Sound::PingusSound::play_sound("die");
    // TODO: copied from walker.ceu
                    this.set_x(this.get_x() + (float)(this.direction));
                    escape _PS_DEAD;
                end

                if this.rel_getpixel(0,-1) == {Groundtype::GP_WATER} or
                   this.rel_getpixel(0,-1) == {Groundtype::GP_LAVA}
                then
                    emit e_set_action => {ActionName::DROWN};
                    break;  // no more checks, will die
                end


                // if it has hit the ground too quickly
                if this.rel_getpixel(0,-1) != {Groundtype::GP_NOTHING} and
                        this.velocity.y > _deadly_velocity
                then
                    emit e_set_action => {ActionName::SPLASHED};
                    break;  // no more checks, will die
                end
            end
            await FOREVER;
        with
            every new_action in this.go_action do
                if new_action!={ActionName::EXITER} and new_action!={ActionName::LASERKILL} then
                    _assert(this.check_action(new_action));
                end
                if not this.check_action(new_action) then
                    continue;
                end

                var int mode = {ActionName::ACTIVATION_MODE}[new_action];

                if mode == {ActionType::INSTANT} then
                    if new_action != this.current_action and
                       {ActionName::CHANGE_ALLOWED}
                            [this.current_action][new_action]
                    then
                        emit e_set_action => new_action;
                    end
                else/if mode == {ActionType::WALL_TRIGGERED} then
                    this.wall_action = new_action;
                else/if mode == {ActionType::FALL_TRIGGERED} then
                    this.fall_action = new_action;
                end
            end
        with
            loop do
                name = [] .. (char&&){ActionName::to_screenname}
                                (this.current_action);
                par/or do
                    this.current_action = await e_set_action;
                with
                    #define DO_PINGU_ACTION(T)                              \
                    do                                                      \
                        var int a = do T with                               \
                            this.pingu = &outer;                            \
                            this.previous_action = outer.current_action;    \
                        end;                                                \
                        escape (_ActionName__Enum)a;                        \
                    end
                    if this.current_action == {ActionName::NONE} then
                        _assert(not "invalid action");
                        await FOREVER;
                    else/if this.current_action == {ActionName::DEAD} then
                        escape _PS_DEAD;
                    else/if this.current_action == {ActionName::BASHER} then
                        this.current_action = DO_PINGU_ACTION(Basher);
                    else/if this.current_action == {ActionName::BLOCKER} then
                        this.current_action = DO_PINGU_ACTION(Blocker);
                    else/if this.current_action == {ActionName::BOMBER} then
                        this.current_action = DO_PINGU_ACTION(Bomber);
                    else/if this.current_action == {ActionName::BRIDGER} then
                        this.current_action = DO_PINGU_ACTION(Bridger);
                    else/if this.current_action == {ActionName::CLIMBER} then
                        this.current_action = DO_PINGU_ACTION(Climber);
                    else/if this.current_action == {ActionName::DIGGER} then
                        this.current_action = DO_PINGU_ACTION(Digger);
                    else/if this.current_action == {ActionName::DROWN} then
                        this.current_action = DO_PINGU_ACTION(Drown);
                    else/if this.current_action == {ActionName::EXITER} then
                        this.current_action = DO_PINGU_ACTION(Exiter);
                        escape _PS_EXITED;
                    else/if this.current_action == {ActionName::FALLER} then
                        this.current_action = DO_PINGU_ACTION(Faller);
                    else/if this.current_action == {ActionName::FLOATER} then
                        this.current_action = DO_PINGU_ACTION(Floater);
                    else/if this.current_action == {ActionName::JUMPER} then
                        this.current_action = DO_PINGU_ACTION(Jumper);
                    else/if this.current_action == {ActionName::LASERKILL} then
                        this.current_action = DO_PINGU_ACTION(LaserKill);
                    else/if this.current_action == {ActionName::MINER} then
                        this.current_action = DO_PINGU_ACTION(Miner);
                    else/if this.current_action == {ActionName::SLIDER} then
                        this.current_action = DO_PINGU_ACTION(Slider);
                    else/if this.current_action == {ActionName::SPLASHED} then
                        this.current_action = DO_PINGU_ACTION(Splashed);
                    else/if this.current_action == {ActionName::WAITER} then
                        this.current_action = DO_PINGU_ACTION(Waiter);
                    else/if this.current_action == {ActionName::WALKER} then
                        this.current_action = DO_PINGU_ACTION(Walker);
                    else
                        _assert({!"Invalid action name provied"});
                        await FOREVER;
                    end
                end
            end
        end
    end;

    _assert(ret != _PS_ALIVE);
    emit holder.ok_pingu => ret;

    /* END-OF-BODY */

    /* PUBLIC */

    function (void)=>float get_x do
        return this.pos_x;
    end
    function (void)=>float get_y do
        return this.pos_y;
    end
    function (void)=>int get_xi do
        return (int)this.pos_x;
    end
    function (void)=>int get_yi do
        return (int)this.pos_y;
    end
    function (void)=>Vector3f get_pos do
        var Vector3f vec = Vector3f(this.pos_x, this.pos_y, 0);
        return vec;
    end

    function (float x)=>void set_x do
        this.pos_x = x;
    end

    function (float y)=>void set_y do
        this.pos_y = y;
    end
    function (float x, float y)=>void set_pos do
        this.set_x(x);
        this.set_y(y);
    end

    function (void)=>Vector3f get_center_pos do
        var Vector3f vec = Vector3f(this.pos_x, this.pos_y-16, 0);
        return vec;
    end

    function (void)=>Vector3f get_velocity do
        return this.velocity;
    end

    function (Vector3f velocity_)=>void set_velocity do
        this.velocity = velocity_;

        // crude terminal velocity
        this.velocity.x =
            (float){Math::clamp}(-_terminal_velocity, this.velocity.x, _terminal_velocity);
        this.velocity.y =
            (float){Math::clamp}(-_terminal_velocity, this.velocity.y, _terminal_velocity);
    end

    function (s8 d)=>void set_direction do
        this.direction = d;
    end

    function (void)=>void change_direction do
        if this.direction == _LEFT then
            this.direction = _RIGHT;
        else
            this.direction = _LEFT;
        end
    end

    function (int x, int y)=>int rel_getpixel do
/// TODO: w/o me.ceu this function becomes @rec
        return _GLOBAL_WORLD_COLMAP:getpixel(
        //return global:world!:get_colmap():getpixel(
        //return global:world!:me.colmap:getpixel(
                (int)(this.pos_x + (float)(x * this.direction)),
                (int)(this.pos_y - (float)(y)));
    end

    function (int x, int y)=>bool head_collision_on_walk do
        var int pixel = this.rel_getpixel(x, y + _pingu_height);
        if (     pixel != {Groundtype::GP_NOTHING} and
            not (pixel &  {Groundtype::GP_BRIDGE}))
        then
            return true;
        else
            return false;
        end
    end

    // Returns true if the given koordinates are above the pingu
    function (int x, int y)=>bool is_over do
        var Vector3f center = this.get_center_pos();
        return (center.x+16 > x and
                center.x-16 < x and
                center.y+16 > y and
                center.y-16 < y);
    end

    function (int x1, int y1, int x2, int y2)=>bool is_inside do
        _assert (x1 < x2);
        _assert (y1 < y2);

        return (this.pos_x > x1 and
                this.pos_x < x2 and
                this.pos_y > y1 and
                this.pos_y < y2);
    end

    // Returns the distance between the Pingu and a given coordinate
    function (int x, int y)=>float dist do
        var Vector3f p = this.get_center_pos();

        return {Math::sqrt}(((p.x - (float)(x)) * (p.x - (float)(x)) +
                             (p.y - (float)(y)) * (p.y - (float)(y))));
    end

    function (void)=>int get_id do
        return this.id;
    end

    function (void)=>int get_owner do
        return this.owner_id;
    end

    function (void)=>_std__string get_owner_str do
        {
            std::ostringstream ostr;
            ostr << THIS_F(CEU_Pingu)->owner_id;
        };
        return _ostr.str();
    end

    function (void)=>char[]& get_name do
        return &this.name;
    end

    function (_ActionName__Enum new_action)=>bool check_action do
        var int mode = {ActionName::ACTIVATION_MODE}[new_action];

        if mode == {ActionType::INSTANT} then
            return (new_action!=this.current_action) and
                   {ActionName::CHANGE_ALLOWED}[this.current_action][new_action];
        else/if mode == {ActionType::WALL_TRIGGERED} then
            return (this.wall_action != new_action);
        else/if mode == {ActionType::FALL_TRIGGERED} then
            return (this.fall_action != new_action);
        else //if mode == {ActionType::COUNTDOWN_TRIGGERED} then
            _assert(not "DEAD CODE???");
        end
    end

#if 0
    void
    Pingu::apply_force (Vector3f arg_v)
    {
      velocity += arg_v;
      // Moving the pingu on pixel up, so that the force can take effect
      // FIXME: this should be handled by a state-machine
      --pos_y;
    }
#endif
end

#endif
