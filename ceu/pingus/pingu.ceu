#ifndef _PINGU_CEU
#define _PINGU_CEU

native do
    ##include "../src/engine/display/scene_context.hpp"
    ##include "pingus/collision_map.hpp"
    ##include "pingus/direction.hpp"
    ##define GC_COLOR_DRAW(gc,x,y) gc->color().draw(x,y)
    enum Dir { LEFT = -1, NONE = 0, RIGHT = +1 };
end
native @nohold _GC_COLOR_DRAW();

native/pre do
    ##include "../src/pingus/pingu_holder.hpp"
    ##include "../src/pingus/world.hpp"
    ##include "../src/pingus/pingu.hpp"
    ##include "../src/pingus/action_name.hpp"
end

#include "../engine/display/sprite_pingu.ceu"
#include "actions/basher.ceu"
#include "actions/blocker.ceu"
#include "actions/bomber.ceu"
#include "actions/bridger.ceu"
#include "actions/digger.ceu"
#include "actions/drown.ceu"
#include "actions/exiter.ceu"
#include "actions/faller.ceu"
#include "actions/floater.ceu"
#include "actions/jumper.ceu"
#include "actions/miner.ceu"
#include "actions/splashed.ceu"
#include "actions/waiter.ceu"
#include "actions/walker.ceu"

native/pre do
    ##define ActionName__Enum ActionName::Enum
    ##define Pingu__PinguStatus Pingu::PinguStatus
    ##define PinguAction_shared_ptr std::shared_ptr<PinguAction>
end
native @plain _Pingu, _ActionName__Enum, _Pingu__PinguStatus;

class Pingu with
    interface IPingu;

    var   s8              direction   = _LEFT;
    var _ActionName__Enum wall_action = {ActionName::NONE};
    var _ActionName__Enum fall_action = {ActionName::NONE};
do
    var Vector3f velocity = Vector3f(0, 0, 0);
    this.me.ceu = &&this;

    this.holder.number_of_released = this.holder.number_of_released + 1;
    this.holder.number_of_alive    = this.holder.number_of_alive    + 1;
    finalize with
        this.holder.number_of_alive = this.holder.number_of_alive - 1;
    end

    me.current_action = {ActionName::FALLER};

    var _Pingu__PinguStatus ret =
    do
        event _ActionName__Enum e_set_action;
        par do
            loop do
                await WORLD_UPDATE;

                // FIXME: Out of screen check is ugly
                /* The Pingu has hit the edge of the screen, a good time to let
                   him die.
                 */
                if this.rel_getpixel(0,-1) == {Groundtype::GP_OUTOFSCREEN} then
                    //Sound::PingusSound::play_sound("die");
                    me.status = {Pingu::PS_DEAD};
    // TODO: copied from walker.ceu
                    me.set_x(me.get_x() + (float)(this.direction));
                    escape {Pingu::PS_DEAD};
                end

                if this.rel_getpixel(0,-1) == {Groundtype::GP_WATER} or
                   this.rel_getpixel(0,-1) == {Groundtype::GP_LAVA}
                then
                    emit e_set_action => {ActionName::DROWN};
                    break;  // no more checks, will die
                end


                // if it has hit the ground too quickly
                if this.rel_getpixel(0,-1) != {Groundtype::GP_NOTHING} and
                        this.velocity.y > _deadly_velocity
                then
                    emit e_set_action => {ActionName::SPLASHED};
                    break;  // no more checks, will die
                end
            end
            await FOREVER;
        with
            loop do
                var _Pingu&& ptr;
                var bool&&?  ret_val;
                #define RET_VAL(v) if ret_val? then *ret_val! = v; end
                var _ActionName__Enum new_action;
                new_action = await this.go_action;
// TODO: ret_val
                RET_VAL(false);

                if me.status == {Pingu::PS_DEAD} then
                    _log_debug("Setting action to a dead pingu");
                    _assert(not "DEAD PINGU");
                end

                var int mode = {ActionName::ACTIVATION_MODE}[new_action];

                if mode == {ActionType::INSTANT} then
                    if new_action == me.current_action then
                        _log_debug("Pingu: Already have action");
                        RET_VAL(false);
                    else/if {ActionName::CHANGE_ALLOWED}
                                [me.current_action][new_action]
                    then
                        _log_debug("setting instant action");
                        RET_VAL(true);
                        emit e_set_action => new_action;
                    else
                        _log_debug("change from action %1% not allowed",
                                   me.current_action);
                        RET_VAL(false);
                    end
                else/if mode == {ActionType::WALL_TRIGGERED} then
                    if this.wall_action == new_action then
                        _log_debug("Not using wall action, we have already");
                        RET_VAL(false);
                    else
                        _log_debug("Setting wall action");
                        this.wall_action = new_action;
                        RET_VAL(true);
                    end
                else/if mode == {ActionType::FALL_TRIGGERED} then
                    if this.fall_action == new_action then
                        _log_debug("Not using fall action, we have already");
                        RET_VAL(false);
                    else
                        _log_debug("Setting fall action");
                        this.fall_action = new_action;
                        RET_VAL(true);
                    end
                else/if mode == {ActionType::COUNTDOWN_TRIGGERED} then
                    _assert(not "DEAD CODE???");
                else
                    _log_debug("unknown action activation_mode");
                    RET_VAL(false);
                    _assert(0);
                end
            end
        with
            loop do
                par/or do
                    me.current_action = await e_set_action;
                with
                    #define DO_PINGU_ACTION(T)                          \
                    do                                                  \
                        var int a = do T with                           \
                            this.pingu = &outer;                        \
                            this.previous_action = me.current_action;   \
                        end;                                            \
                        escape (_ActionName__Enum)a;                    \
                    end
                    if me.current_action == {ActionName::NONE} then
                        await FOREVER;
                    else/if me.current_action == {ActionName::DEAD} then
                        me.status = {Pingu::PS_DEAD};
                        escape {Pingu::PS_DEAD};
                    else/if me.current_action == {ActionName::BASHER} then
                        me.current_action = DO_PINGU_ACTION(Basher);
                    else/if me.current_action == {ActionName::BLOCKER} then
                        me.current_action = DO_PINGU_ACTION(Blocker);
                    else/if me.current_action == {ActionName::BOMBER} then
                        me.current_action = DO_PINGU_ACTION(Bomber);
                    else/if me.current_action == {ActionName::BRIDGER} then
                        me.current_action = DO_PINGU_ACTION(Bridger);
                    else/if me.current_action == {ActionName::DIGGER} then
                        me.current_action = DO_PINGU_ACTION(Digger);
                    else/if me.current_action == {ActionName::DROWN} then
                        me.current_action = DO_PINGU_ACTION(Drown);
                    else/if me.current_action == {ActionName::EXITER} then
                        me.current_action = DO_PINGU_ACTION(Exiter);
                        me.status = {Pingu::PS_EXITED};
                        escape {Pingu::PS_EXITED};
                    else/if me.current_action == {ActionName::FALLER} then
                        me.current_action = DO_PINGU_ACTION(Faller);
                    else/if me.current_action == {ActionName::FLOATER} then
                        me.current_action = DO_PINGU_ACTION(Floater);
                    else/if me.current_action == {ActionName::JUMPER} then
                        me.current_action = DO_PINGU_ACTION(Jumper);
                    else/if me.current_action == {ActionName::MINER} then
                        me.current_action = DO_PINGU_ACTION(Miner);
                    else/if me.current_action == {ActionName::SPLASHED} then
                        me.current_action = DO_PINGU_ACTION(Splashed);
                    else/if me.current_action == {ActionName::WAITER} then
                        me.current_action = DO_PINGU_ACTION(Waiter);
                    else/if me.current_action == {ActionName::WALKER} then
                        me.current_action = DO_PINGU_ACTION(Walker);
                    else
_printf("ACTION_NAME = %d\n", me.current_action);
                        _assert({!"Invalid action name provied"});
                        await FOREVER;
                    end
                end
            end
        end
    end;

    if ret == {Pingu::PS_DEAD} then
        this.holder.number_of_killed = this.holder.number_of_killed + 1;
    else/if ret == {Pingu::PS_EXITED} then
        this.holder.number_of_exited = this.holder.number_of_exited + 1;
    else
        _assert(ret == {Pingu::PS_NONE});
    end
    _assert(this.holder.number_of_released == this.holder.number_of_alive-1 +
                                              this.holder.number_of_killed  +
                                              this.holder.number_of_exited);

    function (void)=>Vector3f get_pos do
        var Vector3f ret = Vector3f(this.me.pos_x, this.me.pos_y, 0);
        return ret;
    end
    function (void)=>Vector3f get_center_pos do
        var Vector3f ret = Vector3f(this.me.pos_x, this.me.pos_y-16, 0);
        return ret;
    end


    /* PUBLIC */

    function (void)=>Vector3f get_velocity do
        return this.velocity;
    end

    function (Vector3f velocity_)=>void set_velocity do
        this.velocity = velocity_;

        // crude terminal velocity
        this.velocity.x =
            (float){Math::clamp}(-_terminal_velocity, this.velocity.x, _terminal_velocity);
        this.velocity.y =
            (float){Math::clamp}(-_terminal_velocity, this.velocity.y, _terminal_velocity);
    end

    function (void)=>_std__string get_owner_str do
        {
            std::ostringstream ostr;
            ostr << THIS_F(CEU_Pingu)->me->owner_id;
        };
        return _ostr.str();
    end

    function (s8 d)=>void set_direction do
        this.direction = d;
    end

    function (void)=>void change_direction do
        if this.direction == _LEFT then
            this.direction = _RIGHT;
        else
            this.direction = _LEFT;
        end
    end

    function (int x, int y)=>int rel_getpixel do
        return {WorldObj::get_world()->get_colmap()->getpixel}(
                (int)(this.me.pos_x + (float)(x * this.direction)),
                (int)(this.me.pos_y - (float)(y)));
    end

    function (int x, int y)=>bool head_collision_on_walk do
        var int pixel = this.rel_getpixel(x, y + _pingu_height);
        if (     pixel != {Groundtype::GP_NOTHING} and
            not (pixel &  {Groundtype::GP_BRIDGE}))
        then
            return true;
        else
            return false;
        end
    end

    // Returns true if the given koordinates are above the pingu
    function (int x, int y)=>bool is_over do
        var Vector3f center = this.get_center_pos();
        return (center.x+16 > x and
                center.x-16 < x and
                center.y+16 > y and
                center.y-16 < y);
    end

#if 0
    bool
    Pingu::is_inside (int x1, int y1, int x2, int y2)
    {
        assert (x1 < x2);
        assert (y1 < y2);

        return (pos_x > x1 && pos_x < x2
              &&
              pos_y > y1 && pos_y < y2);
    }

    void
    Pingu::apply_force (Vector3f arg_v)
    {
      velocity += arg_v;
      // Moving the pingu on pixel up, so that the force can take effect
      // FIXME: this should be handled by a state-machine
      --pos_y;
    }
#endif
end

#endif
