#ifndef _PINGU_CEU
#define _PINGU_CEU

native do
    ##include "../src/engine/display/scene_context.hpp"
    ##define GC_COLOR_DRAW(gc,x,y) gc->color().draw(x,y)
end
native @nohold _GC_COLOR_DRAW();

input (_Pingu&&, bool&&, _ActionName__Enum) PINGU_REQUEST_SET_ACTION;
input (_Pingu&&, _ActionName__Enum)         PINGU_SET_ACTION;

native/pre do
    ##include "../src/pingus/pingu_holder.hpp"
    ##include "../src/pingus/world.hpp"
    ##include "../src/pingus/pingu.hpp"
    ##include "../src/pingus/action_name.hpp"
end

#include "../engine/display/sprite_pingu.ceu"
#include "actions/basher.ceu"
#include "actions/blocker.ceu"
#include "actions/bomber.ceu"
#include "actions/bridger.ceu"
#include "actions/digger.ceu"
#include "actions/drown.ceu"
#include "actions/exiter.ceu"
#include "actions/faller.ceu"
#include "actions/floater.ceu"
#include "actions/jumper.ceu"
#include "actions/miner.ceu"
#include "actions/splashed.ceu"
#include "actions/waiter.ceu"
#include "actions/walker.ceu"

native/pre do
    ##define ActionName__Enum ActionName::Enum
    ##define Pingu__PinguStatus Pingu::PinguStatus
    ##define PinguAction_shared_ptr std::shared_ptr<PinguAction>
end
native @plain _Pingu, _ActionName__Enum, _Pingu__PinguStatus;

class Pingu with
    interface IPingu;

    var _ActionName__Enum wall_action = {ActionName::NONE};
    var _ActionName__Enum fall_action = {ActionName::NONE};
do
    var Vector3f velocity = Vector3f(0, 0, 0);
    this.me.ceu = &&this;

    this.holder.number_of_released = this.holder.number_of_released + 1;
    this.holder.number_of_alive    = this.holder.number_of_alive    + 1;
    finalize with
        this.holder.number_of_alive = this.holder.number_of_alive - 1;
    end

    me.current_action = {ActionName::FALLER};

    var _Pingu__PinguStatus ret =
    do
        event _ActionName__Enum e_set_action;
        par do
            loop do
                await WORLD_UPDATE;

                // FIXME: Out of screen check is ugly
                /* The Pingu has hit the edge of the screen, a good time to let
                   him die.
                 */
                if me.rel_getpixel(0,-1) == {Groundtype::GP_OUTOFSCREEN} then
                    //Sound::PingusSound::play_sound("die");
                    me.status = {Pingu::PS_DEAD};
    // TODO: copied from walker.ceu
                    me.set_x(me.get_x() + (float)(me.direction));
                    escape {Pingu::PS_DEAD};
                end

                if me.rel_getpixel(0,-1) == {Groundtype::GP_WATER} or
                   me.rel_getpixel(0,-1) == {Groundtype::GP_LAVA}
                then
                    emit e_set_action => {ActionName::DROWN};
                    break;  // no more checks, will die
                end


                // if it has hit the ground too quickly
                if me.rel_getpixel(0,-1) != {Groundtype::GP_NOTHING} and
                        this.velocity.y > _deadly_velocity
                then
                    emit e_set_action => {ActionName::SPLASHED};
                    break;  // no more checks, will die
                end
            end
            await FOREVER;
        with
            loop do
                var _Pingu&& ptr;
                var bool&&?  ret_val;
                #define RET_VAL(v) if ret_val? then *ret_val! = v; end
                var _ActionName__Enum new_action;
                par/or do
                    var bool&& ret_val_;
                    (ptr, ret_val_, new_action) = await PINGU_REQUEST_SET_ACTION
                                                  until ptr == &&this.me;
                    ret_val := ret_val_;
                with
                    new_action = await this.go_action;
                end
                RET_VAL(false);

                if me.status == {Pingu::PS_DEAD} then
                    _log_debug("Setting action to a dead pingu");
                    _assert(not "DEAD PINGU");
                end

                var int mode = {ActionName::ACTIVATION_MODE}[new_action];

                if mode == {ActionType::INSTANT} then
                    if new_action == me.current_action then
                        _log_debug("Pingu: Already have action");
                        RET_VAL(false);
                    else/if {ActionName::CHANGE_ALLOWED}
                                [me.current_action][new_action]
                    then
                        _log_debug("setting instant action");
                        RET_VAL(true);
                        emit e_set_action => new_action;
                    else
                        _log_debug("change from action %1% not allowed",
                                   me.current_action);
                        RET_VAL(false);
                    end
                else/if mode == {ActionType::WALL_TRIGGERED} then
                    if this.wall_action == new_action then
                        _log_debug("Not using wall action, we have already");
                        RET_VAL(false);
                    else
                        _log_debug("Setting wall action");
                        this.wall_action = new_action;
                        RET_VAL(true);
                    end
                else/if mode == {ActionType::FALL_TRIGGERED} then
                    if this.fall_action == new_action then
                        _log_debug("Not using fall action, we have already");
                        RET_VAL(false);
                    else
                        _log_debug("Setting fall action");
                        this.fall_action = new_action;
                        RET_VAL(true);
                    end
                else/if mode == {ActionType::COUNTDOWN_TRIGGERED} then
                    _assert(not "DEAD CODE???");
                else
                    _log_debug("unknown action activation_mode");
                    RET_VAL(false);
                    _assert(0);
                end
            end
        with
            loop do
                par/or do
                    me.current_action = await e_set_action;
                with
                    #define DO_PINGU_ACTION(T)                          \
                    do                                                  \
                        var int a = do T with                           \
                            this.pingu = &outer;                        \
                            this.previous_action = me.current_action;   \
                        end;                                            \
                        escape (_ActionName__Enum)a;                    \
                    end
                    if me.current_action == {ActionName::NONE} then
                        await FOREVER;
                    else/if me.current_action == {ActionName::DEAD} then
                        me.status = {Pingu::PS_DEAD};
                        escape {Pingu::PS_DEAD};
                    else/if me.current_action == {ActionName::BASHER} then
                        me.current_action = DO_PINGU_ACTION(Basher);
                    else/if me.current_action == {ActionName::BLOCKER} then
                        me.current_action = DO_PINGU_ACTION(Blocker);
                    else/if me.current_action == {ActionName::BOMBER} then
                        me.current_action = DO_PINGU_ACTION(Bomber);
                    else/if me.current_action == {ActionName::BRIDGER} then
                        me.current_action = DO_PINGU_ACTION(Bridger);
                    else/if me.current_action == {ActionName::DIGGER} then
                        me.current_action = DO_PINGU_ACTION(Digger);
                    else/if me.current_action == {ActionName::DROWN} then
                        me.current_action = DO_PINGU_ACTION(Drown);
                    else/if me.current_action == {ActionName::EXITER} then
                        me.current_action = DO_PINGU_ACTION(Exiter);
                        me.status = {Pingu::PS_EXITED};
                        escape {Pingu::PS_EXITED};
                    else/if me.current_action == {ActionName::FALLER} then
                        me.current_action = DO_PINGU_ACTION(Faller);
                    else/if me.current_action == {ActionName::FLOATER} then
                        me.current_action = DO_PINGU_ACTION(Floater);
                    else/if me.current_action == {ActionName::JUMPER} then
                        me.current_action = DO_PINGU_ACTION(Jumper);
                    else/if me.current_action == {ActionName::MINER} then
                        me.current_action = DO_PINGU_ACTION(Miner);
                    else/if me.current_action == {ActionName::SPLASHED} then
                        me.current_action = DO_PINGU_ACTION(Splashed);
                    else/if me.current_action == {ActionName::WAITER} then
                        me.current_action = DO_PINGU_ACTION(Waiter);
                    else/if me.current_action == {ActionName::WALKER} then
                        me.current_action = DO_PINGU_ACTION(Walker);
                    else
_printf("ACTION_NAME = %d\n", me.current_action);
                        _assert({!"Invalid action name provied"});
                        await FOREVER;
                    end
                end
            end
        end
    end;

    if ret == {Pingu::PS_DEAD} then
        this.holder.number_of_killed = this.holder.number_of_killed + 1;
    else/if ret == {Pingu::PS_EXITED} then
        this.holder.number_of_exited = this.holder.number_of_exited + 1;
    else
        _assert(ret == {Pingu::PS_NONE});
    end
    _assert(this.holder.number_of_released == this.holder.number_of_alive-1 +
                                              this.holder.number_of_killed  +
                                              this.holder.number_of_exited);


    /* PUBLIC */

    function (void)=>Vector3f get_velocity do
        return this.velocity;
    end

    function (Vector3f velocity_)=>void set_velocity do
        this.velocity = velocity_;

        // crude terminal velocity
        this.velocity.x =
            (float){Math::clamp}(-_terminal_velocity, this.velocity.x, _terminal_velocity);
        this.velocity.y =
            (float){Math::clamp}(-_terminal_velocity, this.velocity.y, _terminal_velocity);
    end

    function (void)=>_std__string get_owner_str do
        {
            std::ostringstream ostr;
            ostr << THIS_F(CEU_Pingu)->me->owner_id;
        };
        return _ostr.str();
    end

#if 0
    void
    Pingu::apply_force (Vector3f arg_v)
    {
      velocity += arg_v;
      // Moving the pingu on pixel up, so that the force can take effect
      // FIXME: this should be handled by a state-machine
      --pos_y;
    }
#endif
end

#endif
