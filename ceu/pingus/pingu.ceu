#ifndef _PINGU_CEU
#define _PINGU_CEU

native do
    ##include "../src/engine/display/scene_context.hpp"
    ##define GC_COLOR_DRAW(gc,x,y) gc->color().draw(x,y)
end
native @nohold _GC_COLOR_DRAW();

input (_Pingu&&) PINGU_NEW;
input (_Pingu&&) PINGU_DELETE;
input (_Pingu&&) PINGU_UPDATE;
input (_Pingu&&, _SceneContext&&) PINGU_DRAW;

input (_Pingu&&, bool&&, _ActionName__Enum) PINGU_REQUEST_SET_ACTION;
input (_Pingu&&, _ActionName__Enum)         PINGU_SET_ACTION;

interface IPingu with
    var _Pingu& me;
end

#include "pingu_action.ceu"

native/pre do
    ##include "../src/pingus/pingu_holder.hpp"
    ##include "../src/pingus/world.hpp"
    ##include "../src/pingus/pingu.hpp"
    ##include "../src/pingus/pingu_action.hpp"
end

#include "actions/basher.ceu"
#include "actions/blocker.ceu"
#include "actions/bomber.ceu"
#include "actions/bridger.ceu"
#include "actions/digger.ceu"
#include "actions/drown.ceu"
#include "actions/exiter.ceu"
#include "actions/faller.ceu"
#include "actions/floater.ceu"
#include "actions/jumper.ceu"
#include "actions/miner.ceu"
#include "actions/splashed.ceu"
#include "actions/waiter.ceu"
#include "actions/walker.ceu"

native/pre do
    ##define ActionName__Enum ActionName::Enum
    ##define PinguAction_shared_ptr std::shared_ptr<PinguAction>
end
native @plain _Pingu, _ActionName__Enum;

class Pingu with
    interface IPingu;
do
    me.current_action = {ActionName::FALLER};

    event _ActionName__Enum e_set_action;
    par/or do
        AWAIT_UNTIL_MYSELF(_Pingu,PINGU_DELETE);
    with
        loop do
            AWAIT_UNTIL_MYSELF(_Pingu,PINGU_UPDATE);

            /// TODO(control)
            // FIXME: Out of screen check is ugly
            /* The Pingu has hit the edge of the screen, a good time to let
               him die.
             */
            if me.rel_getpixel(0,-1) == {Groundtype::GP_OUTOFSCREEN} then
                //Sound::PingusSound::play_sound("die");
                me.status = {Pingu::PS_DEAD};
            end
            if me.status == {Pingu::PS_DEAD} then
                break;
            end

            // if an countdown action is set, update the countdown time
            if me.action_time > -1 then
                me.action_time = me.action_time - 1;
            end
            if me.action_time==0 and (me.countdown_action!={ActionName::NONE}) then
                // Reset the countdown action handlers
                me.countdown_action = {ActionName::NONE};
                me.set_action(me.countdown_action);
                me.action_time = -1;
                break;
            end

            me.action:update();
        end
        await FOREVER;
    with
        loop do
            var _Pingu&& ptr;
            var bool&&   ret_val;
            var _ActionName__Enum action_name;
            (ptr, ret_val, action_name) = await PINGU_REQUEST_SET_ACTION
                                          until ptr == &&this.me;
            *ret_val = false;

            if me.status == {Pingu::PS_DEAD} then
                _log_debug("Setting action to a dead pingu");
                continue;
            end

            var int mode = {PinguAction::get_activation_mode}(action_name);

            if mode == {ActionType::INSTANT} then
                if action_name == me.action:get_type() then
                    _log_debug("Pingu: Already have action");
                    *ret_val = false;
                else/if {ActionName::CHANGE_ALLOWED}
                            [me.current_action][action_name]
                then
                    _log_debug("setting instant action");
                    *ret_val = true;
                    emit e_set_action => action_name;
                else
                    _log_debug("change from action %1% not allowed",
                               me.action:get_name());
                    *ret_val = false;
                end
            else/if mode == {ActionType::WALL_TRIGGERED} then
                if me.wall_action == action_name then
                    _log_debug("Not using wall action, we have already");
                    *ret_val = false;
                else
                    _log_debug("Setting wall action");
                    me.wall_action = action_name;
                    *ret_val = true;
                end
            else/if mode == {ActionType::FALL_TRIGGERED} then
                if me.fall_action == action_name then
                    _log_debug("Not using fall action, we have already");
                    *ret_val = false;
                else
                    _log_debug("Setting fall action");
                    me.fall_action = action_name;
                    *ret_val = true;
                end
            else/if mode == {ActionType::COUNTDOWN_TRIGGERED} then
                if me.countdown_action == action_name then
                    _log_debug("Not using countdown action, we have already");
                    *ret_val = false;
                else
                    _log_debug("Setting countdown action");
                    // We set the action and start the countdown
                    ///std::shared_ptr<PinguAction> act = me.create_action(action_name);
                    me.action_time = -1;///me.act:activation_time();
                    me.countdown_action = action_name;
                    *ret_val = true;
                end
            else
                _log_debug("unknown action activation_mode");
                *ret_val = false;
                _assert(0);
            end
        end
    with
        every (ptr,action) in PINGU_SET_ACTION do
            if ptr == &&this.me then
                emit e_set_action => action;
            end
        end
    with
        loop do
            par/or do
                me.current_action = await e_set_action;
            with
                #define DO_PINGU_ACTION(T)                          \
                do                                                  \
                    var _PinguAction&& ptr = _XXX_PURE(             \
                            {new PinguAction}(&&this.me,me.current_action) \
                                finalize with nothing; end);        \
                    me.action.reset(ptr)                            \
                        finalize with nothing; end;                 \
                    var int a = do T with                           \
                        this.me    = &_XXX_PTR2REF(ptr);            \
                        this.pingu = &outer;                        \
                    end;                                            \
                    escape (_ActionName__Enum)a;                    \
                end
                if me.current_action == {ActionName::NONE} then
                    await FOREVER;
                else/if me.current_action == {ActionName::DEAD} then
                    me.set_status({Pingu::PS_DEAD});
                    break;
                    ///escape {Pingu:PS_DEAD};
                else/if me.current_action == {ActionName::BASHER} then
                    me.current_action = DO_PINGU_ACTION(Basher);
                else/if me.current_action == {ActionName::BLOCKER} then
                    me.current_action = DO_PINGU_ACTION(Blocker);
                else/if me.current_action == {ActionName::BOMBER} then
                    me.current_action = DO_PINGU_ACTION(Bomber);
                else/if me.current_action == {ActionName::BRIDGER} then
                    me.current_action = DO_PINGU_ACTION(Bridger);
                else/if me.current_action == {ActionName::DIGGER} then
                    me.current_action = DO_PINGU_ACTION(Digger);
                else/if me.current_action == {ActionName::DROWN} then
                    me.current_action = DO_PINGU_ACTION(Drown);
                else/if me.current_action == {ActionName::EXITER} then
                    me.current_action = DO_PINGU_ACTION(Exiter);
                    me.set_status({Pingu::PS_EXITED});
                    break;
                    ///escape {Pingu:PS_EXITED};
                else/if me.current_action == {ActionName::FALLER} then
                    me.current_action = DO_PINGU_ACTION(Faller);
                else/if me.current_action == {ActionName::FLOATER} then
                    me.current_action = DO_PINGU_ACTION(Floater);
                else/if me.current_action == {ActionName::JUMPER} then
                    me.current_action = DO_PINGU_ACTION(Jumper);
                else/if me.current_action == {ActionName::MINER} then
                    me.current_action = DO_PINGU_ACTION(Miner);
                else/if me.current_action == {ActionName::SPLASHED} then
                    me.current_action = DO_PINGU_ACTION(Splashed);
                else/if me.current_action == {ActionName::WAITER} then
                    me.current_action = DO_PINGU_ACTION(Waiter);
                else/if me.current_action == {ActionName::WALKER} then
                    me.current_action = DO_PINGU_ACTION(Walker);
                else
_printf("ACTION_NAME = %d\n", me.current_action);
                    _assert({!"Invalid action name provied"});
                    await FOREVER;
                end
            end
        end
    end
end

class PinguFactory with
do
    every me_ in PINGU_NEW do
        spawn Pingu with
            this.me = &_XXX_PTR2REF(me_);
        end;
    end
end

var PinguFactory _;

#endif
