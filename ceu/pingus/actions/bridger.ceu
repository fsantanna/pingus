#ifndef _BRIDGER_CEU
#define _BRIDGER_CEU

native do
    ##include "../../src/math/vector3f.hpp"
    ##include "../../src/util/string_util.hpp"
    ##include "../../src/pingus/gettext.h"
end

#include "../pingu_action.ceu"
#include "../right_left_sprites_.ceu"

native do
    enum { BRIDGER_WALKING, BRIDGER_BUILDING };
    enum { BRIDGER_MAX_BRICKS = 15 };
    enum { BRIDGER_brick_length = 16 };
end

class Bridger with
    interface IPinguAction;
do
    function (void)=>bool way_is_free;
    function (void)=>bool brick_placement_allowed;
    function (void)=>void place_a_brick;
    function (void)=>void walk_one_step_up;

    var int bricks = _BRIDGER_MAX_BRICKS;

    this.me.name = {_("Bridger") + std::string(" (" +
                    StringUtil::to_string(THIS(CEU_Bridger)->bricks) + ")")};

    var char[] left1  = [] .. "pingus/player"
                           .. (char&&)*this.pingu.me.get_owner_str().c_str()
                           .. "/bridger_walk/left";
    var char[] right1 = [] .. "pingus/player"
                           .. (char&&)*this.pingu.me.get_owner_str().c_str()
                           .. "/bridger_walk/right";
    var RightLeftSprites_ walks with
        this.left  = &left1;
        this.right = &right1;
    end;

    var char[] left2  = [] .. "pingus/player"
                           .. (char&&)*this.pingu.me.get_owner_str().c_str()
                           .. "/bridger/left";
    var char[] right2 = [] .. "pingus/player"
                           .. (char&&)*this.pingu.me.get_owner_str().c_str()
                           .. "/bridger/right";
    var RightLeftSprites_ builds with
        this.left  = &left2;
        this.right = &right2;
    end;

    var int mode; // building
    par do
        /* UPDATE */
        loop i in _BRIDGER_MAX_BRICKS do

            // BUILDING: initial mode
            mode = _BRIDGER_BUILDING;
            par/or do
                every PINGUHOLDER_UPDATE do
                    builds.get(this.pingu.me.direction).me.update();
                end
            with
                AWAIT_UNTIL_PINGU_FRAME(builds.get(this.pingu.me.direction).me, 7);
                if this.brick_placement_allowed() then
                    this.place_a_brick(); // me.bricks--;
                else
                    this.pingu.me.direction.change();
                    escape {ActionName::WALKER};
                end
                await PINGUHOLDER_UPDATE
                until builds.get(this.pingu.me.direction).me.is_finished();
            end
            builds.get(this.pingu.me.direction).me.restart();

            // SKIP the last WALKING
            if i == _BRIDGER_MAX_BRICKS-1 then
                escape {ActionName::WAITER};
            end

            // WALKING
            mode = _BRIDGER_WALKING;
            loop do
                await PINGUHOLDER_UPDATE;

                // FIXME: Dangerous! might not be fixed timing
                if walks.get(this.pingu.me.direction).me.is_finished() then
                    if this.way_is_free() then
                        break;
                    else // We reached a wall...
                        this.pingu.me.direction.change();
                        escape {ActionName::WALKER};
                    end
                else
                    walks.get(this.pingu.me.direction).me.update();
                end
            end
            walks.get(this.pingu.me.direction).me.restart();
            this.walk_one_step_up();
        end
    with
        /* DRAW */
        every gc in PINGUHOLDER_DRAW_OTHERS do
            var int x_offset = 6;
            var int y_offset = 4;
            if      (bricks == _BRIDGER_MAX_BRICKS  ) then
                x_offset = -4;
                y_offset = 0;
            else/if (bricks == _BRIDGER_MAX_BRICKS-1) then
                x_offset = 0;
                y_offset = 1;
            else/if (bricks == _BRIDGER_MAX_BRICKS-2) then
                x_offset = 3;
                y_offset = 2;
            end

            if mode == _BRIDGER_BUILDING then
                _GC_COLOR_DRAW(
                    gc,
                    builds.get(this.pingu.me.direction).me,
                    _Vector3f(this.pingu.me.get_pos().x -
                                (float)(x_offset * this.pingu.me.direction),
                                this.pingu.me.get_pos().y + (float)(y_offset))
                );
            else // _BRIDGER_WALKING
                _GC_COLOR_DRAW(
                    gc,
                    walks.get(this.pingu.me.direction).me,
                    _Vector3f(this.pingu.me.get_pos().x -
                                (float)(x_offset * this.pingu.me.direction),
                                this.pingu.me.get_pos().y + (float)(y_offset))
                );
            end
        end
    end

    /* PRIVATE */

    // way_is_free() needs to stop BRIDGERS from getting stuck between a brick
    // and the ceiling.  The routine also stops cases of Bridgers building up but
    // then not being able to walk all the way down the bridge the it has built.
    // Even though the routine may be the same as brick_placement_allowed(), it is
    // best to keep them apart as they may need to be independent of each other if
    // there needs to be a patch.
    function (void)=>bool way_is_free do
        var bool way_free = true;
        loop i in 4 do
            var int x_inc = i+1;
            if me.rel_getpixel(x_inc, 2) != {Groundtype::GP_NOTHING}
            or me.head_collision_on_walk(x_inc, 2)
            then
                way_free = false;
                break;
            end
        end
        return way_free;
    end

    // brick_placement_allowed() is mainly for stopping WALKERS from getting 
    // stuck
    // between a brick and the ceiling.  Even though the routine may be the same,
    // as way_is_free() it is best to keep them apart as they may need to be
    // independent of each other if there needs to be a patch.
    function (void)=>bool brick_placement_allowed do
        return not me.head_collision_on_walk(0, 2);
    end

    function (void)=>void place_a_brick do
        this.bricks = this.bricks - 1;
        this.me.name = { _("Bridger") + std::string(" (") +
                 StringUtil::to_string(THIS_F(CEU_Bridger)->bricks) + ")" };
        if this.bricks < 4 then
            { Sound::PingusSound::play_sound("ting"); };
        end

        {
            static CollisionMask brick_l("other/brick_left");
            static CollisionMask brick_r("other/brick_right");
        };

        if this.pingu.me.direction.is_right() then
            call {WorldObj::get_world()->put}(
                    _brick_r,
                    (int)(this.pingu.me.get_pos().x + 10.0 - (float)(_brick_r.get_width())),
                    (int)(this.pingu.me.get_pos().y),
                    {Groundtype::GP_BRIDGE}
            );
        else
            call {WorldObj::get_world()->put}(
                    _brick_l,
                    (int)(this.pingu.me.get_pos().x - 10.0),
                    (int)(this.pingu.me.get_pos().y),
                    {Groundtype::GP_BRIDGE}
            );
        end
    end

    function (void)=>void walk_one_step_up do
        this.pingu.me.set_pos(
            this.pingu.me.get_pos().x + (4.0*(float)(this.pingu.me.direction)),
            this.pingu.me.get_pos().y - 2
        );
    end
end

#endif
