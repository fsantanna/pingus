#ifndef _BRIDGER_CEU
#define _BRIDGER_CEU

native do
    ##include "../../src/math/vector3f.hpp"
    ##include "../../src/util/string_util.hpp"
    ##include "../../src/pingus/gettext.h"
end

#include "../pingu_action.ceu"
#include "../right_left_sprites_.ceu"

native do
    enum { BRIDGER_WALKING, BRIDGER_BUILDING };
    enum { BRIDGER_MAX_BRICKS = 15 };
    enum { BRIDGER_brick_length = 16 };
end

class Bridger with
    interface IPinguAction;
do
    function (void)=>bool way_is_free;
    function (void)=>bool brick_placement_allowed;
    function (void)=>void place_a_brick;
    function (void)=>void walk_one_step_up;

    this.me.name = {_("Bridger") + std::string(" (" +
                    StringUtil::to_string(THIS(CEU_Bridger)->bricks) + ")")};

    var int bricks = _BRIDGER_MAX_BRICKS;

    /* UPDATE */
    loop i in _BRIDGER_MAX_BRICKS do

        // BUILDING
        do
            var char[] left  = [] .. "pingus/player"
                                  ..  (char&&)*this.pingu.me.get_owner_str().c_str()
                                  .. "/bridger/left";
            var char[] right = [] .. "pingus/player"
                                  ..  (char&&)*this.pingu.me.get_owner_str().c_str()
                                  .. "/bridger/right";
            var RightLeftSprites builds with
                this.pingu = &outer.pingu;
                this.left  = &left;
                this.right = &right;
            end;

            AWAIT_UNTIL_PINGU_FRAME((*builds.get()), 7);
            if this.brick_placement_allowed() then
                this.place_a_brick(); // me.bricks--;
            else
                this.pingu.me.direction.change();
                escape {ActionName::WALKER};
            end
            await builds;
        end

        // SKIP the last WALKING
        if i == _BRIDGER_MAX_BRICKS-1 then
            escape {ActionName::WAITER};
        end

        // WALKING
        do
            var char[] left  = [] .. "pingus/player"
                                  .. (char&&)*this.pingu.me.get_owner_str().c_str()
                                  .. "/bridger_walk/left";
            var char[] right = [] .. "pingus/player"
                                  .. (char&&)*this.pingu.me.get_owner_str().c_str()
                                  .. "/bridger_walk/right";
            do RightLeftSprites with
                this.pingu = &outer.pingu;
                this.left  = &left;
                this.right = &right;
            end;

            // FIXME: Dangerous! might not be fixed timing
            if not this.way_is_free() then
                // We reached a wall...
                this.pingu.me.direction.change();
                escape {ActionName::WALKER};
            end
            this.walk_one_step_up();
        end
    end
    _assert(0);
    escape {ActionName::WALKER};

#if 0
        /* DRAW */
        every gc in PINGUHOLDER_DRAW do
            var int x_offset = 6;
            var int y_offset = 4;
            if      (bricks == _BRIDGER_MAX_BRICKS  ) then
                x_offset = -4;
                y_offset = 0;
            else/if (bricks == _BRIDGER_MAX_BRICKS-1) then
                x_offset = 0;
                y_offset = 1;
            else/if (bricks == _BRIDGER_MAX_BRICKS-2) then
                x_offset = 3;
                y_offset = 2;
            end

            if mode == _BRIDGER_BUILDING then
                _GC_COLOR_DRAW(
                    gc,
                    builds.get(this.pingu.me.direction).me,
                    _Vector3f(this.pingu.me.get_pos().x -
                                (float)(x_offset * this.pingu.me.direction),
                                this.pingu.me.get_pos().y + (float)(y_offset))
                );
            else // _BRIDGER_WALKING
                _GC_COLOR_DRAW(
                    gc,
                    walks.get(this.pingu.me.direction).me,
                    _Vector3f(this.pingu.me.get_pos().x -
                                (float)(x_offset * this.pingu.me.direction),
                                this.pingu.me.get_pos().y + (float)(y_offset))
                );
            end
        end
#endif

    /* PRIVATE */

    // way_is_free() needs to stop BRIDGERS from getting stuck between a brick
    // and the ceiling.  The routine also stops cases of Bridgers building up but
    // then not being able to walk all the way down the bridge the it has built.
    // Even though the routine may be the same as brick_placement_allowed(), it is
    // best to keep them apart as they may need to be independent of each other if
    // there needs to be a patch.
    function (void)=>bool way_is_free do
        var bool way_free = true;
        loop i in 4 do
            var int x_inc = i+1;
            if this.pingu.me.rel_getpixel(x_inc, 2) != {Groundtype::GP_NOTHING}
            or this.pingu.me.head_collision_on_walk(x_inc, 2)
            then
                way_free = false;
                break;
            end
        end
        return way_free;
    end

    // brick_placement_allowed() is mainly for stopping WALKERS from getting 
    // stuck
    // between a brick and the ceiling.  Even though the routine may be the same,
    // as way_is_free() it is best to keep them apart as they may need to be
    // independent of each other if there needs to be a patch.
    function (void)=>bool brick_placement_allowed do
        return not this.pingu.me.head_collision_on_walk(0, 2);
    end

    function (void)=>void place_a_brick do
        this.bricks = this.bricks - 1;
        this.me.name = { _("Bridger") + std::string(" (") +
                 StringUtil::to_string(THIS_F(CEU_Bridger)->bricks) + ")" };
        if this.bricks < 4 then
            { Sound::PingusSound::play_sound("ting"); };
        end

        {
            static CollisionMask brick_l("other/brick_left");
            static CollisionMask brick_r("other/brick_right");
        };

        if this.pingu.me.direction.is_right() then
            call {WorldObj::get_world()->put}(
                    _brick_r,
                    (int)(this.pingu.me.get_pos().x + 10.0 - (float)(_brick_r.get_width())),
                    (int)(this.pingu.me.get_pos().y),
                    {Groundtype::GP_BRIDGE}
            );
        else
            call {WorldObj::get_world()->put}(
                    _brick_l,
                    (int)(this.pingu.me.get_pos().x - 10.0),
                    (int)(this.pingu.me.get_pos().y),
                    {Groundtype::GP_BRIDGE}
            );
        end
    end

    function (void)=>void walk_one_step_up do
        this.pingu.me.set_pos(
            this.pingu.me.get_pos().x + (4.0*(float)(this.pingu.me.direction)),
            this.pingu.me.get_pos().y - 2
        );
    end
end

#endif
