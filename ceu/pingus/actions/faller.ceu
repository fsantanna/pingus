#ifndef _FALLER_CEU
#define _FALLER_CEU

#include "../pingu_action.ceu"
#include "../right_left_sprites.ceu"

class Faller with
    interface IPinguAction;
do
    function (void) => bool is_tumbling;

    var char[] left1  = [] .. "pingus/player"
                           .. (char&&)*this.pingu.me.get_owner_str().c_str()
                           .. "/faller/left";
    var char[] right1 = [] .. "pingus/player"
                           .. (char&&)*this.pingu.me.get_owner_str().c_str()
                           .. "/faller/right";
    var RightLeftSprites_ fallers with
        this.left  = &left1;
        this.right = &right1;
    end;

    var char[] left2  = [] .. "pingus/player"
                           .. (char&&)*this.pingu.me.get_owner_str().c_str()
                           .. "/tumbler/left";
    var char[] right2 = [] .. "pingus/player"
                           .. (char&&)*this.pingu.me.get_owner_str().c_str()
                           .. "/tumbler/right";
    var RightLeftSprites_ tumblers with
        this.left  = &left2;
        this.right = &right2;
    end;

    par do
        /* UPDATE */
        var float countdown = 2.0;
        loop do
            await PINGUHOLDER_UPDATE;

            if this.is_tumbling() then
                tumblers.get(this.pingu.me.direction).me.update();
            else
                fallers.get(this.pingu.me.direction).me.update();
            end

            // FIXME: This should be triggered at a later point, when close to
            // FIXME: deadly_velocity or something like that. A translation
            // FIXME: animation for the floater might also help
            if (me.pingu:get_velocity().y > 5.0) then
                var int fall_action = me.pingu:request_fall_action();
                if fall_action != {ActionName::NONE} then
                    escape fall_action;
                end
            end

            // Apply gravity
            me.pingu:set_velocity(me.pingu:get_velocity() +
                  {Vector3f(0.0f, WorldObj::get_world()->get_gravity())});

            // Move the Pingu as far is it can go
            // XXX_CPP
            {
                Vector3f move =  ME(CEU_Faller)->pingu->get_velocity();
                Movers::LinearMover mover(WorldObj::get_world(),
                                          ME(CEU_Faller)->pingu->get_pos());
                mover.update(move, Colliders::PinguCollider(pingu_height));
            };
            this.pingu.me.set_pos(_mover.get_pos());
            if not _mover.collided() then
                continue;
            end

            // If the Pingu collided with something...

            // XXX_CPP
            {
                static Vector3f velocity = ME(CEU_Faller)->pingu->get_velocity();
            };

            if me.rel_getpixel(0,-1) == {Groundtype::GP_NOTHING} and
               me.rel_getpixel(0,-2) == {Groundtype::GP_NOTHING} and
               me.rel_getpixel(0,-3) == {Groundtype::GP_NOTHING} and
               me.rel_getpixel(1, 0) != {Groundtype::GP_NOTHING} and
               me.rel_getpixel(1, 0) != {Groundtype::GP_BRIDGE}
            then
                // Make Pingu bounce off wall
                _velocity.x = -(_velocity.x / 3.0);

                // Make the Pingu face the correct direction.  NB: Pingu 
                // may previously have been facing in the opposite direction of its
                // velocity because of an explosion.
                if (_velocity.x > 0.0) then
                    me.pingu:direction.right();
                else
                    me.pingu:direction.left();
                end
                me.pingu:set_velocity(_velocity);

            else/if (_velocity.y > 0.0) then
                // If the Pingu collided into something while moving 
                // down...
                if me.rel_getpixel(0,-1) == {Groundtype::GP_WATER} or
                   me.rel_getpixel(0,-1) == {Groundtype::GP_LAVA}
                then
                    // Ping is on ground/water/something
                    escape (int){ActionName::DROWN};
                else/if {Math::abs(((CEU_Faller*)_STK_ORG)->me->pingu->get_velocity().y)} >
                         _deadly_velocity
                then
                    // Did we stop too fast?
                    //log_info("Pingus splashed: " << 
                    //me.pingu:get_velocity().y << " " << deadly_velocity);
                    escape (int){ActionName::SPLASHED};
                else
                    // This is where the jumper bug happens
                    //log_info("Reached the unreachable: " << 
                    //me.pingu:get_velocity().y);
                    if me.pingu:get_previous_action() ==
                       {ActionName::BLOCKER}
                    then
                        escape (int)me.pingu:get_previous_action();
                    else
                        escape (int){ActionName::WALKER};
                    end
                end
                //_assert(0);

            else // if (_velocity.y < 0.0f)
                // If the Pingu collided into something while moving up...
                // Don't make the Pingu go up any further.
                _velocity.y = 0;
                _velocity.x = (_velocity.x / 3.0);
                me.pingu:set_velocity(_velocity);
            end
        end
    with
        /* DRAW */
        every gc in PINGUHOLDER_DRAW_OTHERS do
            if this.is_tumbling() then
                _GC_COLOR_DRAW(gc, tumblers.get(this.pingu.me.direction).me,
                                   this.pingu.me.get_pos());
            else
                _GC_COLOR_DRAW(gc, fallers.get(this.pingu.me.direction).me,
                                   this.pingu.me.get_pos());
            end
        end
    end

    /* PRIVATE */

    function (void) => bool is_tumbling do
        // If we are going fast enough to get smashed, start tumbling
        return {Math::abs}(this.pingu.me.get_velocity().x) > _deadly_velocity
            or {Math::abs}(this.pingu.me.get_velocity().y) > _deadly_velocity;
    end
end

#endif
