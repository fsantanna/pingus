#ifndef _BOMBER_CEU
#define _BOMBER_CEU

native/pre do
    ##include "../src/pingus/colliders/pingu_collider.hpp"
    ##include "../src/pingus/movers/linear_mover.hpp"
    ##include "../src/pingus/particles/pingu_particle_holder.hpp"
    ##include "../src/pingus/pingu_enums.hpp"
    ##include "../src/pingus/pingu.hpp"
    ##include "../src/pingus/pingu_action.hpp"
    ##include "../src/pingus/actions/bomber.hpp"
    ##define Actions__Bomber Actions::Bomber
end
native @plain _Actions__Bomber;

input (_Actions__Bomber&&) BOMBER_UPDATE;

class Bomber with
    var _Actions__Bomber& me;
do
    par do
        loop do
            AWAIT_UNTIL_MYSELF(_Actions__Bomber,BOMBER_UPDATE);
            me.sprite.update();
            // XXX_CPP
            {
                static Movers::LinearMover mover(WorldObj::get_world(),
                                                ((CEU_Bomber*)_STK_ORG)->me->pingu->get_pos());
            };
            _mover.update(me.pingu:get_velocity(),
                          {Colliders::PinguCollider(pingu_height)});
            me.pingu:set_pos(_mover.get_pos());
        end
    with
        // while the Bomber hasn't 'exploded' yet
        par/or do
            loop do
                AWAIT_UNTIL_MYSELF(_Actions__Bomber,BOMBER_UPDATE);

                // if it has hit Water or Lava
                if me.rel_getpixel(0,-1) == {Groundtype::GP_WATER} or
                   me.rel_getpixel(0,-1) == {Groundtype::GP_LAVA}
                then
                    escape {ActionName::DROWN};

                // if it has hit the ground too quickly
                else/if me.rel_getpixel(0,-1) != {Groundtype::GP_NOTHING} and
                        me.pingu:get_velocity().y > _deadly_velocity
                then
                    escape {ActionName::SPLASHED};
                end
            end
        with
            AWAIT_UNTIL_FRAME(_Actions__Bomber, BOMBER_UPDATE, me.sprite, 10);
        end

        // Throwing particles
        {
            WorldObj::get_world()->play_sound("plop",
                ((CEU_Bomber*)_STK_ORG)->me->pingu->get_pos());
        };
        AWAIT_UNTIL_FRAME(_Actions__Bomber, BOMBER_UPDATE, me.sprite, 13);
        {
            WorldObj::get_world()->get_pingu_particle_holder()->
                add_particle((int)(((CEU_Bomber*)_STK_ORG)->me->pingu->get_x()),
                             (int)(((CEU_Bomber*)_STK_ORG)->me->pingu->get_y())-5);
        };
        {
            WorldObj::get_world()->remove(((CEU_Bomber*)_STK_ORG)->me->bomber_radius,
                (int) ((int)(((CEU_Bomber*)_STK_ORG)->me->pingu->get_x()) -
                                (((CEU_Bomber*)_STK_ORG)->me->bomber_radius.get_width()/2)),
                (int) ((int)(((CEU_Bomber*)_STK_ORG)->me->pingu->get_y()) -
                                16 - (((CEU_Bomber*)_STK_ORG)->me->bomber_radius.get_width()/2)));
        };

        // The pingu explode
        loop do
            AWAIT_UNTIL_MYSELF(_Actions__Bomber,BOMBER_UPDATE);
            if me.sprite[me.pingu:direction].is_finished() then
                escape {ActionName::DEAD};
            end
        end
    end
end

#endif
