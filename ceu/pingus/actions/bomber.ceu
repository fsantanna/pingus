#ifndef _BOMBER_CEU
#define _BOMBER_CEU

native/pre do
    ##include "../src/pingus/colliders/pingu_collider.hpp"
    ##include "../src/pingus/movers/linear_mover.hpp"
    ##include "../src/pingus/particles/pingu_particle_holder.hpp"
    ##include "../src/pingus/pingu_enums.hpp"
end

#include "../pingu_action.ceu"
#include "../right_left_sprites.ceu"

class Bomber with
    interface IPinguAction;
do
    var char[] left  = [] .. "pingus/player"
                          .. (char&&)*this.pingu.me.get_owner_str().c_str()
                          .. "/bomber/left";
    var char[] right = [] .. "pingus/player"
                          .. (char&&)*this.pingu.me.get_owner_str().c_str()
                          .. "/bomber/right";
    var RightLeftSprites sprites with
        this.pingu = &outer.pingu;
        this.left  = &left;
        this.right = &right;
    end;

    call {WorldObj::get_world()->play_sound}("ohno", this.pingu.me.get_pos());

    par do
        /* UPDATE */
        every PINGUHOLDER_UPDATE do
            // XXX_CPP
            {
                Movers::LinearMover mover(WorldObj::get_world(),
                                          ((CEU_Bomber*)_STK_ORG)->me->pingu->get_pos());
            };
            _mover.update(me.pingu:get_velocity(),
                          {Colliders::PinguCollider(pingu_height)});
            me.pingu:set_pos(_mover.get_pos());
        end
    with
        /* UPDATE */
        // while the Bomber hasn't 'exploded' yet
        par/or do
            loop do
                await PINGUHOLDER_UPDATE;

                // if it has hit Water or Lava
                if me.rel_getpixel(0,-1) == {Groundtype::GP_WATER} or
                   me.rel_getpixel(0,-1) == {Groundtype::GP_LAVA}
                then
                    escape {ActionName::DROWN};

                // if it has hit the ground too quickly
                else/if me.rel_getpixel(0,-1) != {Groundtype::GP_NOTHING} and
                        me.pingu:get_velocity().y > _deadly_velocity
                then
                    escape {ActionName::SPLASHED};
                end
            end
        with
            AWAIT_UNTIL_PINGU_FRAME((*sprites.get()), 10);
        end

        // Throwing particles
        {
            WorldObj::get_world()->play_sound("plop",
                ((CEU_Bomber*)_STK_ORG)->me->pingu->get_pos());
        };
        AWAIT_UNTIL_PINGU_FRAME((*sprites.get()), 13);
        {
            WorldObj::get_world()->get_pingu_particle_holder()->
                add_particle((int)(((CEU_Bomber*)_STK_ORG)->me->pingu->get_x()),
                             (int)(((CEU_Bomber*)_STK_ORG)->me->pingu->get_y())-5);
        };
        {
            ##include "../../../src/pingus/collision_mask.hpp"
            static CollisionMask bomber_radius(
                    "other/bomber_radius_gfx",
                    "other/bomber_radius"
            );
            WorldObj::get_world()->remove(bomber_radius,
                (int) ((int)(THIS(CEU_Bomber)->me->pingu->get_x()) 
                                - (bomber_radius.get_width()/2)),
                (int) ((int)(THIS(CEU_Bomber)->me->pingu->get_y()) -
                                16 - (bomber_radius.get_width()/2)));
        };

        do
            var char[] str = [] .. "pingus/player"
                                .. (char&&)*this.pingu.me.get_owner_str().c_str()
                                .. "/explo";
            var SpritePingu _ with
                this.pingu = &outer.pingu;
                this.name  = _XXX_PURE(&&str);
            end;
            await PINGUHOLDER_UPDATE;
        end

        // The pingu explode
        loop do
            await PINGUHOLDER_UPDATE;
            if sprites.get():is_finished() then
                escape {ActionName::DEAD};
            end
        end
    end
end

#endif
