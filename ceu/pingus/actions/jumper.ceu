#ifndef _JUMPER_CEU
#define _JUMPER_CEU

native/pre do
    ##include "../src/pingus/pingu.hpp"
    ##include "../src/pingus/pingu_action.hpp"
    ##include "../src/pingus/actions/jumper.hpp"
    ##define Actions__Jumper Actions::Jumper
end
native @plain _Actions__Jumper;

input (_Actions__Jumper&&) JUMPER_NEW;
input (_PinguAction&&)     PINGU_ACTION_DELETE;
input (_Actions__Jumper&&) JUMPER_UPDATE;

class Jumper with
    var _Actions__Jumper& me;
do
    par/or do
        AWAIT_UNTIL_MYSELF(_PinguAction,PINGU_ACTION_DELETE);
    with
        AWAIT_UNTIL_MYSELF(_Actions__Jumper,JUMPER_UPDATE);

        // if climber, do a wall-jump, else just jump forward
        if me.pingu:get_previous_action() == {ActionName::CLIMBER} then
            me.pingu:direction.change();
        end

        if me.pingu:direction.is_left() then
            me.pingu:set_velocity(me.pingu:get_velocity() +
                                  _Vector3f(-4.58, -4.58));
        else
            // if (me.pingu:direction.is_right())
            me.pingu:set_velocity(me.pingu:get_velocity() +
                                  _Vector3f(4.58, -4.58));
        end

        // Move the me.pingu:n the air, so that it can start 'falling'
        me.pingu:set_y(me.pingu:get_y() - 1);

        me.pingu:set_action({ActionName::FALLER});
        ///escape {ActionName::FALLER};
    end

    ///escape {ActionName::WALKER};
    ///await FOREVER;
end

class JumperFactory with
do
    every me_ in JUMPER_NEW do
        spawn Jumper with
            this.me = &_XXX_PTR2REF(me_);
        end;
    end
end

var JumperFactory _;

#endif
