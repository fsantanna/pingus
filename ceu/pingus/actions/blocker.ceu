#ifndef _BLOCKER_CEU
#define _BLOCKER_CEU

#include "../right_left_sprites.ceu"

class Blocker with
    interface IPinguAction;
do
    function (void)=>bool standing_on_ground;
    function (_Pingu&& target)=>void catch_pingu;

    var char[] left  = [] .. "pingus/player"
                          .. (char&&)*this.pingu.get_owner_str().c_str()
                          .. "/blocker/left";
    var char[] right = [] .. "pingus/player"
                          .. (char&&)*this.pingu.get_owner_str().c_str()
                          .. "/blocker/right";
    var RightLeftSprites _ with
        this.pingu = &outer.pingu;
        this.left  = &left;
        this.right = &right;
    end;

    /* UPDATE */
    loop do
        await WORLD_UPDATE;
        if not this.standing_on_ground() then
            escape {ActionName::FALLER};
        end

        // FIXME: PinguHolder iterations should be handled otherwise
        {
            /// XXX_CPP
            static PinguHolder* pingus = WorldObj::get_world()->get_pingus();
            for(PinguIter i = pingus->begin(); i != pingus->end(); ++i)
                CEU_Blocker_catch_pingu(_ceu_app,_STK_ORG,*i);
        };
    end

    /* PRIVATE */

    function (void)=>bool standing_on_ground do
        return (this.pingu.me.rel_getpixel(0,-1) != {Groundtype::GP_NOTHING});
    end

    function (_Pingu&& target)=>void catch_pingu do
        if (target != &&this.pingu.me) then // avoid 'self' catch
            if ( target:get_x() > this.pingu.me.get_x()-16
            and  target:get_x() < this.pingu.me.get_x()+16
            and  target:get_y() > this.pingu.me.get_y()-32
            and  target:get_y() < this.pingu.me.get_y()+5 )
            then
                if (target:get_x() > this.pingu.me.get_x()) then
                    target:direction.right();
                else
                    target:direction.left();
                end
            end
        end
    end
end

#endif
