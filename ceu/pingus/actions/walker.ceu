#ifndef _WALKER_CEU
#define _WALKER_CEU

#define WALKER_MAX_STEPS 5  // max nr. of pixels that pingu can walk up/down

class Walker with
    interface IPinguAction;
do
    var char[] left1  = [] .. "pingus/player"
                           .. (char&&)*this.pingu.me.get_owner_str().c_str()
                           .. "/walker/left";
    var char[] right1 = [] .. "pingus/player"
                           .. (char&&)*this.pingu.me.get_owner_str().c_str()
                           .. "/walker/right";
    var RightLeftSprites _ with
        this.pingu = &outer.pingu;
        this.left  = &left1;
        this.right = &right1;
    end;

    // Reset the velocity
    this.pingu.me.set_velocity({Vector3f()});

    /* UPDATE */
    par do
        await WORLD_UPDATE
        until (this.pingu.fall_action == {ActionName::FLOATER});
        do
            var char[] left2  = [] .. "other/floaterlayer/left";
            var char[] right2 = [] .. "other/floaterlayer/right";
            var RightLeftSprites _ with
                this.pingu = &outer.pingu;
                this.left  = &left2;
                this.right = &right2;
            end;
            await FOREVER;
        end
    with
        loop do
            await WORLD_UPDATE;

            // XXX_CPP
            {
                static Vector3f last_pos;
            };
            _last_pos = (_Vector3f)this.pingu.me.get_pos();

              /* How should this code work?

                 1) Check that the Pingu stands still on ground, if not turn it into
                 a faller or drown. The reason we do so, is that we catch situations
                 where a digger or a similar action removed the ground under the
                 walker.

                 2) If pingu is still on ground, we can preprare the next step

                 3) Check if up-hill or down-hill is required

                 4)

              */

            if this.pingu.me.rel_getpixel(0, -1) == {Groundtype::GP_NOTHING} then
                // The Pingu stands no longer on ground, the cause for this could 
                // be a digger, miner or a bomber
                // We search for the nearest ground below the pingu, if we can't 
                // find anything within a few pixels, we will turn into a faller
                var bool found_ground = false;
                var int i = 0;
                loop ii in 2 do   // [-2 .. -4]
                    i = -ii - 2;
                    if not (this.pingu.me.rel_getpixel(0, i) == {Groundtype::GP_NOTHING}) then
                        found_ground = true;
                        break;
                    end
                end
                if found_ground then
                    this.pingu.me.set_y(this.pingu.me.get_y() - (float)(i));
                else
                    escape {ActionName::FALLER};
                end
            end

            // FIXME: here we could/should scan more pixels
            if this.pingu.me.rel_getpixel(1, 0) == {Groundtype::GP_BRIDGE} and
               not this.pingu.me.head_collision_on_walk(1, 1)
            then // bridge
                // simple, stupid, but working bridge code
                // FIXME: We don't check if we 'drift' into a solid ground block
                this.pingu.me.set_pos(
                    this.pingu.me.get_x() + (float)(this.pingu.me.direction),
                    this.pingu.me.get_y() - 1.0); // pingus 'float' through bridges
            else
                // Non of the trivial moves worked, so we do up-hill or down-hill 
                // walking
                // FIXME: currently the pingu takes multiple steps at once when
                // FIXME: working uphill, this looks kind of ugly

                // FIXME: rel_getpixel works on the current pos, so modifing pos
                // FIXME: is evil, a backup copy might help

                // if infront is a pixel Pingu is walking up the mountain
                // we can continue walking up. search for the correct y_pos
                var int y_inc = 0;
                var int possible_y_step = 0;
                var bool found_next_step = false;
                loop i in 2*WALKER_MAX_STEPS+1 do // [-max_steps ..  max_steps]
                    y_inc = i-WALKER_MAX_STEPS;
                    // up/down-hill scan
                    if (this.pingu.me.rel_getpixel(1, y_inc)=={Groundtype::GP_NOTHING} or
                        this.pingu.me.rel_getpixel(1, y_inc)=={Groundtype::GP_BRIDGE})
                    and
                        // FIXME: This causes a rather huge step
                        this.pingu.me.rel_getpixel(1, y_inc - 1) != {Groundtype::GP_NOTHING}
                    then
                        // FIXME:
                        found_next_step = true;
                        possible_y_step = y_inc;
                        // No break here, since we always want to use the 
                        // highest possible position
                        //break;
                    end
                end

                if found_next_step then
                    // pos.y has a reversed co-system to rel_getpixel()?
                    this.pingu.me.set_pos(
                        this.pingu.me.get_x() + (float)(this.pingu.me.direction),
                        this.pingu.me.get_y() - (float)(possible_y_step));
                else
                    if this.pingu.me.rel_getpixel(1, 0) != {Groundtype::GP_NOTHING} then
                        // We reached a wall
                        var int wall_action = this.pingu.wall_action;
                        if wall_action != {ActionName::NONE} then
                            _log_debug("Pingu: We are in front of a wall, setting persistant action");
                            escape wall_action;
                        end

                        // No persitent action found, so change the direction
                        this.pingu.me.direction.change();
                    else
                        // We take the step, so that we are in the air
                        this.pingu.me.set_x(this.pingu.me.get_x() + (float)(this.pingu.me.direction));
                        // We reached a cliff
                        escape {ActionName::FALLER};
                    end
                end

                // This is moved here to fix the bug where pingu stuck turning both 
                // sides indefinetely when a head collision occured. the fix needs 
                // the above downhill walk being done before head collision check.
                if this.pingu.me.head_collision_on_walk(0, 0) then
                    _log_debug("Pingu: Head collision");

                    //if the new position causes a head collision, we are already 
                    //stuck in a wall, so lets go back to the old position
                    this.pingu.me.direction.change();
                    this.pingu.me.set_pos(_last_pos);
                end
            end
        end
    end
end

#endif
