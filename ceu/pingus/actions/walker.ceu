#ifndef _WALKER_CEU
#define _WALKER_CEU

#define WALKER_MAX_STEPS 5  // max nr. of pixels that pingu can walk up/down

code/await Walker (var _ActionName__Enum previous_action)
                    -> int
do
    vector[] byte left1  = [] .. "pingus/player"
                           .. (call Get_Owner_Str() as _char&&)
                           .. "/walker/left";
    vector[] byte right1 = [] .. "pingus/player"
                           .. (call Get_Owner_Str() as _char&&)
                           .. "/walker/right";

    spawn RightLeftSprites(&outer.rect, &outer.direction, &left1, &right1, true);

    // Reset the velocity
    var Vector3f v = val Vector3f(0, 0, 0);
    call Set_Velocity(v);

    /* UPDATE */
    par do
        await WORLD_UPDATE
        until (outer.fall_action == {ActionName::FLOATER});
        vector[] byte left2  = [] .. "other/floaterlayer/left";
        vector[] byte right2 = [] .. "other/floaterlayer/right";
        spawn RightLeftSprites(&outer.rect, &outer.direction, &left2, &right2, true);
        await FOREVER;
    with
        loop do
            await WORLD_UPDATE;

            var Vector3f last_pos = call Get_Pos();

              /* How should this code work?

                 1) Check that the Pingu stands still on ground, if not turn it into
                 a faller or drown. The reason we do so, is that we catch situations
                 where a digger or a similar action removed the ground under the
                 walker.

                 2) If pingu is still on ground, we can preprare the next step

                 3) Check if up-hill or down-hill is required

                 4)

              */

            if call Rel_Getpixel(0,-1) == {Groundtype::GP_NOTHING} then
                // The Pingu stands no longer on ground, the cause for this could 
                // be a digger, miner or a bomber
                // We search for the nearest ground below the pingu, if we can't 
                // find anything within a few pixels, we will turn into a faller
                var int i = _;
                var bool? found_ground = do
                    loop i in [-4 <- -2] do
                        if not (call Rel_Getpixel(0,i) == {Groundtype::GP_NOTHING}) then
                            escape true;
                        end
                    end
                end;
                if found_ground? then
                    call Set_Y(call Get_Y()-i);
                else
                    escape {ActionName::FALLER};
                end
            end

            // FIXME: here we could/should scan more pixels
            if call Rel_Getpixel(1, 0) == {Groundtype::GP_BRIDGE} and
               not call Head_Collision_On_Walk(1, 1)
            then // bridge
                // simple, stupid, but working bridge code
                // FIXME: We don't check if we 'drift' into a solid ground block
                call Set_Pos(
                    call Get_X() + (outer.direction as int),
                    call Get_Y() - 1.0); // pingus 'float' through bridges
            else
                // Non of the trivial moves worked, so we do up-hill or down-hill 
                // walking
                // FIXME: currently the pingu takes multiple steps at once when
                // FIXME: working uphill, this looks kind of ugly

                // FIXME: rel_getpixel works on the current pos, so modifing pos
                // FIXME: is evil, a backup copy might help

                // if infront is a pixel Pingu is walking up the mountain
                // we can continue walking up. search for the correct y_pos
                var int possible_y_step = 0;
                var bool found_next_step = false;
                var int y_inc;
                loop y_inc in [-WALKER_MAX_STEPS -> +WALKER_MAX_STEPS] do
                    // up/down-hill scan
                    if (call Rel_Getpixel(1, y_inc)=={Groundtype::GP_NOTHING} or
                        call Rel_Getpixel(1, y_inc)=={Groundtype::GP_BRIDGE})
                    and
                        // FIXME: This causes a rather huge step
                        call Rel_Getpixel(1, y_inc - 1) != {Groundtype::GP_NOTHING}
                    then
                        // FIXME:
                        found_next_step = true;
                        possible_y_step = y_inc;
                        // No break here, since we always want to use the 
                        // highest possible position
                        //break;
                    end
                end

                if found_next_step then
                    // pos.y has a reversed co-system to rel_getpixel()?
                    call Set_Pos(
                        call Get_X() + (outer.direction as int),
                        call Get_Y() - possible_y_step,
                    );
                else
                    if call Rel_Getpixel(1,0) != {Groundtype::GP_NOTHING} then
                        // We reached a wall
                        var int wall_action = outer.wall_action;
                        if wall_action != {ActionName::NONE} then
                            _log_debug("Pingu: We are in front of a wall, setting persistant action");
                            escape wall_action;
                        end

                        // No persitent action found, so change the direction
                        call Change_Direction();
                    else
                        // We take the step, so that we are in the air
                        call Set_X(call Get_X() + (outer.direction as int));
                        // We reached a cliff
                        escape {ActionName::FALLER};
                    end
                end

                // This is moved here to fix the bug where pingu stuck turning both 
                // sides indefinetely when a head collision occured. the fix needs 
                // the above downhill walk being done before head collision check.
                if call Head_Collision_On_Walk(0, 0) then
                    _log_debug("Pingu: Head collision");

                    //if the new position causes a head collision, we are already 
                    //stuck in a wall, so lets go back to the old position
                    call Change_Direction();
                    call Set_Pos(last_pos.x,last_pos.y);
                end
            end
        end
    end
end

#endif
