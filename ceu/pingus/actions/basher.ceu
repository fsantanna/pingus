#ifndef _BASHER_CEU
#define _BASHER_CEU

native do
    ##include "../../../src/engine/sound/sound.hpp"
end

#include "../pingu_action.ceu"
#include "../right_left_sprites.ceu"

/* Defines the minimum "wall" height needed for a bash to happen. */
#define BASHER_MIN_BASH_HEIGHT 5

/* Defines the maximum height up to which a check is made to see if there
   is anything to bash.  Best to make this at least (min_bash_height +
   pingu_height). */
#define BASHER_MAX_BASH_HEIGHT 33

/* Defines the maximum no. of steps down a Basher can go down before it
   stops being a Basher and turns into a Faller. */
#define BASHER_MAX_STEPS_DOWN 3

class Basher with
    interface IPinguAction;
do
    function (void)=>void bash;
    function (void)=>bool walk_forward;
    function (void)=>bool have_something_to_dig;

    var char[] left  = [] .. "pingus/player"
                          .. (char&&)*this.pingu.me.get_owner_str().c_str()
                          .. "/basher/left";
    var char[] right = [] .. "pingus/player"
                          .. (char&&)*this.pingu.me.get_owner_str().c_str()
                          .. "/basher/right";
    var RightLeftSprites sprites with
        this.pingu = &outer.pingu;
        this.left  = &left;
        this.right = &right;
    end;

    // Start a bash even so the action will stops instantly after the
    // first bash
    this.bash();
    var int bash_reach; // set in bash

    /* UPDATE */
    var bool is_first_bash = true;
    loop i do
        await PINGUHOLDER_UPDATE;
        await PINGUHOLDER_UPDATE;
        await PINGUHOLDER_UPDATE;

        if not this.walk_forward() then
            escape {ActionName::FALLER};
        end

        // If on walking forward the Basher has now walked on to water or lava
        if me.rel_getpixel(0,-1) == {Groundtype::GP_WATER} or
           me.rel_getpixel(0,-1) == {Groundtype::GP_LAVA}
        then
            escape {ActionName::DROWN};

        // If walking on to something (i.e. hasn't fallen)
        else/if me.rel_getpixel(0,-1) != {Groundtype::GP_NOTHING}
        then
            // If the Basher has walked into something that it won't be 
            // able to bash
            if me.rel_getpixel(0,0)             == {Groundtype::GP_SOLID} or
               me.rel_getpixel(0,_pingu_height) == {Groundtype::GP_SOLID}
            then
                // Change direction and let walk code walk forward/up to get out.
                { Sound::PingusSound::play_sound("chink"); };
                this.pingu.me.direction.change();
                escape {ActionName::WALKER};
            else/if is_first_bash or this.have_something_to_dig() then
                is_first_bash = false;
                // We only bash every second step, cause the Pingus would
                // get trapped otherwise in the bashing area.
                if i%2 == 1 then
                    this.bash();
                end
            else/if ((float)(sprites.get():get_current_frame())) /
                    ((float)(sprites.get():get_frame_count())) > 0.6
                // FIXME: Game logic must be separate from Sprite
                // FIXME: EVIL! Engine must not relay on graphic
            then
                escape {ActionName::WALKER};
            end
        end
    end

    /* PRIVATE */

    function (void)=>void bash do
        {
            ##include "../../../src/pingus/collision_mask.hpp"
            static CollisionMask bash_radius(
                    "pingus/common/bash_radius_gfx",
                    "pingus/common/bash_radius");
            assert(bash_radius.get_width() % 2 == 0);
        };
        this.bash_reach = _bash_radius.get_width();

        call {WorldObj::get_world()->remove}(
                _bash_radius,
                this.pingu.me.get_xi() - _bash_radius.get_width() / 2,
                this.pingu.me.get_yi() - _bash_radius.get_height() + 1
        );
    end

    function (void)=>bool walk_forward do
        var int y_inc = 0;

        // Find the correct y position to go to next
        loop i in BASHER_MAX_STEPS_DOWN+1 do
            y_inc = -i;
            // If there is something below, get out of this loop
            if this.me.rel_getpixel(0, y_inc - 1) != {Groundtype::GP_NOTHING} then
                break;
            end
        end

        if y_inc < -BASHER_MAX_STEPS_DOWN then
            // The step down is too much.  So stop being a Basher and be a 
            // Faller.
            return false;
        else
            // Note that Pingu::set_pos() is the 'reverse' of the y co-ords of
            // rel_getpixel()
            this.pingu.me.set_pos(
                this.pingu.me.get_x() + (float)(this.pingu.me.direction),
                this.pingu.me.get_y() - (float)(y_inc)
            );
        end
        return true;
    end

    function (void)=>bool have_something_to_dig do
        // Check that there is something "within" the Basher's reach
        loop x in this.bash_reach+1 do
            loop i in (BASHER_MAX_BASH_HEIGHT-BASHER_MIN_BASH_HEIGHT+1) do
                var int y = BASHER_MIN_BASH_HEIGHT + i;
                if this.me.rel_getpixel(x, y) == {Groundtype::GP_GROUND} then
                    _log_debug("Basher: Found something to dig...");
                    return true;
                end
            end
        end
        return false;
    end
end

#endif
