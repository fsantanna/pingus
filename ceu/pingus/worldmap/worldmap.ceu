#ifndef WORLDMAP_CEU
#define WORLDMAP_CEU

native/pre do
    ##include "pingus/worldmap/pingus_worldmap.hpp"
    ##include "pingus/worldmap/worldmap.hpp"
    ##include "pingus/res_descriptor.hpp"
    ##include "engine/display/sprite_description.hpp"
    ##include "pingus/worldmap/level_dot.hpp"
    ##include "pingus/worldmap/pingus.hpp"
end

native do
    static std::shared_ptr<WorldmapNS::WorldmapScreen> screen;
    static std::vector<FileReader> object_reader;
    std::vector<FileReader>::const_iterator i;
    static ResDescriptor desc;
    static SpriteDescription* spr;
    static Vector3f      pos;
    static bool          auto_uncover;
end

#include "../../engine/gui/surface_button.ceu"
#include "pingus.ceu"

class SpriteDrawable with
    var int x, y, z;
    var bool auto_uncover;
    var _SpriteDescription&& desc;;
do
    var Surface sfc with
        this.desc = desc;
    end;

    every gc in SCREENMANAGER_DRAW do
        if this.auto_uncover then
            { static Vector3f pos; };
            _pos = _XXX_PURE(_Vector3f(100,100,0));
            // Pingu is not over the surface
            if (not (_pos.x>this.x and _pos.x<(this.x + sfc.get_width()) and
                     _pos.y>this.y and _pos.y<(this.y + sfc.get_height())))
            then
                gc:draw(&&sfc, _Vector2i(this.x,this.y))
                    finalize with end;
            else/if _pos.z > this.z+1000 then
                // FIXME: Hack for the 0.6.0 release/tutorial world remove // later
                gc:draw(&&sfc, _Vector2i(this.x,this.y))
                    finalize with end;
            end
        else
            gc:draw(&&sfc, _Vector2i(this.x,this.y))
                finalize with end;
        end
    end
end

class WorldMap with
    var _Pathname&& filename;
do
    {
        screen = std::make_shared<WorldmapNS::WorldmapScreen>();
        screen->load(*THIS(CEU_WorldMap)->filename);
        ScreenManager::instance()->push_screen(screen);
    };
    _screen:worldmap:gc_state.set_limit(
        _Rect(_Vector2i(0, 0),
        _Size(_screen:worldmap:worldmap.get_width(), _screen:worldmap:worldmap.get_height())));

    var Pingus pingus with
        this.path = _XXX_PURE(_screen:worldmap:path_graph.get());
    end;

        loop do
            var int x, y;
            (x,y) = await ON_PRIMARY_BUTTON_PRESSED;
            var float xx, yy;
            var float xx = _screen:worldmap:gc_state.screen2world(_Vector2i(x,y)).x;
            var float yy = _screen:worldmap:gc_state.screen2world(_Vector2i(x,y)).y;
_printf("CEU-0 (%d,%d) => (%f,%f)\n", x, y, xx, yy);

            { WorldmapNS::Dot* dot; };
            _dot = _XXX_PURE(_screen:worldmap:path_graph:get_dot(xx, yy));
            if _dot != null then
                if {globals::developer_mode} then
                    _log_info("Worldmap: Clicked on: %1%", _dot:get_name());
                end

                if (_screen:worldmap:path_graph:lookup_node
                        (_dot:get_name()) == _screen:worldmap:pingus:get_node()) 
                    then
                    if {globals::developer_mode} then
                        _log_info("Worldmap: Pingu is on node, issue on_click()");
                    end
                    _dot:on_click();
_printf("ALREADY THERE\n");
                else
                    if _dot:accessible() then
_printf("GO\n");
                        emit pingus.go =>
                            _screen:worldmap:path_graph:lookup_node(_dot:get_name());
                        if not _screen:worldmap:pingus:walk_to_node
                                (_screen:worldmap:path_graph:lookup_node(_dot:get_name()))
                        then
                            if {globals::developer_mode} then
                                _log_info("Worldmap: NO PATH TO NODE FOUND!");
                            end
                        else
                            {StatManager::instance()->set_string
                                (screen->worldmap->worldmap.get_short_name() + "-current-node", dot->get_name());};
                        end
                    else
                        call {Sound::PingusSound::play_sound}("chink");
                    end
                end
            end
        end

#if 0
    var _PingusWorldmap&? worldmap;
    finalize
        worldmap = &{new PingusWorldmap}(_XXX_PURE(*filename));
    with
        _delete(&&worldmap!);
    end

    {Sound::PingusSound::stop_music();};
    call {Sound::PingusSound::play_music}(worldmap!.get_music());

    pool SpriteDrawable[] sprites;

    _object_reader = _XXX_PURE(worldmap!.get_objects());
    _i = _XXX_PURE(_object_reader.begin());
    loop do
        if _i == _object_reader.end() then
            break;
        end
        var bool ok = true;
        if _i:get_name() == "surface" then
            {
                i->read_desc  ("surface", desc);
                i->read_vector("position", pos);
                i->read_bool  ("auto-uncover", auto_uncover);
                spr = Resource::load_sprite_desc(desc.res_name);
            };
            //_assert(not _auto_uncover);
            spawn SpriteDrawable in sprites with
                this.desc = _spr;
                this.x = _pos.x;
                this.y = _pos.y;
                this.z = _pos.z;
                this.auto_uncover = _auto_uncover;
            end;
        else
            _log_error("can't create %1%", _i:get_name());
            ok = false;
        end
        if not ok then
            _log_info("Worldmap::parse_objects: Parse Error");
        end
        _i = _i + 1;
    end

    var SurfaceButton close with
        this.x = 0;
        this.y = {Display::get_height() - 37};
        this.button         = "core/worldmap/leave_button_normal";
        this.button_pressed = "core/worldmap/leave_button_pressed";
        this.button_over    = "core/worldmap/leave_button_hover";
    end;

    par do
        every close.get_component().on_pointer_enter do
            call {Sound::PingusSound::play_sound}("tick");
        end
    with
        await close.get_component().on_click;
        escape -1;
    with
        loop do
            var _Input__Event&& e = await ON_INPUT_EVENT;
            var _Input__ButtonEvent&& but = &&e:button;
            if e:type != {Input::BUTTON_EVENT_TYPE}
            or but:state != {Input::BUTTON_PRESSED}
            then
                continue;
            end
            if but:name == {Input::ESCAPE_BUTTON} then
                escape -1;
            end
        end
    with
        every gc in SCREENMANAGER_DRAW do
            gc:print_center({Fonts::chalk_small},
                            _Vector2i(44, {Display::get_height()} - 25),
                            __("Leave?"));
        end
    end
#endif
end

#endif
