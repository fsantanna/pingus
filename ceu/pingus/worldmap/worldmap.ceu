#ifndef WORLDMAP_CEU
#define WORLDMAP_CEU

native @plain _WorldmapNS__NodeId;
native/pre do
    ##define WorldmapNS__NodeId WorldmapNS::NodeId
    ##define WorldmapNS__Dot WorldmapNS::Dot
    ##include "pingus/worldmap/pingus_worldmap.hpp"
    ##include "pingus/worldmap/worldmap.hpp"
    ##include "pingus/res_descriptor.hpp"
    ##include "engine/display/sprite_description.hpp"
    ##include "pingus/worldmap/level_dot.hpp"
    ##include "util/sexpr_file_writer.hpp"
end

native do
    static std::shared_ptr<WorldmapNS::WorldmapScreen> screen;
    static std::vector<FileReader> object_reader;
    std::vector<FileReader>::const_iterator i;
    static ResDescriptor desc;
    static SpriteDescription* spr;
    static Vector3f      pos;
    static bool          auto_uncover;
end

#include "../../engine/gui/surface_button.ceu"
#include "dots.ceu"
#include "pingus.ceu"

class SpriteDrawable with
    var _FileReader&& reader;
    var Vector3f&     pos;
do
    {
        static ResDescriptor desc;
        static Vector3f      pos;
        static bool          auto_uncover;
    };
    reader:read_desc  ("surface", _desc);
    reader:read_vector("position", _pos);
    reader:read_bool  ("auto-uncover", _auto_uncover);

    var bool auto_uncover = false;
    var Vector3f pos_ini = Vector3f(_pos.x,_pos.y,_pos.z);

    var _SpriteDescription&& desc = _XXX_PURE({Resource::load_sprite_desc}(_desc.res_name));
    var Surface sfc with
        this.desc = desc;
    end;

    every gc in SCREENMANAGER_DRAW do
        if this.auto_uncover then
            // Pingu is not over the surface
            if (not (this.pos.x>pos_ini.x and this.pos.x<(pos_ini.x + sfc.get_width()) and
                     this.pos.y>pos_ini.y and this.pos.y<(pos_ini.y + sfc.get_height())))
            then
                gc:draw(&&sfc, _Vector2i(pos_ini.x,pos_ini.y))
                    finalize with end;
            else/if this.pos.z > pos_ini.z+1000 then
                // FIXME: Hack for the 0.6.0 release/tutorial world remove // later
                gc:draw(&&sfc, _Vector2i(pos_ini.x,pos_ini.y))
                    finalize with end;
            end
        else
            gc:draw(&&sfc, _Vector2i(pos_ini.x,pos_ini.y))
                finalize with end;
        end
    end
end

class WorldMap with
    var _Pathname&& filename;
do
    {
        screen = std::make_shared<WorldmapNS::WorldmapScreen>();
        screen->load(*THIS(CEU_WorldMap)->filename);
        ScreenManager::instance()->push_screen(screen);
    };
    _screen:worldmap:gc_state.set_limit(
        _Rect(_Vector2i(0, 0),
        _Size(_screen:worldmap:worldmap.get_width(), _screen:worldmap:worldmap.get_height())));

    {Sound::PingusSound::play_music(screen->worldmap->worldmap.get_music());};

    // Determine starting node
    // See if the user has played this map before.
    // If not, use the <default-node> tag from the XML file.
    var Vector3f pos = Vector3f(0,0,0);
    var _WorldmapNS__NodeId id =
        _screen:worldmap:path_graph:lookup_node(_screen:worldmap:worldmap.get_default_node());
    {
        static std::string node_name;
    };
    if {StatManager::instance()->get_string(screen->worldmap->worldmap.get_short_name() + "-current-node",
                                            node_name)}
    then
        // Just in case that level doesn't exist, look it up.
        id = _screen:worldmap:path_graph:lookup_node(_node_name);
    end
    pos.x = _screen:worldmap:path_graph:get_dot(id):get_pos().x;
    pos.y = _screen:worldmap:path_graph:get_dot(id):get_pos().y;

    par do
        every gc in SCREENMANAGER_DRAW do
            var int x = 0;
            do
                var int min, max;
                var int width  = _screen:worldmap:worldmap.get_width();
                if width >= gc:get_width() then
                    min = gc:get_width()/2;
                    max = width - gc:get_width()/2;
                else
                    min = width - gc:get_width()/2;
                    max = gc:get_width()/2;
                end
                x = {Math::clamp}(min, (int)pos.x, max);
            end

            var int y = 0;
            do
                var int min, max;
                var int height = _screen:worldmap:worldmap.get_height();
                if height >= gc:get_height() then
                    min = gc:get_height()/2;
                    max = height - gc:get_height()/2;
                else
                    min = height - gc:get_height()/2;
                    max = gc:get_height()/2;
                end
                y = {Math::clamp}(min, (int)pos.y, max);
            end

            _screen:worldmap:gc_state.set_size(gc:get_width(), gc:get_height());
            _screen:worldmap:gc_state.set_pos(_Vector2i(x, y));
            _screen:worldmap:gc_state.push(*gc);
        end
    with
        // Create all objects
        pool SpriteDrawable[] draws;
        {
            static const std::vector<FileReader>& object_reader = screen->worldmap->worldmap.get_objects();
            static std::vector<FileReader>::const_iterator i1;
        };
        _i1 = _XXX_PURE(_object_reader.begin());
        loop do
            if _i1 == _object_reader.end() then
                break;
            end
            //log_info("Worldmap::parse_objects: Parse Error");
            { const FileReader& file_reader = *i1; };
            var _FileReader&& reader = (_FileReader&&)&&_file_reader;
            spawn SpriteDrawable in draws with
                this.reader = reader;
                this.pos    = &pos;
            end;
            {i1++;};
        end

        // Create graph
        var DotE dot;
        pool IDot[] dots;
        {
            static const std::vector<FileReader>& childs =
                screen->worldmap->worldmap.get_graph().read_section("nodes").get_sections();
            static std::vector<FileReader>::const_iterator i2;
        };
        _i2 = _XXX_PURE(_childs.begin());
        loop do
            if _i2 == _childs.end() then
                break;
            end
            { const FileReader& file_reader = *i2; };
            var _FileReader&& reader = (_FileReader&&)&&_file_reader;
            if reader:get_name() == "storydot" then
                spawn StoryDot in dots with
                    this.reader = reader;
                    this.pos    = &pos;
                    this.e      = &dot;
                    this.is_story = true;
                end;
            else/if reader:get_name() == "leveldot" then
                spawn LevelDot in dots with
                    this.reader = reader;
                    this.pos    = &pos;
                    this.e      = &dot;
                    this.is_story = false;
                end;
            else
                _assert(not "DotFactory: unknown tag: ");// <<  reader.get_name());
            end
            {i2++;};
        end

        var Pingus pingus with
            this.path = _XXX_PURE(_screen:worldmap:path_graph.get());
            this.node = id;
            this.pos  = &pos;
        end;

        //every (but,id_,status) in dot.ok_clicked do
        loop do
            var int but,id_,status;
            var bool is_story;
            (but,id_,is_story,status) = await dot.ok_clicked;
            if but == 1 then
                if id_ == pingus.node then
                    if {globals::developer_mode} then
                        _log_info("Worldmap: Pingu is on node, issue on_click()");
                    end
                    escape is_story;
                else
                    if status == {Savegame::NONE} then
                        call {Sound::PingusSound::play_sound}("chink");
                    else
                        call {StatManager::instance()}:set_string(
                            {screen->worldmap->worldmap.get_short_name() + "-current-node"},
                            _screen:worldmap:path_graph:lookup_node(id_)
                        );
                        emit pingus.go_walking => id_;
                    end
                end
            else
                _assert(but == 2);
                emit pingus.go_directly => id_;
            end
        end
    with
        every (x,y) in ON_PRIMARY_BUTTON_PRESSED do
            var float xx = _screen:worldmap:gc_state.screen2world(_Vector2i(x,y)).x;
            var float yy = _screen:worldmap:gc_state.screen2world(_Vector2i(x,y)).y;
            { static Vector2f click_pos; };
            _click_pos = _XXX_PURE(_Vector2i(xx,yy));
            {
                if (globals::developer_mode)
                {
                    SExprFileWriter writer(std::cout);
                    writer.begin_section("leveldot");
                    writer.write_string("levelname", "");
                    writer.begin_section("dot");
                    writer.write_string("name", "leveldot_X");
                    writer.write_vector("position", click_pos);
                    writer.end_section();
                    writer.end_section();
                    std::cout << std::endl;
                    std::cout << std::endl;
                }
            };
        end
    with
        every gc in SCREENMANAGER_DRAW do
            _screen:worldmap:gc_state.pop(*gc);
        end
    end
end

#endif
