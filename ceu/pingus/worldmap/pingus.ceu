#ifndef _PINGUS_CEU
#define _PINGUS_CEU

#include "../../engine/display/sprite.ceu"
#include "../right_left_sprites.ceu"

native @plain _WorldmapNS__NodeId;
native/pre do
    ##define WorldmapNS__NodeId           WorldmapNS::NodeId
    ##define WorldmapNS__PathGraph        WorldmapNS::PathGraph
    ##define WorldmapNS__Path             WorldmapNS::Path
    ##define WorldmapNS__PathfinderResult WorldmapNS::PathfinderResult
    ##include "pingus/worldmap/worldmap.hpp"
    ##include "pingus/worldmap/path.hpp"
    ##include "pingus/worldmap/path_graph.hpp"
    ##include "pingus/worldmap/pathfinder.hpp"
    static WorldmapNS::Path edge_path;
end

class MovePath with
    var s8&    direction;
    var float& pos_x;
    var float& pos_y;
    var float& cur;
do
    var float velocity = 70;
    loop do
        var float dt = await SCREENMANAGER_UPDATE;
        // Update the edge_path_position
        cur = cur + velocity * dt;

        if cur > _edge_path.length() then
            break; // target reached
        end

        // Recalc pingu position on the screen
        var float prv_x = this.pos_x;
        var float prv_y = this.pos_y;
        this.pos_x = _edge_path.at(cur).x;
        this.pos_y = _edge_path.at(cur).y;

        var float dir = ({Math::atan2}(prv_x-this.pos_x, -(prv_y-this.pos_y))
                            / {Math::pi}*180) + 180;
        if dir>=0 and dir<180 then
            this.direction = _RIGHT;
        else
            this.direction = _LEFT;
        end
    end
end

class Pingus with
    interface  IPositionDirection;
    var _WorldmapNS__NodeId current_node;
    var s8     direction = _NONE;
    var float  pos_x;
    var float  pos_y;

    event _WorldmapNS__NodeId go;

    var _WorldmapNS__PathGraph&& path;
do
    var _WorldmapNS__PathGraph&? path_;
    finalize
        path_ = &_XXX_NOHOLD(this.path);
    with
    end

    var char[] left  = [].."core/worldmap/pingus/left";
    var char[] right = [].."core/worldmap/pingus/right";
    var RightLeftSprites _ with
        this.none   = [].."core/worldmap/pingus_standing";
        this.left   = &left;
        this.right  = &right;
        this.parent = &outer;
        this.is_world = false;
    end;

spawn do
    every 1s do
        //_printf("CEU-POS %f %f\n", pos_x, pos_y);
    end
end

    par do
        loop do
            var _WorldmapNS__NodeId target = await go;
            var float cur_position = 0;
            var int   cur_length   = 0;

            loop do
_printf("============== %d -> %d\n", this.current_node, target);
                {
                    static WorldmapNS::PathfinderResult res;
                    static std::vector<WorldmapNS::NodeId> node_path;
                };
                _res = _XXX_PURE(this.path_!.get_path(this.current_node, target));
                _node_path = _res.path;

                _assert(not _node_path.empty());
                var _WorldmapNS__NodeId src = _node_path.back();
                _node_path.pop_back();

                _assert(not _node_path.empty());
                var _WorldmapNS__NodeId dst = _node_path.back();
                _node_path.pop_back();

                watching target in go do
                    loop i do
                        _printf("> [%d]: %d => %d\n", i, src, dst);
                        _edge_path.clear();
                        var _WorldmapNS__Path&& partial_path =
                            _XXX_PURE(path_!.graph.resolve_edge(src,dst).data);
                        _edge_path.push_back(path_!.graph.resolve_node(src).data:get_pos());
                        // Why do we need to reverse this?!
                        _edge_path.reverse_insert(*partial_path)
                            finalize with nothing; end;
                        _edge_path.push_back(path_!.graph.resolve_node(dst).data:get_pos());
                        cur_length = _edge_path.length();
                        do MovePath with
                            this.direction = &outer.direction;
                            this.pos_x     = &outer.pos_x;
                            this.pos_y     = &outer.pos_y;
                            this.cur       = &cur_position;
                        end;
                        cur_position = 0;
                        _printf("< [%d]: %d => %d\n", i, src, dst);
                        this.current_node = dst;

                        if _node_path.empty() then
                            break;
                        else
                            src = dst;
                            dst = _node_path.back();
                            _node_path.pop_back();
                        end
                    end
                    this.direction = _NONE;
                    break; // moved and finished normally
                end

                // awoke from "go" during traversal

                if target == dst then
                    // nothing to do
                else/if target == src then
                    this.current_node = dst;
                    cur_position = cur_length - cur_position;
                else
                    // Pingu between two nodes
                    {
                        static WorldmapNS::PathfinderResult node_path1;
                        static WorldmapNS::PathfinderResult node_path2;
                    };
                    _node_path1 = _XXX_PURE(this.path_!.get_path(src, target));
                    _node_path2 = _XXX_PURE(this.path_!.get_path(dst, target));
                    if (_node_path1.cost+cur_position <
                        _node_path2.cost+(cur_length-cur_position))
                    then
                        _node_path = _node_path1.path;
                        this.current_node = dst;
                        cur_position = cur_length - cur_position;
                        _node_path.insert(_node_path.begin(), dst);
                    else
                        _node_path = _node_path2.path;
                    end
                end
            end
        end
    with
    end
end

#endif
