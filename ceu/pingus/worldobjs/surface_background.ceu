#ifndef _SURFACEBACKGROUND_CEU
#define _SURFACEBACKGROUND_CEU

class SurfaceBackground with
    var _FileReader&& reader;

    function (void)       =>float     get_z_pos;
    function (_Vector3f&&)=>void      set_pos;
    function (void)       =>_Vector3f get_pos;
do
    var float para_x = 0.5;
    var float para_y = 0.5;

    /* Position of the background, only the z_pos is really used. */
    var Vector3f pos;

    /* The amount of pixel the background is scrolled each frame in x
            direction. */
    var float scroll_x = 0;

    /* The amount of pixel the background is scrolled each frame in x
            direction. */
    var float scroll_y = 0;

    /* fill_rect() components
            An fill_rect() can be drawn over the background, the following
            for components are passed to the fill_rect() call. */
    var Color color = Color(0,0,0,0);

    /* Stretch the background to the full screen size in x direction */
    var bool stretch_x = false;

    /* Stretch the background to the full screen size in x direction */
    var bool stretch_y = false;

    /* If streched in x or y direction keep the aspect ratio */
    var bool keep_aspect = false;

    /* The horizontal scrolling speed in pixels per tick */
    var float scroll_ox = 0;

    /* The vertical scrolling speed in pixels per tick */
    var float scroll_oy = 0;

    //do
        { static Vector3f p; };
        if this.reader:read_vector("position", _p) then
            this.pos = Vector3f(_p.x,_p.y,_p.z);
        else
            this.pos = Vector3f(0,0,-150);
        end

        { static Color c; };
        if this.reader:read_colori("colori",_c) or
           this.reader:read_colorf("color",_c)
        then
            this.color = Color(_c.r, _c.g, _c.b, _c.a);
        end

        this.reader:read_float("para-x", this.para_x);
        this.reader:read_float("para-y", this.para_y);

        this.reader:read_float("scroll-x", this.scroll_x);
        this.reader:read_float("scroll-y", this.scroll_y);

        this.reader:read_bool("stretch-x", this.stretch_x);
        this.reader:read_bool("stretch-y", this.stretch_y);

        this.reader:read_bool("keep-aspect", this.keep_aspect);

        //_assert((not stretch_x) and (not stretch_y) and (color.a == 0));
    //end

    /* Background image */
    // FIXME: would be nice to allow surface manipulation with
    // animated sprites, but it's not that easy to do
    { static ResDescriptor desc; };
    this.reader:read_desc("surface", _desc);
    var _Sprite&? bg_sprite_;
    finalize
        bg_sprite_ = &{new Sprite}(_desc);
    with
        //_delete(&&bg_sprite_!);
    end
    var _Sprite& bg_sprite = &bg_sprite_!;

    par do
        every WORLD_UPDATE do
            if {globals::static_graphics} then
                continue;
            end
            this.bg_sprite.update();

            if (this.scroll_x) then
                this.scroll_ox = this.scroll_ox + this.scroll_x;
                if (this.scroll_ox > this.bg_sprite.get_width()) then
                    this.scroll_ox = this.scroll_ox -
                                            (float)(this.bg_sprite.get_width());
                else/if (-this.scroll_ox > this.bg_sprite.get_width()) then
                    this.scroll_ox = this.scroll_ox +
                                            (float)(this.bg_sprite.get_width());
                end
            end

            if (this.scroll_y) then
                this.scroll_oy = this.scroll_oy + this.scroll_y;
                if (this.scroll_oy > this.bg_sprite.get_height()) then
                    this.scroll_oy = this.scroll_oy -
                                            (float)(this.bg_sprite.get_height());
                else/if (-this.scroll_oy > this.bg_sprite.get_height()) then
                    this.scroll_oy = this.scroll_oy +
                                            (float)(this.bg_sprite.get_height());
                end
            end
        end
    with
        every gc in SCREENMANAGER_DRAW do
            var int offset_x=0;
            var int offset_y=0;
            do
                var _Vector2i offset = 
                 global:world!:get_scene_context().color().world_to_screen(_Vector2i(0,0));
                 offset_x = offset.x - global:world!:get_scene_context().color().get_rect().left;
                 offset_y = offset.y - global:world!:get_scene_context().color().get_rect().top;
            end

            var int start_x = (int)(((float)(offset_x) * this.para_x) + this.scroll_ox);
            var int start_y = (int)(((float)(offset_y) * this.para_y) + this.scroll_oy);

            if (start_x > 0) then
                start_x = (start_x % this.bg_sprite.get_width()) - this.bg_sprite.get_width();
            end

            if (start_y > 0) then
                start_y = (start_y % this.bg_sprite.get_height()) - this.bg_sprite.get_height();
            end

            var int y = start_y;
            loop i do
                if y >= global:world!:get_height() then
                    break;
                end

                var int x = start_x;
                loop j do
                    if x >= global:world!:get_width() then
                        break;
                    end
                    global:world!:get_scene_context().color().draw(
                                    this.bg_sprite,
                                    _Vector2i(x-offset_x, y-offset_y),
                                    this.pos.z);
                    x = x + this.bg_sprite.get_width();
                end
                y = y + this.bg_sprite.get_height();
            end
        end
    end

    /* PUBLIC */

    function (void)=>float get_z_pos do
        return this.pos.z;
    end
    function (_Vector3f&& p)=>void set_pos do
        this.pos = Vector3f(p:x, p:y, p:z);
    end
    function (void)=>_Vector3f get_pos do
        return _Vector3f(this.pos.x, this.pos.y, this.pos.z);
    end
end

#endif
