#ifndef _SURFACEBACKGROUND_CEU
#define _SURFACEBACKGROUND_CEU

class SurfaceBackground with
    var _FileReader&& reader;

    function (void)       =>float     get_z_pos;
    function (_Vector3f&&)=>void      set_pos;
    function (void)       =>_Vector3f get_pos;
do
    var float para_x = 0.5;
    var float para_y = 0.5;

    /* Position of the background, only the z_pos is really used. */
    var Vector3f pos;

    /* The amount of pixel the background is scrolled each frame in x
            direction. */
    var float scroll_x = 0;

    /* The amount of pixel the background is scrolled each frame in x
            direction. */
    var float scroll_y = 0;

    /* fill_rect() components
            An fill_rect() can be drawn over the background, the following
            for components are passed to the fill_rect() call. */
    var Color color = Color(0,0,0,0);

    /* Stretch the background to the full screen size in x direction */
    var bool stretch_x = false;

    /* Stretch the background to the full screen size in x direction */
    var bool stretch_y = false;

    /* If streched in x or y direction keep the aspect ratio */
    var bool keep_aspect = false;

    /* The horizontal scrolling speed in pixels per tick */
    var float scroll_ox = 0;

    /* The vertical scrolling speed in pixels per tick */
    var float scroll_oy = 0;

    //do
        { static Vector3f p; };
        if this.reader:read_vector("position", _p) then
            this.pos = Vector3f(_p.x,_p.y,_p.z);
        else
            this.pos = Vector3f(0,0,-150);
        end

        { static Color c; };
        if this.reader:read_colori("colori",_c) or
           this.reader:read_colorf("color",_c)
        then
            this.color = Color(_c.r, _c.g, _c.b, _c.a);
        end

        this.reader:read_float("para-x", this.para_x);
        this.reader:read_float("para-y", this.para_y);

        this.reader:read_float("scroll-x", this.scroll_x);
        this.reader:read_float("scroll-y", this.scroll_y);

        this.reader:read_bool("stretch-x", this.stretch_x);
        this.reader:read_bool("stretch-y", this.stretch_y);

        this.reader:read_bool("keep-aspect", this.keep_aspect);

        //_assert((not stretch_x) and (not stretch_y) and (color.a == 0));
    //end

    /* Background image */
    // FIXME: would be nice to allow surface manipulation with
    // animated sprites, but it's not that easy to do
    { static ResDescriptor desc; };
    this.reader:read_desc("surface", _desc);
    var _SpriteDescription&& desc = _XXX_PURE({Resource::load_sprite_desc}(_desc.res_name));
    var Surface bg_sfc with
        this.desc = desc;
    end;

    par do
        every WORLD_UPDATE do
            if {globals::static_graphics} then
                continue;
            end
            //this.bg_sprite.update();

            if (this.scroll_x) then
                this.scroll_ox = this.scroll_ox + this.scroll_x;
                if (this.scroll_ox > bg_sfc.get_width()) then
                    this.scroll_ox = this.scroll_ox -
                                            (float)(bg_sfc.get_width());
                else/if (-this.scroll_ox > bg_sfc.get_width()) then
                    this.scroll_ox = this.scroll_ox +
                                            (float)(bg_sfc.get_width());
                end
            end

            if (this.scroll_y) then
                this.scroll_oy = this.scroll_oy + this.scroll_y;
                if (this.scroll_oy > bg_sfc.get_height()) then
                    this.scroll_oy = this.scroll_oy -
                                            (float)(bg_sfc.get_height());
                else/if (-this.scroll_oy > bg_sfc.get_height()) then
                    this.scroll_oy = this.scroll_oy +
                                            (float)(bg_sfc.get_height());
                end
            end
        end
    with
        every REDRAW0 do
            var Vector2i off = global:world!:get_offset();

            var int start_x = (-off.x * this.para_x) + this.scroll_ox;
            var int start_y = (-off.y * this.para_y) + this.scroll_oy;

            if (start_x > 0) then
                start_x = (start_x % bg_sfc.get_width()) - bg_sfc.get_width();
            end

            if (start_y > 0) then
                start_y = (start_y % bg_sfc.get_height()) - bg_sfc.get_height();
            end

            var int y = start_y;
            loop i do
                if y >= global:world!:get_height() then
                    break;
                end

                var int x = start_x;
                loop j do
                    if x >= global:world!:get_width() then
                        break;
                    end
                    call {Display::s_framebuffer}:draw_surface(
                        bg_sfc.get_framebuffer_surface(),
                        _Vector2i(x+off.x,y+off.y)
                    );
                    x = x + bg_sfc.get_width();
                end
                y = y + bg_sfc.get_height();
            end
        end
    end

    /* PUBLIC */

    function (void)=>float get_z_pos do
        return this.pos.z;
    end
    function (_Vector3f&& p)=>void set_pos do
        this.pos = Vector3f(p:x, p:y, p:z);
    end
    function (void)=>_Vector3f get_pos do
        return _Vector3f(this.pos.x, this.pos.y, this.pos.z);
    end
end

#endif
