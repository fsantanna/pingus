#ifndef _LIQUID_CEU
#define _LIQUID_CEU

class Liquid with
    var _FileReader&& reader;

    function (void)       =>float     get_z_pos;
    function (_Vector3f&&)=>void      set_pos;
    function (void)       =>_Vector3f get_pos;
do
    { static Vector3f p; };
    this.reader:read_vector("position", _p);
    var Rect rect = Rect(_p.x,_p.y, 0,0);

/// TODO: vector of sprites up to width
    /* Background image */
    // FIXME: would be nice to allow surface manipulation with
    // animated sprites, but it's not that easy to do
    { static ResDescriptor desc; };
    this.reader:read_desc("surface", _desc);
    var _SpriteDescription&& desc = _XXX_PURE({Resource::load_sprite_desc}(_desc.res_name));
    var Sprite sprite with
        this.rect = &rect;
        this.desc = desc;
    end;

    var int width = 0;
    this.reader:read_int("repeat", width);
    width = width * sprite.get_width();

    do
        { static CollisionMask mask("liquids/water_cmap"); };
        loop i in width do
            global:world!:get_colmap():put(_mask,
                             (int)(rect.left + (float)(i)),
                             (int)(rect.top),
                             {Groundtype::GP_WATER});
        end
    end

    every REDRAW do
        var int x = this.rect.left;
        loop i do
            if x >= this.rect.left+this.width then
                break;
            end
            x = x + sprite.get_width();
            sprite.draw(x, this.rect.top);
        end
    end

    /* PUBLIC */

    function (void)=>float get_z_pos do
        return 0;
    end
    function (_Vector3f&& p)=>void set_pos do
        this.rect.left = p:x;
        this.rect.top  = p:y;
    end
    function (void)=>_Vector3f get_pos do
        return _Vector3f(this.rect.left, this.rect.top, 0);
    end
end

#endif
