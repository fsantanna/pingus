#ifndef _PLAYFIELD_CEU
#define _PLAYFIELD_CEU

input (int,int) PLAYFIELD_ON_PRIMARY_BUTTON_PRESS;

interface IPlayfield with
    var   IPingu&&?   current_pingu;
    event void        ok_pingu;
    var   _Playfield& me;
end

native do
    ##include "src/pingus/screens/game_session.hpp"
    ##include "pingus/server.hpp"
end

#include "../capture_rectangle.ceu"

class Playfield with
    interface IPlayfield;
    var PinguHolder& pingu_holder;
do
    par do
        every (x,y) in PLAYFIELD_ON_PRIMARY_BUTTON_PRESS do
            x = x - this.me.rect.left;
            y = y - this.me.rect.top;
            x = this.me.state.screen2world(_Vector2i(x,y)).x;
            y = this.me.state.screen2world(_Vector2i(x,y)).y;

            if this.me.session != null then
                var IWorld&&? world = (IWorld&&) _XXX_PURE(this.me.server:get_world():ceu);
                var IPingu&& current_pingu = null;
                var float min_dist = 500.0;
                var float dist;
                loop pingu in world!:get_pingu_holder().pingus do
                    if (pingu:is_over(x, y)) then
                        dist = pingu:me.dist(x, y);
                        if (dist < min_dist) then
                            min_dist = dist;
                            current_pingu = pingu;
                        end
                    end
                end

                if current_pingu != null then
// TODO enqueue on fail
                    emit current_pingu:go_action =>
                            this.me.session:get_action_name();
                end
            end
        end
    with
        var bool was_empty = true;
            // having current_pingu&&? is not enough because it can die and 
            // clear the variable

        every WORLD_UPDATE do
            var Position pos = Position(
                                this.me.state.screen2world(this.me.mouse_pos).x,
                                this.me.state.screen2world(this.me.mouse_pos).y
                               );

            var float min_dist = 500.0;
            var IPingu&&? cur;
            loop pingu in pingu_holder.pingus do
                if pingu:is_over((int)pos.x, (int)pos.y) then
                    var float dist = pingu:me.dist((int)pos.x, (int)pos.y);
                    if (dist < min_dist) then
                        min_dist = dist;
                        cur = pingu;
                    end
                end
            end

            var bool has_changed;
            if cur? then
                has_changed = was_empty or
                              (this.current_pingu? and (cur! != this.current_pingu!));
            else
                has_changed = (not was_empty);
            end

            this.current_pingu = cur;
            was_empty = (not cur?);
            if has_changed then
                emit this.ok_pingu;
            end
        end
    with
        // MUST BE UPDATED AFTER MYSELF

        var CaptureRectangle _ with
            this.playfield = &outer;
        end;
        await FOREVER;
    end

    /* PRIVATE */

end

#endif
