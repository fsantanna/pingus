#ifndef _PLAYFIELD_CEU
#define _PLAYFIELD_CEU

interface IPlayfield with
    var   IPingu&&? current_pingu;
    event void      ok_pingu;
end

native do
    ##include "src/pingus/screens/game_session.hpp"
    ##include "pingus/server.hpp"
end

#include "../../engine/gui/rect_component.ceu"
#include "../capture_rectangle.ceu"

class Playfield with
    interface IPlayfield;
    var PinguHolder& pingu_holder;

    var Rect& rect;

    function (void)=>Vector2i get_pos;
    function (int x, int y)=>void set_viewpoint;
    function (int x, int y)=>void scroll;
    function (void)=>void update_layout;
do
    #define POS2VEC(m) _Vector2i(m.x,m.y)

    var RectComponent component with
        this.rect  = &outer.rect;
        //this.state = &global:world!:get_state();
    end;

    var Position mouse_pos = Position(0,0);
    spawn do
        every (x,y) in ON_POINTER_MOVE do
            mouse_pos.x = x - this.rect.left;
            mouse_pos.y = y - this.rect.top;
        end
    end

    par do
        every (x,y) in component.on_primary_button_pressed do
            x = x - this.rect.left;
            y = y - this.rect.top;
            x = global:world!:get_state().screen2world(_Vector2i(x,y)).x;
            y = global:world!:get_state().screen2world(_Vector2i(x,y)).y;

            var IPingu&&? pingu;
            var float min_dist = 500.0;
            loop p in global:world!:get_pingu_holder().pingus do
                if (p:is_over(x, y)) then
                    var float dist = p:dist(x, y);
                    if (dist < min_dist) then
                        min_dist = dist;
                        pingu = p;
                    end
                end
            end

            if pingu? then
                var _ActionName__Enum action = _GLOBAL_SESSION:get_action_name();
                if pingu!:check_action(action) then
                    if _GLOBAL_SERVER:action_holder.pop_action(action) then
                        emit pingu!:go_action => action;
                    end
                end
            end
        end
    with
        loop do
            var int x,y;
            (x,y) = await ON_SECONDARY_BUTTON_PRESSED;

            var Vector2i old_state_pos = Vector2i(global:world!:get_state().get_pos().x,
                                                  global:world!:get_state().get_pos().y);

            var Vector2i scroll = Vector2i(x - this.rect.left,
                                           y - this.rect.top);

            watching ON_SECONDARY_BUTTON_RELEASED do
                par do
                    every SCREENMANAGER_UPDATE do
                        // FIXME: This should be delta dependant
                        if {globals::drag_drop_scrolling} then
                            global:world!:get_state().set_pos(
                                _Vector2i(old_state_pos.x,old_state_pos.y)
                                    + (_Vector2i(scroll.x,scroll.y)
                                        - POS2VEC(this.mouse_pos)));
                        else
                            global:world!:get_state().set_pos(
                                _Vector2i(global:world!:get_state().get_pos().x
                                            - (int)((float)(scroll.x - 
                                              this.mouse_pos.x) * 0.2),
                                          global:world!:get_state().get_pos().y
                                            - (int)((float)(scroll.y - 
                                              this.mouse_pos.y) * 0.2)
                                )
                            );
                        end
                    end
                with
                    every gc in SCREENMANAGER_DRAW do
                        if {globals::drag_drop_scrolling} then
                            continue;
                        end

                        gc:draw_line(POS2VEC(this.mouse_pos),
                                     _Vector2i(scroll.x,
                                               scroll.y - 15),
                                     _Color(0, 255, 0));
                        gc:draw_line(POS2VEC(this.mouse_pos),
                                     _Vector2i(scroll.x,
                                               scroll.y + 15),
                                     _Color(0, 0, 255));
                        gc:draw_line(POS2VEC(this.mouse_pos),
                                     _Vector2i(scroll.x + 15,
                                               scroll.y),
                                     _Color(0, 255, 255));
                        gc:draw_line(POS2VEC(this.mouse_pos),
                                     _Vector2i(scroll.x - 15,
                                               scroll.y),
                                     _Color(255, 255, 0));
                        gc:draw_line(POS2VEC(this.mouse_pos),
                                     _Vector2i(scroll.x,
                                               scroll.y),
                                     _Color(255, 0, 0));
                    end
                end
            end
        end
    with
        var bool was_empty = true;
            // having current_pingu&&? is not enough because it can die and 
            // clear the variable

        every SCREENMANAGER_UPDATE do
            var Position pos = Position(
                                global:world!:get_state().screen2world(POS2VEC(this.mouse_pos)).x,
                                global:world!:get_state().screen2world(POS2VEC(this.mouse_pos)).y
                               );

            var float min_dist = 500.0;
            var IPingu&&? cur;
            loop p in pingu_holder.pingus do
                if p:is_over((int)pos.x, (int)pos.y) then
                    var float dist = p:dist((int)pos.x, (int)pos.y);
                    if (dist < min_dist) then
                        min_dist = dist;
                        cur = p;
                    end
                end
            end

            var bool has_changed;
            if cur? then
                has_changed = was_empty or
                              (this.current_pingu? and (cur! != this.current_pingu!));
            else
                has_changed = (not was_empty);
            end

            this.current_pingu = cur;
            was_empty = (not cur?);
            if has_changed then
                emit this.ok_pingu;
            end
        end
    with
        every delta in SCREENMANAGER_UPDATE do
            if ({globals::auto_scrolling} and
                ({Display::is_fullscreen()} or 
                    _SDL_WM_GrabInput(_SDL_GRAB_QUERY) == _SDL_GRAB_ON))
            then
                var int scroll_speed = (int)(800 * delta);

                if (this.mouse_pos.x < 10) then
                    global:world!:get_state().set_pos(global:world!:get_state().get_pos() - _Vector2i(scroll_speed, 0));
                else/if (this.mouse_pos.x > {Display::get_width()} - 10) then
                    global:world!:get_state().set_pos(global:world!:get_state().get_pos() + _Vector2i(scroll_speed, 0));
                end

                if (this.mouse_pos.y < 10) then
                    global:world!:get_state().set_pos(global:world!:get_state().get_pos() - _Vector2i(0, scroll_speed));
                else/if (this.mouse_pos.y > {Display::get_height()} - 10) then
                    global:world!:get_state().set_pos(global:world!:get_state().get_pos() + _Vector2i(0, scroll_speed));
                end
            end
        end
    with
        // MUST BE UPDATED AFTER MYSELF

        var CaptureRectangle _ with
            this.playfield = &outer;
        end;
        await FOREVER;
    end

    /* PUBLIC */

    function (void)=>Vector2i get_pos do
        var Vector2i ret = Vector2i((int)(global:world!:get_state().get_pos().x),
                                    (int)(global:world!:get_state().get_pos().y));
        return ret;
    end

    function (int x, int y)=>void set_viewpoint do
        global:world!:get_state().set_pos(_Vector2i(x, y));
    end

    function (int x, int y)=>void scroll do
        global:world!:get_state().set_pos(global:world!:get_state().get_pos() + _Vector2i(x, y));
    end

    function (void)=>void update_layout do
        global:world!:get_state().set_size(this.rect.width, this.rect.height);
        global:world!:get_scene_context().set_rect(_Rect(this.rect.left,this.rect.top,this.rect.width,this.rect.height));
    end
end

#endif
