#ifndef _SMALLMAP_CEU
#define _SMALLMAP_CEU

native/pre do
    ##include "../src/engine/display/drawing_context.hpp"
    ##include "../src/engine/gui/component.hpp"
    using namespace GUI;
end
native @plain _DrawingContext;

#define AWAIT_MY(EVT,x,y)   \
    (x,y) = await EVT       \
            until (this.me.is_visible() and this.is_at(x,y))

class SmallMap with
    var _SmallMap& me;
    var PinguHolder& pingu_holder;
    var Rect rect;
do
    function (int x, int y)=>bool is_at;
    this.me.ceu = &&this;
_printf("SMALLMAP %p %p %p\n", _GLOBAL_SMALLMAP, &&this, &&this.rect);

    par do
        loop do
            var int x,y;
            AWAIT_MY(ON_PRIMARY_BUTTON_PRESSED,x,y);

            par/or do
                await ON_PRIMARY_BUTTON_RELEASED;
            with
                loop do
                    // set view to the given COs
                    var int cx, cy;
                    cx = (x - this.rect.left) *
                            ((int)global:world!:get_width()) /
                                this.rect.width;
                    cy = (y - this.rect.top) *
                            ((int)global:world!:get_height()) /
                                this.rect.height;
                    _GLOBAL_PLAYFIELD:set_viewpoint(cx, cy);
                    AWAIT_MY(ON_POINTER_MOVE,x,y);
                end
            end
        end
    with
        every gc in GUISCREEN_DRAW do
            var int of_x = _GLOBAL_PLAYFIELD:get_pos().x;
            var int of_y = _GLOBAL_PLAYFIELD:get_pos().y;
            {
                Rect view_rect;
            };

            if (global:world!:get_width() > gc:get_width()) then
                var int rwidth = (int)(gc:get_width() * this.rect.width
                                    / global:world!:get_width());
                _view_rect.left = this.rect.left
                                + (of_x * this.rect.width /
                                    global:world!:get_width())
                                - rwidth/2;
                _view_rect.right = _view_rect.left + rwidth;
            else
                _view_rect.left  = (int)this.rect.left;
                _view_rect.right = this.rect.left + this.rect.width;
            end

            if (global:world!:get_height() > gc:get_height()) then
                var int rheight = (int)(gc:get_height() * this.rect.height
                                    / global:world!:get_height());
                _view_rect.top = this.rect.top
                               + (of_y * this.rect.height
                                    / global:world!:get_height()) - rheight/2;
                _view_rect.bottom = _view_rect.top + rheight;
            else
                _view_rect.top    = (int)this.rect.top;
                _view_rect.bottom = this.rect.top + this.rect.height;
            end

            gc:draw(this.me, _Vector2i(0,0));

            gc:draw_rect(_view_rect, _Color(0, 255, 0));

            // Draw Pingus
            loop pingu in this.pingu_holder.pingus do
                var int x = (int)((float)(this.rect.left)
                          + (pingu:get_x() * (float)(this.rect.width)
                            / (float)(global:world!:get_width())));
                var int y = (int)((float)(this.rect.top)
                          + (pingu:get_y() * (float)(this.rect.height)
                            / (float)(global:world!:get_height())));
                gc:draw_line(_Vector2i(x, y), _Vector2i(x, y-2), _Color(255, 255, 
            0));
            end
        end
    end

    /* PIRVATE */

    function (int x, int y)=>bool is_at do
        return (x > this.rect.left and
                x < this.rect.left + (int)(this.rect.width) and
                y > this.rect.top and
                y < this.rect.top + (int)(this.rect.height));
    end
end

#endif
