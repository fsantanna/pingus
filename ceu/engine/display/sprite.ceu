#ifndef _SPRITE_PINGUS_CEU
#define _SPRITE_PINGUS_CEU

native/pre do
    ##include "engine/display/display.hpp"
    ##include "engine/display/framebuffer.hpp"
    ##include "engine/display/sdl_framebuffer_surface_impl.hpp"
    ##include "engine/display/sprite_description.hpp"
    ##define loop_ loop
    extern FramebufferSurface* load_framebuffer_sdl_surface(const Pathname& filename, ResourceModifier::Enum modifier);
end
native @plain _FramebufferSurface;

#include "surface.ceu"

class SpriteR with
    function (void)=>int get_current_frame;
    function (int)=>void set_frame;
    function (void)=>int get_frame_count;
    function (void)=>int get_width;
    function (void)=>int get_height;

    var bool is_world = true;

    var Rect&  rect;
    var Rect&? small_map;   // TODO

    var Vector2i offset      = Vector2i(0, 0);
    var Vector2i frame_pos   = Vector2i(0, 0);
    var Size     frame_size  = Size(0,0);
    var int      frame_delay = 0;
    var Size     array       = Size(0,0);
    var bool     is_loop     = false;
    var int      frame       = 0;

    // constructor
    var _Surface&&              surface = null;
    var _SpriteDescription&&    desc    = null;
    var _ResourceModifier__Enum mod     = {ResourceModifier::ROT0};
    var char&&                  name    = null;

    function (Rect& rect, @hold char&& name)=>SpriteR build_name;
    function (Rect& rect, @hold char&& name)=>SpriteR build_nameX;
do
    function (Rect& rect, @hold char&& name)=>SpriteR build_name do
        this.rect = &rect;
        this.name := name;
    end
    function (Rect& rect, @hold char&& name)=>SpriteR build_nameX do
        this.rect = &rect;
        this.name := name;
        this.is_world = false;
    end

    var Surface sfc with
        this.surface = surface;
        this.desc    = outer.desc;
        this.mod     = outer.mod;
        this.name    = name;
    end;

    this.rect.width  = sfc.get_width();
    this.rect.height = sfc.get_height();

    if surface != null then
        this.frame_pos   = Vector2i(0, 0);
        this.offset      = Vector2i(0, 0);
        this.array       = Size(sfc.get_width(), sfc.get_height());
        this.frame_delay = 0;
        this.frame_size  = this.array;
    else
        this.frame_pos   = Vector2i(sfc.desc:frame_pos.x, sfc.desc:frame_pos.y);
        this.array       = Size(sfc.desc:array.width, sfc.desc:array.height);
        this.frame_delay = sfc.desc:speed;
        this.is_loop     = sfc.desc:loop_;

        if sfc.desc:frame_size.width  == -1 then
            this.frame_size.width  = sfc.get_width()/array.width;
            this.frame_size.height = sfc.get_height()/array.height;
        else
            this.frame_size.width  = sfc.desc:frame_size.width;
            this.frame_size.height = sfc.desc:frame_size.height;
        end

        {
            Vector2i vec = calc_origin(THIS(CEU_SpriteR)->sfc.desc->origin,
                                       Size(THIS(CEU_SpriteR)->frame_size.width,
                                            THIS(CEU_SpriteR)->frame_size.height))
                            - THIS(CEU_SpriteR)->sfc.desc->offset;
        };
        this.offset = Vector2i(_vec.x, _vec.y);
    end
    //end

    var int total_time = this.frame_delay *
                         (this.array.width * this.array.height);

    this.frame = 0;

    var int tick_count = 0;

    par do
        /* UPDATE */
        loop do
            loop do
                var float dt;
                if this.is_world then
                    await WORLD_UPDATE;
                    dt = 0.033;   // TODO
                else
                    var int v = await DELTA;
                    dt = ((float)v)/1000;
                end
                if this.frame_delay == 0 then
                    await FOREVER;
                end

                tick_count = tick_count + (int)(dt * 1000);

                if tick_count >= total_time then
                    if this.is_loop then
                        tick_count = tick_count % total_time;
                        this.frame = tick_count / this.frame_delay;
                    end
                    break;
                else
                    this.frame = tick_count / this.frame_delay;
                end

            end
            if not this.is_loop then
                escape 0;
            end
        end
    with
        /* DRAW */
        every REDRAW do
            var int xx=0, yy=0;
            if this.is_world and global:world? then
                xx = global:world!:get_state().get_pos().x -
                     global:world!:get_state().get_width()/2;
                yy = global:world!:get_state().get_pos().y -
                     global:world!:get_state().get_height()/2;
            end

            var float x, y;
            if this.small_map? then
                x = (float)(this.small_map!.left) +
                        (this.rect.left * (float)(this.small_map!.width) /
                            (float)global:world!:get_width());
                y = (float)(this.small_map!.top) +
                        (this.rect.top * (float)(this.small_map!.height) /
                            (float)global:world!:get_height());
            else
                x = this.rect.left;
                y = this.rect.top;
            end

            call {Display::s_framebuffer}:draw_surface(
                this.sfc.get_framebuffer_surface(),
                _Rect(
                    _Vector2i(this.frame_pos.x,this.frame_pos.y) +
                        _Vector2i(this.frame_size.width  * (this.frame%this.array.width),
                                  this.frame_size.height * (this.frame/this.array.width)),
                    _Size(this.frame_size.width,this.frame_size.height)),
                _Vector2i(-xx + x - this.offset.x,
                          -yy + y - this.offset.y)
            );
        end
    end

    /* PUBLIC */

    function (void)=>int get_frame_count do
        return this.array.width * this.array.height;
    end

    function (void)=>int get_current_frame do
        return this.frame;
    end
    function (int frame)=>void set_frame do
        this.frame = frame;
    end

    function (void)=>int get_width do
        return this.frame_size.width;
    end
    function (void)=>int get_height do
        return this.frame_size.height;
    end
end

#endif
