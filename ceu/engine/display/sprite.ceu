#ifndef _SPRITE_PINGUS_CEU
#define _SPRITE_PINGUS_CEU

native/pre do
    ##include "engine/display/display.hpp"
    ##include "engine/display/framebuffer.hpp"
    ##include "engine/display/sdl_framebuffer_surface_impl.hpp"
    ##include "engine/display/sprite_description.hpp"
    ##define loop_ loop
    extern FramebufferSurface* load_framebuffer_sdl_surface(const Pathname& filename, ResourceModifier::Enum modifier);
end
native @plain _SpriteCeu;
native @plain _FramebufferSurface;

/// TODO: unify
input (int,int,_Framebuffer&&) WORLD_RENDER;
input (int,int,_Framebuffer&&) SMALLMAP_RENDER;

class Sprite with
    function (void)=>int get_current_frame;
    function (int)=>void set_frame;
    function (void)=>int get_frame_count;
    function (void)=>int get_width;
    function (void)=>int get_height;

    var bool is_world = true;

    var float& x;
    var float& y;

    var Vector2i offset      = Vector2i(0, 0);
    var Vector2i frame_pos   = Vector2i(0, 0);
    var Size     frame_size  = Size(0,0);
    var int      frame_delay = 0;
    var Size     array       = Size(0,0);
    var bool     is_loop     = false;
    var int      frame       = 0;

    var Rect&?   rect;      /// TODO: for smallmap

    // constructor
    var _Surface&&              surface = null;
    var _SpriteDescription&&    desc    = null;
    var _ResourceModifier__Enum mod     = {ResourceModifier::ROT0};
    var char&&                  name    = null;

    function (bool is_world, float& x, float& y, @hold char&& name)=>Sprite w_xy_name;
do
    function (bool is_world, float& x, float& y, @hold char&& name)=>Sprite w_xy_name do
        this.is_world = is_world;
        this.x        = &x;
        this.y        = &y;
        this.name     := name;
    end

    var _FramebufferSurface&? framebuffer_surface;
    //do
        if surface != null then
            finalize
                framebuffer_surface =
                    &{new FramebufferSurface}(
                        {new SDLFramebufferSurfaceImpl}(surface:get_surface()));
            with
                //_delete(&&framebuffer_surface!);
            end

            this.frame_pos   = Vector2i(0, 0);
            this.offset      = Vector2i(0, 0);
            this.array       = Size(surface:get_width(), surface:get_height());
            this.frame_delay = 0;
            this.frame_size  = this.array;
        else
            if name != null then
                desc = _Resource__load_sprite_desc(name);
            end
            _assert(desc != null);
            finalize
                framebuffer_surface =
                    &_load_framebuffer_sdl_surface(desc:filename, mod);
            with
                //_delete(&&framebuffer_surface!);
            end

            this.frame_pos   = Vector2i(desc:frame_pos.x, desc:frame_pos.y);
            this.array       = Size(desc:array.width, desc:array.height);
            this.frame_delay = desc:speed;
            this.is_loop     = desc:loop_;

            if desc:frame_size.width  == -1 then
                this.frame_size.width  = framebuffer_surface!.get_width()/array.width;
                this.frame_size.height = framebuffer_surface!.get_height()/array.height;
            else
                this.frame_size.width  = desc:frame_size.width;
                this.frame_size.height = desc:frame_size.height;
            end

            {
                Vector2i vec = calc_origin(THIS(CEU_Sprite)->desc->origin,
                                           Size(THIS(CEU_Sprite)->frame_size.width,
                                                THIS(CEU_Sprite)->frame_size.height))
                                - THIS(CEU_Sprite)->desc->offset;
            };
            this.offset = Vector2i(_vec.x, _vec.y);
        end
    //end

    var int total_time = this.frame_delay *
                         (this.array.width * this.array.height);

    this.frame = 0;

    var int tick_count = 0;

    par do
        /* UPDATE */
        loop do
            loop do
                await WORLD_UPDATE;
                if this.frame_delay == 0 then
                    await FOREVER;
                end

                var float dt = 0.033;   // TODO
                tick_count = tick_count + (int)(dt * 1000);

                if tick_count >= total_time then
                    if this.is_loop then
                        tick_count = tick_count % total_time;
                        this.frame = tick_count / this.frame_delay;
                    end
                    break;
                else
                    this.frame = tick_count / this.frame_delay;
                end

            end
            if not this.is_loop then
                escape 0;
            end
        end
    with
        /* RENDER */
        every (x0,y0,fb) in WORLD_RENDER do
            if not this.is_world then
                x0 = 0;
                y0 = 0;
            end
            var float xx, yy;
            if this.rect? then
                xx = (float)(this.rect!.left) +
                        (this.x * (float)(this.rect!.width) /
                            (float)global:world!:get_width());
                yy = (float)(this.rect!.top) +
                        (this.y * (float)(this.rect!.height) /
                            (float)global:world!:get_height());
            else
                xx = this.x;
                yy = this.y;
            end
            fb:draw_surface(framebuffer_surface!,
                _Rect(_Vector2i(this.frame_pos.x,this.frame_pos.y) +
                           _Vector2i(this.frame_size.width  * (this.frame%this.array.width),
                                     this.frame_size.height * (this.frame/this.array.width)),
                       _Size(this.frame_size.width,this.frame_size.height)),
                _Vector2i(x0+xx-this.offset.x,y0+yy-this.offset.y));
        end
    end

    /* PUBLIC */

    function (void)=>int get_frame_count do
        return this.array.width * this.array.height;
    end

    function (void)=>int get_current_frame do
        return this.frame;
    end
    function (int frame)=>void set_frame do
        this.frame = frame;
    end

    function (void)=>int get_width do
        return this.frame_size.width;
    end
    function (void)=>int get_height do
        return this.frame_size.height;
    end
end

#endif
