#ifndef _SPRITE_PINGUS_CEU
#define _SPRITE_PINGUS_CEU

native/pre do
    ##include "engine/display/display.hpp"
    ##include "engine/display/framebuffer.hpp"
    ##include "engine/display/sdl_framebuffer_surface_impl.hpp"
    ##include "engine/display/sprite_description.hpp"
    ##define loop_ loop
    extern FramebufferSurface* load_framebuffer_sdl_surface(const Pathname& filename, ResourceModifier::Enum modifier);
end
native/plain _FramebufferSurface;

#include "surface.ceu"

data Sprite with
    var Vector2i offset      = val Vector2i(0, 0);
    var Vector2i frame_pos   = val Vector2i(0, 0);
    var Size     frame_size  = val Size(0,0);
    var int      frame_delay = 0;
    var Size     array       = val Size(0,0);
    var bool     is_loop     = false;
    var int      frame       = 0;
end

code/await Sprite_from_name (var& Sprite sprite, var& Rect rect, var _char_const_ptr name) -> FOREVER do
    var& Surface sfc;
    spawn Surface_from_name(name, {ResourceModifier::ROT0}) -> (&sfc);

    sprite.frame_pos   = val Vector2i(sfc.desc:frame_pos.x, sfc.desc:frame_pos.y);
    sprite.array       = val Size(sfc.desc:array.width, sfc.desc:array.height);
    sprite.frame_delay = sfc.desc:speed;
    sprite.is_loop     = (sfc.desc:loop_ as bool);

    if sfc.desc:frame_size.width  == -1 then
        sprite.frame_size.width  = sfc.framebuffer.get_width()  / sprite.array.width;
        sprite.frame_size.height = sfc.framebuffer.get_height() / sprite.array.height;
    else
        sprite.frame_size.width  = sfc.desc:frame_size.width;
        sprite.frame_size.height = sfc.desc:frame_size.height;
    end

    native _vec;
    {
        static Vector2i vec;
        vec = calc_origin(@(sfc.desc:origin),
                          Size(@(sprite.frame_size.width),
                               @(sprite.frame_size.height)))
                - @(sfc.desc:offset);
    };
    sprite.offset = val Vector2i(_vec.x, _vec.y);

    /* DRAW */
    every SDL_REDRAW do
        var float x, y;
        x = rect.left;
        y = rect.top;

        var int xx=0, yy=0;
#if 0
        call {Display::s_framebuffer}:draw_surface(
                                        sfc.framebuffer,
                                        _Vector2i(x,y),
        );
#endif
        call {Display::s_framebuffer}:draw_surface(
            sfc.framebuffer,
            _Rect(
                _Vector2i(sprite.frame_pos.x,sprite.frame_pos.y) +
                    _Vector2i(sprite.frame_size.width  * (sprite.frame%sprite.array.width),
                              sprite.frame_size.height * (sprite.frame/sprite.array.width)),
                _Size(sprite.frame_size.width,sprite.frame_size.height)),
            _Vector2i(-xx + x - sprite.offset.x,
                      -yy + y - sprite.offset.y)
        );
    end
#if 0
    function (void)=>int get_current_frame;
    function (int)=>void set_frame;
    function (void)=>int get_frame_count;
    function (void)=>int get_width;
    function (void)=>int get_height;

    var bool is_world = true;   // TODO: rename to is_relative

    var Rect&? small_map;   // TODO

    var Vector2i offset      = Vector2i(0, 0);
    var Vector2i frame_pos   = Vector2i(0, 0);
    var Size     frame_size  = Size(0,0);
    var int      frame_delay = 0;
    var Size     array       = Size(0,0);
    var bool     is_loop     = false;
    var int      frame       = 0;

    // constructor
    var _Surface&&              surface = null;
    var _SpriteDescription&&    desc    = null;
    var _ResourceModifier__Enum mod     = {ResourceModifier::ROT0};

    function (Rect& rect, char&& name)=>Sprite build_name;
    function (Rect& rect, char&& name)=>Sprite build_nameX;
    function (int x, int y)=>void draw;
    function (Rect& rect, char&& name)=>Sprite build_name do
        this.rect = &rect;
        this.name = _XXX_PURE(name);
    end
    function (Rect& rect, char&& name)=>Sprite build_nameX do
        this.rect = &rect;
        this.name = _XXX_PURE(name);
        this.is_world = false;
    end

    var Surface sfc with
        this.surface = surface;
        this.desc    = outer.desc;
        this.mod     = outer.mod;
        this.name    = name;
    end;

    this.rect.width  = sfc.get_width();
    this.rect.height = sfc.get_height();

    if surface != null then
        this.frame_pos   = Vector2i(0, 0);
        this.offset      = Vector2i(0, 0);
        this.array       = Size(sfc.get_width(), sfc.get_height());
        this.frame_delay = 0;
        this.frame_size  = this.array;
    else
        this.frame_pos   = Vector2i(sfc.desc:frame_pos.x, sfc.desc:frame_pos.y);
        this.array       = Size(sfc.desc:array.width, sfc.desc:array.height);
        this.frame_delay = sfc.desc:speed;
        this.is_loop     = sfc.desc:loop_;

        if sfc.desc:frame_size.width  == -1 then
            this.frame_size.width  = sfc.get_width()/array.width;
            this.frame_size.height = sfc.get_height()/array.height;
        else
            this.frame_size.width  = sfc.desc:frame_size.width;
            this.frame_size.height = sfc.desc:frame_size.height;
        end

        {
            Vector2i vec = calc_origin(THIS(CEU_Sprite)->sfc.desc->origin,
                                       Size(THIS(CEU_Sprite)->frame_size.width,
                                            THIS(CEU_Sprite)->frame_size.height))
                            - THIS(CEU_Sprite)->sfc.desc->offset;
        };
        this.offset = Vector2i(_vec.x, _vec.y);
    end
    //end

    var int total_time = this.frame_delay *
                         (this.array.width * this.array.height);

    this.frame = 0;

    var int tick_count = 0;

    par do
        /* UPDATE */
        loop do
            loop do
                var float dt;
                if this.is_world and global:world? then
                    await WORLD_UPDATE;
                    dt = 0.033;   // TODO
                else
                    var int v = await DELTA;
                    dt = ((float)v)/1000;
                end
                if this.frame_delay == 0 then
                    await FOREVER;
                end

                tick_count = tick_count + (int)(dt * 1000);

                if tick_count >= total_time then
                    if this.is_loop then
                        tick_count = tick_count % total_time;
                        this.frame = tick_count / this.frame_delay;
                    end
                    break;
                else
                    this.frame = tick_count / this.frame_delay;
                end

            end
            if not this.is_loop then
                escape 0;
            end
        end
    with
        /* DRAW */
        every REDRAW do
            var float x, y;
            if this.small_map? then
                x = (float)(this.small_map!.left) +
                        (this.rect.left * (float)(this.small_map!.width) /
                            (float)global:world!:get_width());
                y = (float)(this.small_map!.top) +
                        (this.rect.top * (float)(this.small_map!.height) /
                            (float)global:world!:get_height());
            else
                x = this.rect.left;
                y = this.rect.top;
            end

            this.draw(x, y);
        end
    end

    /* PUBLIC */

    function (void)=>int get_frame_count do
        return this.array.width * this.array.height;
    end

    function (void)=>int get_current_frame do
        return this.frame;
    end
    function (int frame)=>void set_frame do
        this.frame = frame;
    end

    function (void)=>int get_width do
        return this.frame_size.width;
    end
    function (void)=>int get_height do
        return this.frame_size.height;
    end
    function (int x, int y)=>void draw do
        var int xx=0, yy=0;
        if this.is_world then
            xx = global:offset.x;
            yy = global:offset.y;
        end

        call {Display::s_framebuffer}:draw_surface(
            this.sfc.framebuffer_surface,
            _Rect(
                _Vector2i(this.frame_pos.x,this.frame_pos.y) +
                    _Vector2i(this.frame_size.width  * (this.frame%this.array.width),
                              this.frame_size.height * (this.frame/this.array.width)),
                _Size(this.frame_size.width,this.frame_size.height)),
            _Vector2i(-xx + x - this.offset.x,
                      -yy + y - this.offset.y)
        );
    end
#endif
end

#endif
