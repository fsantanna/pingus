#ifdef _SPR_CEU
#error multiple include
#else
#define _SPR_CEU __FILE__

data ISpr with
    var Vector2i offset      = val Vector2i(0, 0);
    var Vector2i frame_pos   = val Vector2i(0, 0);
    var Size     frame_size  = val Size(0,0);
    var int      frame_delay = 0;
    var Size     array       = val Size(0,0);
    var bool     is_loop     = false;
    var int      frame       = 0;
end

#if 0
code/tight Get_Frame_Count (var& ISpr sprite) -> int do
    escape sprite.array.width * sprite.array.height;
end
#endif

code/await Spr_from_sfc (var& Rct rct, var& Surface sfc, event& int dt, event& void redraw)
                                -> (var ISpr sprite)
                                    -> void
do
    sprite = val ISpr(
        _,
        Vector2i(sfc.desc:frame_pos.x, sfc.desc:frame_pos.y),
        _,
        sfc.desc:speed,
        Size(sfc.desc:array.width, sfc.desc:array.height),
        (sfc.desc:_loop as bool),
        _,
    );

    sprite.frame_pos   = val Vector2i(sfc.desc:frame_pos.x, sfc.desc:frame_pos.y);
    sprite.array       = val Size(sfc.desc:array.width, sfc.desc:array.height);
    sprite.frame_delay = sfc.desc:speed;
    sprite.is_loop     = sfc.desc:_loop as bool;

    if sfc.desc:frame_size.width  == -1 then
        sprite.frame_size.width  = sfc.framebuffer.get_width()  / sprite.array.width;
        sprite.frame_size.height = sfc.framebuffer.get_height() / sprite.array.height;
    else
        sprite.frame_size.width  = sfc.desc:frame_size.width;
        sprite.frame_size.height = sfc.desc:frame_size.height;
    end
    rct.w = sprite.frame_size.width;
    rct.h = sprite.frame_size.height;

    {
        static Vector2i vec;
        vec = calc_origin(@(sfc.desc:origin),
                          Size(@(sprite.frame_size.width),
                               @(sprite.frame_size.height)))
                - @(sfc.desc:offset);
    };
    sprite.offset = val Vector2i({vec.x}, {vec.y});

    var int total_time = sprite.frame_delay *
                         (sprite.array.width * sprite.array.height);

    sprite.frame = 0;

    var int tick_count = 0;

    par do
        /* UPDATE */
        loop do
            loop do
                var int v = await dt;
                if sprite.frame_delay == 0 then
                    await FOREVER;
                end

                tick_count = tick_count + v;

                if tick_count >= total_time then
                    if sprite.is_loop then
                        tick_count = tick_count % total_time;
                        sprite.frame = tick_count / sprite.frame_delay;
                    end
                    break;
                else
                    sprite.frame = tick_count / sprite.frame_delay;
                end
            end
            if not sprite.is_loop then
                escape;
            end
        end
    with
        /* DRAW */
        every redraw do
            var Rct r = _;
            call/recursive Rct_Off(&rct, &r);
#if 0
            call {Display::s_framebuffer}:draw_surface(
                                            sfc.framebuffer,
                                            _Vector2i(x,y),
            );
#endif
            call {Display::s_framebuffer}:draw_surface(
                sfc.framebuffer,
                _Rect(
                    _Vector2i(sprite.frame_pos.x,sprite.frame_pos.y) +
                        _Vector2i(sprite.frame_size.width  * (sprite.frame%sprite.array.width),
                                  sprite.frame_size.height * (sprite.frame/sprite.array.width)),
                    _Size(sprite.frame_size.width,sprite.frame_size.height)),
                _Vector2i(r.x - sprite.offset.x,
                          r.y - sprite.offset.y)
            );
        end
    end
end

#if 0
    var bool is_world = true;   // TODO: rename to is_relative
    var Rect&? small_map;   // TODO
    // constructor
    var _Surface&&              surface = null;
    var _SpriteDescription&&    desc    = null;
    var _ResourceModifier__Enum mod     = {ResourceModifier::ROT0};

    if surface != null then
        this.frame_pos   = Vector2i(0, 0);
        this.offset      = Vector2i(0, 0);
        this.array       = Size(sfc.get_width(), sfc.get_height());
        this.frame_delay = 0;
        this.frame_size  = this.array;
    else
...
    end
    //end

/* PUBLIC */

function (void)=>int get_current_frame do
    return this.frame;
end
function (int frame)=>void set_frame do
    this.frame = frame;
end

function (void)=>int get_width do
    return this.frame_size.width;
end
function (void)=>int get_height do
    return this.frame_size.height;
end
#endif

code/await Spr_from_desc (var& Rct rct, var _SpriteDescription_ptr desc, event& int dt, event& void redraw)
                                -> (var& ISpr sprite)
                                    -> void
do
    var& Surface_from_desc sfc_from_desc =
        spawn Surface_from_desc(desc, {ResourceModifier::ROT0});

    var& Surface sfc = &sfc_from_desc.surface;
    var&? Spr_from_sfc s = spawn Spr_from_sfc(&rct, &sfc, &dt, &redraw);
    watching s do
        sprite = &s!.sprite;
        await FOREVER;
    end
end

code/await Spr_from_name (var& Rct rct, var _char_const_ptr name, event& int dt, event& void redraw)
                                -> (var& ISpr sprite)
                                    -> void
do
    var& Surface_from_name sfc_from_name =
        spawn Surface_from_name(name, {ResourceModifier::ROT0});

    var& Surface sfc = &sfc_from_name.surface;
    var&? Spr_from_sfc s = spawn Spr_from_sfc(&rct, &sfc, &dt, &redraw);
    watching s do
        sprite = &s!.sprite;
        await FOREVER;
    end
end

#endif
