<p><head>
    <title>Francisco Sant&#39;Anna</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</head></p>

<h1>What?</h1>

<p>This report documents the process of porting the video game
Pingus (<a href="http://pingus.seul.org/">1</a>
        <a href="https://github.com/Pingus/pingus">2</a>)
from C++ to the programming language
Céu (<a href="http://ceu-lang.org/">1</a>
     <a href="https://github.com/fsantanna/ceu">2</a>).</p>

<p><img src="pingus-1.png" width="50%"/>
<img src="pingus-2.png" width="50%"/></p>

<h1>Why?</h1>

<p>In order of importance, these are the motivations to port Pingus to Céu:</p>

<ol>
<li>Advocate the programming model of Céu in the context of video games.
Céu provides concurrent and deterministic abstractions for applications 
with a high degree of synchronization such as video games.</li>
<li>Expose Céu to a real (somewhat big) code base that was neither specified nor 
implemented by the designers of language.
Céu is an academic &quot;toy&quot; language, in the sense that its main motivation is 
to propose new ideas to the community.
Even if video games match the purpose of Céu, a real-world project consits 
of a range of (sometimes conflicting) requirements, forcing us to transpose
the &quot;academic fences&quot; of papers which only explore and discuss idiomatic
code.</li>
<li>Exercise the interface between Céu and C/C++.
Céu was designed to integrate seamlessly with C.
This allowed us to perform a <em>live porting</em>, i.e., we incrementally ported 
code from C++ to Céu without breaking the game for long.</li>
<li>Stress-test the implementation of Céu.
Academic artifacts typically do not go beyond a working prototype.
We also want it to be a robust and practical language for everyday use.</li>
<li>Evaluate the performance of Céu.
Having C++ as a reference, how does Céu compare in terms of memory usage, 
code size, and execution time (e.g., FPS rate)?</li>
</ol>

<!--
- GOALS: stress-test the language
    - robustness
        - silly bugs (untested stuff)
    - programability
        - everyday stuff
            - maths, vectors
    - performance
        - FPS, RAM, ROM
    - false positives (too much?)
        - tight loops
    - C tricks: {}, _XXX, etc
-->

<h1>How?</h1>

<h2>Warming Up!</h2>

<p><img src="double-click-opt.gif" align="right" valign="top"/></p>

<p>Let&#39;s consider the case of handling double clicks.</p>

<p>In Pingus, double clicking the <em>Armageddon</em> button in under 1 second literally 
all pingus, as illustrated in the figure in the right.</p>

<p>The code in C++ (<a href="https://github.com/fsantanna/pingus/blob/master/src/pingus/components/action_button.cpp">1</a>) uses the class <code>ArmageddonButton</code> which 
extends <code>RectComponent</code> with custom rendering and event-handling methods.
Below, we show only the parts related to detect a double click on the button:</p>

<p>```C++
ArmageddonButton::ArmageddonButton(Server* s, int x, int y) :
    RectComponent(Rect(Vector2i(x, y), Size(38, 60))),
    pressed(false);
    &lt;...&gt;
{
    &lt;...&gt;
}</p>

<p>void ArmageddonButton::draw (DrawingContext&amp; gc) {
    &lt;...&gt;
}</p>

<p>void ArmageddonButton::update (float delta) {
    &lt;...&gt;
    if (pressed) {
        press<em>time += delta;
        if (press</em>time &gt; 1.0f) {
            press<em>time = 0;
            pressed = false;
        }
    } else {
        pressed = false;
        press</em>time = 0;
    }
}</p>

<p>void ArmageddonButton::on<em>primary</em>button<em>click (int x, int y) {
    if (pressed) {
        server-&gt;send</em>armageddon_event();
    } else {
        pressed = true;
    }
}
```</p>

<p>The class uses the variable <code>pressed</code> (ln. X) to remember the first click (ln. 
X).
If another click doesn&#39;t occur within 1 second, the variable is reset (ln. X).
Otherwise, the class signals the double click to the application (ln. X).
Even though the variable <code>pressed</code> is private, unrelated methods, such as 
<code>draw</code>, can potentially access it.
Also, the accesses are spread across the class definition in multiple methods.
For instance, the distance between the declaration (ln. X) and the last access 
(ln. X) is over X lines, making the understanding and maintenance of the 
pattern more difficult.</p>

<p>The code in Céu (<a href="ceu-armageddon">1</a>) defines the class <code>ArmageddonButton</code> as 
follows:</p>

<pre><code>class ArmageddonButton with
    var Rect&amp; rect;
do
    this.rect.left = 38;
    this.rect.top  = 60;
    var RectComponent component = RectComponent.build(&amp;this.rect);
    &lt;...&gt;
    loop do
        await component.on_primary_button_click;
        watching 1s do
            await component.on_primary_button_click;
            break;
        end
    end
    &lt;...&gt;
    emit global:go_armageddon;
end
</code></pre>

<p>Besides methods (not used above), classes in Céu can have an execution body 
that reacts events.
The double click detection is a <code>loop</code> (ln. X-Y) that awaits the first click 
(ln. X) and then, watching 1 second (ln. X-Y), awaits the second click.
If the second click occurs within 1 second, we <code>break</code> the (ln. X) and signal 
the double click to the application.
Otherwise, the <code>watching</code> block as a whole aborts and restarts the loop, 
falling back to the first click await.
The double click detection in Céu doesn&#39;t require an extra state variable and 
is self-contained in the <code>loop</code> (ln. X-Y), describing the pattern with 
appropriate control-flow mechanisms (e.g., <code>await</code> and <code>watching</code>).</p>

<p>We believe that some difficulties in implementing control patterns in games is 
not inherent to the domain, but are the result of accidental complexity due to 
the use of bad (or the lack of) programming models to handle events 
concurrently.</p>

<p>In this report, we describe 6 recurrent patterns found in Pingus and discuss 
the differences in their implementations in C++ and Céu:</p>

<ol>
<li><p>State Machines
State machines is a form of expressing XXX through data</p>

<ul>
<li>state machines vs await</li>
</ul></li>
<li><p>Dispatching Hierarchies</p>

<ul>
<li>class hierarchies/dispatching vs await</li>
<li>lexical scope</li>
</ul></li>
<li><p>Continuation Passing</p>

<ul>
<li>CPS vs return continue

<ul>
<li>screen trasnitions</li>
<li>story screen advancing</li>
<li>story screen -&gt; credits screen</li>
<li>worse w/o closures</li>
</ul></li>
</ul></li>
<li><p>Signaling</p></li>
</ol>

<pre><code>- signaling/f pointer vs events
    - option save on click
    - global events double direction
        - key/mouse-but events
            - sendo que but tem que ficar highlight ou nao
    - verificar caso do option_menu
        - configuracao pode ser alterada por fora?
    - worse w/o closures
</code></pre>

<ol>
<li><p>Timers</p>

<ul>
<li>wall-clock time

<ul>
<li>story chars</li>
<li>credits up</li>
<li>fps</li>
</ul></li>
</ul></li>
<li><p>Pausing</p>

<ul>
<li>pause

<ul>
<li>alternative is again hierarchies which enable/disable forwarding</li>
</ul></li>
</ul></li>
</ol>

<h2>The Synchronous Concurrency Model</h2>

<h2>Céu</h2>

<ul>
<li>control
= Accidental complexity</li>
<li><p>not pure functions</p></li>
<li><p>end of document</p>

<ul>
<li>GC, why gcc doesn&#39;t solve: lapsed listeners

<ul>
<li>static mem, orgs, aliases, lexical scope</li>
</ul></li>
<li>GC also doesn&#39;t solve resources:
Garbage collecting resources (file handles, etc):</li>
</ul></li>
</ul>

<p>This is a very different question, because resource freeing has observable consequences beyond performance and memory consumption -- unlike garbage collection, which is justified by the realization that if you don&#39;t have any pointers to a value in memory, then it can simply dissapear (or not) without observable consequences.</p>

<p>For example, if you have a file handle open for writing, then other applications can&#39;t open that file. You want such resource usage to be clear and deterministic, so that files don&#39;t just remain open for a random duration depending on the garbage collector&#39;s internals.</p>

<p>In general, I would not advocate garbage collection of OS resources or any other thing requiring explicit cleanup. For example, I think that Java/C# finalizers are a misguided idea, because they have observable, nondeterministic consequences. That is exactly the sort of feature a high-level, secure language should avoid. The bizarre finalization state diagrams for those languages should be enough to indicate that something is wrong here!</p>

<p>For resource freeing, constructs which guarantee that every resource is freed look promising (think of wrapping a file handle in an abstraction like a Haskell State monad). Or just plain old handles with explicit closing (and thus the risk of not closing a handle, closing it when it&#39;s not open, etc).</p>

<p>Garbage collection without type information?</p>

<p>C++ garbage collection would greatly benefit if it was assisted by the compiler. During a scan, only pointers to objects need to be scanned. Unfortunately, it is not possible without assistance from the compiler. That is the reason third-party solutions are not good enough for performance-intensive applications.</p>

<p>Memory management and resource management is not the same. Resources other than memory are usually few in a program and not interconnected. A program may have files, sockets, windows and other types of handles, but usually these handles are &#39;dead ends&#39;, i.e. they do not contain references to other handles. Memory, on the other hand, is a totally different beast: a block of memory usually contains references to other blocks of memory. So the idea of finalizers is a bad one, since resources other than memory should be freed by RAII techniques (for deterministic resource management), but memory should be handled by garbage collector.</p>

<p>I will say it again, because no one seemed to notice it: could it be that there exists a &quot;calculus&quot; for resource management?
By Achilleas Margaritis at Fri, 2006-02-03 11:46 | login or register to post comment</p>

<h2>Idioms</h2>

<h3>State Machines</h3>

<pre><code>- state machines vs await
</code></pre>

<h3>Hierarchies</h3>

<pre><code>- class hierarchies/dispatching vs await
</code></pre>

<h3>Continuations</h3>

<pre><code>- CPS vs return continue
    - screen trasnitions
    - story screen advancing
    - story screen -&gt; credits screen
    - worse w/o closures
</code></pre>

<h3>Signaling</h3>

<pre><code>- signaling/f pointer vs events
    - option save on click
    - global events double direction
        - key/mouse-but events
            - sendo que but tem que ficar highlight ou nao
    - verificar caso do option_menu
        - configuracao pode ser alterada por fora?
    - worse w/o closures
</code></pre>

<h3>Wall-Clock Time</h3>

<pre><code>- wall-clock time
    - story chars
    - credits up
    - fps
</code></pre>

<h3>Pausing</h3>

<pre><code>- pause
    - alternative is again hierarchies which enable/disable forwarding
</code></pre>

<h1>Evaluation</h1>

<ul>
<li>DOC: two main points:
= WHY
    - state machines
    - C libraries
    - static memory
    - control safety
= WHY NOT
    - functional, immutability
    - type safety
    - generic code
    - tooling
= BOUNS: Lua</li>
</ul>

<h2>The Code Base</h2>

<p>Pingus has a code base around 40k lines of code (LoC):</p>

<pre><code>&gt; cd pingus/src/
&gt; sloccount .
...
SLOC    Directory   SLOC-by-Language (Sorted)
18173   pingus          cpp=18173
10073   engine          cpp=10073
6532    editor          cpp=6532
2771    util            cpp=2771
1138    math            cpp=1138
679     lisp            cpp=679
365     win32           ansic=365
248     macosx          objc=248
7       top_dir         cpp=7
</code></pre>

<p>The code base includes a game engine, utilities, level editor, platform stubs, 
and the game logic.
Most of the porting process centered around the <code>engine</code> and <code>pingus</code> 
directory, as we did not port the level editor:</p>

<p>SLOC    Directory   SLOC-by-Language (Sorted)
6844    top_dir         cpp=6844
3045    screens         cpp=3045
2354    worldmap        cpp=2354
2118    worldobjs       cpp=2118
1838    actions         cpp=1838
1338    components      cpp=1338
531     particles       cpp=531
64      colliders       cpp=64
41      movers          cpp=41</p>

<p>SLOC    Directory   SLOC-by-Language (Sorted)
4666    display         cpp=4666
3617    input           cpp=3617
621     gui             cpp=621
603     screen          cpp=603
410     sound           cpp=410
109     resource        cpp=109
47      system          cpp=47</p>

<p>Most of</p>

<p><code>engine/</code>, a level <code>editor/</code></p>

<p>Total Physical Source Lines of Code (SLOC)                = 39,986</p>

<p>The next Mainstream Programming Language, slides for his invited talk at POPL 2006
Video game programming has a
entities have a high degree of interdependence
current abstractions impose a high degree of accidental complexity</p>

<p>More concretely</p>

<ul>
<li>BUG: a cada reinicio, o dobro de pingus sao criados</li>
<li>BUG: is_world=false in sprite.ceu</li>
<li>BUG: cliques nos pingus</li>
<li>BUG: bg do pingu counter fixo</li>
<li>BUG: small map esta atras da agua embaixo do level snow20</li>
<li>BUG: queda do pingu saindo da entrada esta levemente desalinhado</li>
<li>BUG: glitch periodico no smallmap relacionado ao RENDER</li>
<li>BUG: pequeno glitch no smallmap no inicio da fase</li>
<li>BUG: procurar /// TODO: w/o me.ceu this function becomes @rec</li>
<li>z-order front entrance snow-tutorial</li>
<li>TODO: pos_offset em todos os objs em factory</li>
<li>front entrance atras do pingu</li>
<li>color.a em surface_background.ceu</li>
<li>idle laser_exit</li>
<li>EXIT/LASER_EXIT pega somente 1 de cada vez

<ul>
<li>verificar se o loop nao deveria pegar varios</li>
</ul></li>
<li>cache de sprites ou performance inviavel</li>
<li>EXITER/LASERKILL in pingu.ceu</li>
<li>BUG: climber center</li>
<li>global:world.pingus vai simplificar min.ceu</li>
<li>bug do WORLD_UPDATE necessario</li>
<li>pingu! = &lt;...&gt;</li>
<li>world! = &lt;...&gt;</li>
<li>countdown action disable from the original??</li>
<li>walker behind all</li>
<li>bridger offset</li>
<li>rename SpritePingus =&gt; Sprite</li>
<li>testar climber, wall-mode-activation</li>
<li>testar previous action: Climber-&gt;Jumper-&gt;direction-change/Blocker-&gt;Faller-&gt;Blocker</li>
<li>SDL_DT p/ pingus/actions/sprites</li>
</ul>

<h1>Who?</h1>

<h1>When?</h1>

<h1>PORTING</h1>

<p>```
native/pre do
    ##include &quot;../src/engine/display/sprite.hpp&quot;
end
native @plain _SpriteImpl;</p>

<p>input <em>SpriteImpl&amp;&amp; SPRITE</em>IMPL<em>NEW;
input _SpriteImpl&amp;&amp; SPRITE</em>IMPL_DELETE;</p>

<p>class SpriteImpl with
    var <em>SpriteImpl&amp; me;
do
    par/or do
        var _SpriteImpl&amp;&amp; me</em> = await SPRITE<em>IMPL</em>DELETE
                                until me_ == &amp;&amp;this.me;
    with
        &lt;...&gt;
    end
end</p>

<p>class SpriteImplFactory with
do
    every me_ in SPRITE<em>IMPL</em>NEW do
        spawn SpriteImpl with
            this.me = &amp;<em>XXX</em>PTR2REF(me_);
        end;
    end
end</p>

<p>var SpriteImplFactory _;
```</p>

<h1>RESULTS</h1>

<p>```</p>

<h2>CPP</h2>

<blockquote>
<p>cd /tmp/cmp/cpp/
sloccount .
    2087
cd /tmp/cmp/
sloccount all.cpp
    1611
cd /tmp/cmp/
wc all.cpp
    2370</p>
</blockquote>

<h2>CEU</h2>

<blockquote>
<p>wc all.ceu
    1476</p>
</blockquote>

<h2>ALL_CLEAR.CPP</h2>

<ul>
<li>namespaces</li>
<li>comments</li>
<li>blank lines</li>
<li>includes</li>
<li>one-line empty methods</li>
</ul>

<p>-
void
Basher::update ()
{
    ...
}</p>

<p>void Basher::update () {
    ...</p>

<h2>}</h2>

<p>if (x)
{
    ...
}
else
{
    ...
}
if (x)
    ...
else
    ...</p>

<p>if (x) {
    ...
} else {
    ...
}</p>

<p>======</p>

<ul>
<li>native</li>
<li>#ifdef FILE</li>
<li>defines</li>
</ul>

<h2>- interfaces/class with ... do</h2>

<p>{
    tp C;
}
==&gt;
{ tp C; }</p>
