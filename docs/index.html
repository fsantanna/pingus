<head>
<title>
Structured Synchronous Reactive Programming for Game Development --- Case Study: On Rewriting Pingus from C++ to Céu
</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style>
    body {
        width:950px;
        margin:0 auto;
        text-align: justify;
        text-justify: inter-word;
    }
    pre {
        padding: 10px 10px 10px 10px;
        background-color: #E5E4E2;
    }
    code {
        background-color: #E5E4E2;
    }
    div.images {
        float: right;
        clear: right;
        background-color: #ffffff;
        border: 1px solid black;
        padding: 10px;
        margin: 0 0 5px 10px;
/*
        width: 120px;
*/
        text-align: center;
    }
    div.box {
        float: right;
        background-color: #ffffff;
        border: 1px solid black;
        padding: 10px;
        margin: 0 0 5px 10px;
        display: inline-block;
        width: 400px;
    }
    div.summary {
        background-color: #FFCCCC;
        border: 1px solid black;
        padding: 5px;
    }
</style>
</head>
<body>
<!--
silentcast, transparent window interior, dont go under the default size
convert credits-anim.gif -fuzz 10% -layers Optimize optimised.gif
convert -delay 200 -loop 0 *.png state-anim.gif
:%s/\(\[X]\[[^]]*\]\)/\&#91;\1\&#93;/g
chico@note:/opt/pingus/ceu$ lua md-macros.lua README.md > /tmp/README.md
chico@note:/opt/pingus/ceu$ pandoc /tmp/README.md >README.html 
key-mon --noshift --noalt

* TODO
    * events before signalling
    - 2 casos p/ cada pattern
        - pause: pause/if e o nao gerar evento
        - hier: adicionar resize

TODO:
    - TARGET AUDIENCE
        - game developers that have faced these problems before

TODO:
    - ver os patterns do GPP
        - nao cubro algum que ocorre no pingus?
        - cubro algum com nome diferente?
        - cubro algum que o GPP nao cobre?
    - hierarchy
        - exemplo de z-order lexico em vez de dinamico

TODO:
    - only control flow advances
        - no type inference
        - no GC
        - no functional compositions
        - no data abstraction
        - no rearrange of overall arch

- GOALS: stress-test the language
    - robustness
        - silly bugs (untested stuff)
    - programability
        - everyday stuff
            - maths, vectors
    - performance
        - FPS, RAM, ROM
    - false positives (too much?)
        - tight loops
    - C tricks: {}, _XXX, etc

- TODO: threads, lua

- compare to actors
    - parallel, synchronous-run-to-completion
    - not a loop+queue
-->
<h1 id="structured-synchronous-reactive-programming-for-game-development-----case-study-on-rewriting-pingus-from-c-to-céu">Structured Synchronous Reactive Programming for Game Development --- Case Study: On Rewriting Pingus from C++ to Céu</h1>
<!--
* [What](#what-is-this-all-about),
  [Why](#why-rewrite-pingus-to-céu),
  [How](#how-to-rewrite),
  [Who](#who)?
* Analysis: [Qualitative](#qualitative-analysis),
            [Quantitative](#quantitative-analysis)

* [TLDR!](#tldr!)
    - did you do a complete port?
    - why is this cool?
    - ok, but with which gains in productivity?
    - what about CPU,ROM,RAM?
-->
<h2 id="introduction">Introduction</h2>
<!--
This report documents the process of rewriting the video game
Pingus from C++ to Céu.
-->
<!--
<img src="images/pingus-1.png" align="right" width="400"/>
<img src="images/pingus-2.png" align="right" width="400"/>
-->
<div class="images">
<img src="images/pingus-2.png" width="350"/> <br> <a href="images/pingus-2.png"> Figure 1</a>: Pingus gameplay
</div>
<p>Pingus [<a href="http://pingus.seul.org/"><img src="images/link_12.png" alt="X" /></a>] is an open-source [<a href="https://github.com/Pingus/pingus/"><img src="images/link_12.png" alt="X" /></a>] clone of Lemmings [<a href="https://en.wikipedia.org/wiki/Lemmings_(video_game)"><img src="images/link_12.png" alt="X" /></a>], a puzzle-platformer video game.<br />
The objective of the game is to guide a group of penguins through a number of obstacles towards a designated exit [<a href="https://www.youtube.com/watch?v=MKrJgIFtJX0"><img src="images/link_12.png" alt="X" /></a>].</p>
<p>Pingus is developed in standard object-oriented C++, the <em>lingua franca</em> of game development [<a href="http://gameprogrammingpatterns.com/introduction.html#about-the-sample-code"><img src="images/link_12.png" alt="X" /></a>]. The codebase is about 40.000 lines of code (LoCs) [<a href="https://github.com/Pingus/pingus/tree/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src"><img src="images/link_12.png" alt="X" /></a>], divided into the engine, level editor, auxiliary libraries, and the game logic itself.</p>
<!--
    I chose C++ for a couple of reasons. First, it’s the most popular language
    for commercially shipped games.
    It is the lingua franca of the industry.
    Moreso, the C syntax that C++ is based on is also the basis for Java, C#,
    JavaScript, and many other languages.
    Even if you do not know C++, the odds are good you can understand the code
    samples here with a little bit of effort.
-->
<p>Céu [<a href="http://ceu-lang.org/"><img src="images/link_12.png" alt="X" /></a>,<a href="https://github.com/fsantanna/ceu/"><img src="images/link_12.png" alt="X" /></a>] is a programming language that aims to offer a concurrent and expressive alternative to C/C++ with the characteristics that follow:</p>
<ul>
<li><em>Reactive:</em> code only executes in reactions to events.</li>
<li><em>Structured:</em> programs use structured control mechanisms, such as <code>await</code> (to suspend a line of execution), and <code>par</code> (to combine multiple lines of execution).</li>
<li><em>Synchronous:</em> reactions run atomically and to completion on each line of execution, i.e., there's no implicit preemption or real parallelism.</li>
</ul>
<p>Structured programming eliminates the <em>callback hell</em> [<a href="http://callbackhell.com/"><img src="images/link_12.png" alt="X" /></a>], letting programmers write code in <a href="https://en.wikipedia.org/wiki/Direct_style">direct/sequential style</a>. <!-- in multiple lines of execution.--> <!--
In addition, when a line of execution is aborted, all allocated resources
inside it are safely released.
--> Céu supports logical parallelism with a resource-efficient implementation in terms of memory and CPU usage. The runtime is single threaded and the language requires no garbage collection.</p>
<div class="images">
<img src="images/sweeney.png" width="350"/> <br> <a href="images/sweeney.png"> Figure 2</a>: Three kinds of code
</div>
<p>According to Tim Sweeney (of Unreal Engine fame), about half the complexity in game development resides in <em>simulation</em> (aka <em>game logic</em>), but which accounts for only 10% of the CPU budget [<a href="https://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt"><img src="images/link_12.png" alt="X" /></a>]. <!-- the way entities interact in real time --> The game logic &quot;models the state of the game world as interacting objects evolve over time&quot;. The high development costs contrasting with the low impact on performance appeals for alternatives with productivity in mind, especially considering that it is the game logic that varies the most between projects. Sweeney states that &quot;will gladly sacrifice 10% of our performance for 10% higher productivity&quot;.</p>
<!--
When updating 10,000 objects at 60 FPS, everything is performance-sensitive
But:
Productivity is just as important
Will gladly sacrifice 10% of our performance
for 10% higher productivity
We never use assembly language

Gameplay Simulation
Gratuitous use of mutable state
10,000’s of objects must be updated
Typical object update touches 5-10 other objects

This is the hardest problem…
10,00’s of objects
Each one contains mutable state
Each one updated 30 times per second
Each update touches 5-10 other objects
 
Manual synchronization (shared state concurrency) is 
hopelessly intractible here.
 
Solutions?
Rewrite as referentially-transparent functions?
Message-passing concurrency?
Continue using the sequential, single-threaded approach?

Update all objects concurrently in arbitrary order, with each update wrapped in 
an atomic {...} block.
With 10,000’s of updates, and 5-10 objects touched per update, collisions will 
be low.
~2-4X STM performance overhead is acceptable:
if it enables our state-intensive code to scale to many threads, it’s still a win

Claim: Transactions are the only plausible solution to concurrent mutable state
-->
<p>The main motivation for rewriting Pingus to Céu is to suggest structured synchronous reactive programming as an expressive and productive alternative for game logic development. In Pingus, the game logic also accounts for almost half the size of the codebase (18.173 from 39.362 LoCs, or 46%).</p>
<p>The rewriting process consisted of identifying sets of callbacks implementing <em>control-flow behaviors</em> in the game and translating them to Céu using appropriate structured constructs. As an example, a double mouse click is characterized by a first click, followed by a maximum amount of time, followed by a second click. This behavior depends on different events (clicks and timers) which have to occur in a particular order. In C++, the implementation involves callbacks crossing reactions to successive events which manipulate state variables explicitly.</p>
<p>We can identify control-flow behaviors in C++ by looking for class members with identifiers resembling verbs, statuses, and counters (e.g., <a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/components/action_button.hpp#L36"><code>pressed</code></a>, <a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/actions/bomber.hpp#L31"><code>particle_thrown</code></a>, <a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/actions/bridger.hpp#L30"><code>mode</code></a>, and <a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/actions/digger.hpp#L32"><code>delay_count</code></a>). Good chances are that variables with these &quot;suspicious names&quot; encode some form of control-flow progression that cross multiple callback invocations.</p>
<p>We rewrote 126 of the 272 files (46%) which account for 9.186 of the 18.173 LoCs (51%) comprising the game logic of Pingus [<a href="https://github.com/fsantanna/pingus/tree/ceu/cmp/CPP"><img src="images/link_12.png" alt="X" /></a>]. Half of the game logic relates to non-reactive code, such as configurations and options, saved games and serialization, maps and levels descriptions, string formatting, collision detection, graph algorithms, etc. This part remains unchanged and relies on the seamless integration between Céu and C/C++ to remain usable. From the 9.186 touched LoCs, we removed all headers, declarations, trivial getters &amp; setters, and other innocuous statements, resulting in 70 implementation files with 4.135 dense LoCs originally written in C++ [<a href="https://github.com/fsantanna/pingus/tree/ceu/cmp/ALL"><img src="images/link_12.png" alt="X" /></a>]. We did the same with the implementation in Céu, resulting in 3.697 dense LoCs [<a href="https://github.com/fsantanna/pingus/tree/ceu/cmp/ALL"><img src="images/link_12.png" alt="X" /></a>]. The table that follows summarizes the condensed codebase in the two implementations:</p>
<pre><code>    Path            Céu     C++   Céu/C++       Descritpion
    ------------   ----    ----     ----        --------------------------------------
    game/          2064    2268     0.91        the main gameplay
      ./            710     679     1.05            main functionality
      objs/         470     478     0.98            world objects (tiles, traps, etc)
      pingu/        884    1111     0.80            pingu behaviors
        ./          343     458     0.75                main functionality
        actions/    541     653     0.83                pingu actions (bomber, climber, etc)
    worldmap/       468     493     0.95        campaign worldmap
    screens/       1109    1328     0.84        menus and screens
        option/     347     357     0.97            option menu
        others/     762     971     0.78            other menus and screens
    misc/            56      46     1.22        miscellaneous functionality
                   ----    ----     ----
                   3697    4135     0.89</code></pre>
<p>This report focuses on a qualitative analysis for the programming techniques that we applied during the rewriting process. Not all techniques result in reduction in LoCs (especially considering the verbose syntax of Céu), but have other effects such as eliminating shared variables and dependencies between classes. <!--, helping on encapsulation and cohesion.--> Nonetheless, the lowest ratio numbers above correlate to the parts of the game logic that we consider more susceptible to structured reactive programming. For instance, the <em>Pingu</em> behavior (<em>ratio 0.80</em>) contains complex animations that are affected by timers, game rules, and user interaction. In contrast, the <em>Option</em> screen (<em>ratio 0.97</em>) is a simple UI grid with trivial mouse interactions.</p>
<p>We selected 9 representative game behaviors and describe their implementations in C++ and Céu. We also categorized these examples in 5 abstract C++ control-flow patterns that likely apply to other games:</p>
<p><a name="finite-state-machines"/></p>
<ol style="list-style-type: decimal">
<li><a href="#finite-state-machines"><strong>Finite State Machines</strong></a>: State machines describe the behavior of entities by mapping event occurrences to transitions between states that trigger appropriate actions.
<ul>
<li>[ <a href="#finite_state_machines_1">case 1</a> | <a href="#finite-state-machines-2">case 2</a> | <a href="#finite-state-machines-summary">summary</a> ]</li>
</ul></li>
<li><a href="#continuation-passing"><strong>Continuation Passing</strong></a>: The completion of a long-lasting activity may carry a continuation, i.e., some action to execute next.
<ul>
<li>[ <a href="#continuation-passing-1">case 1</a> | <a href="#continuation-passing-2">case 2</a> | <a href="#continuation-passing-summary">summary</a> ]</li>
</ul></li>
<li><a href="#dispatching-hierarchies"><strong>Dispatching Hierarchies</strong></a>: Entities typically form a dispatching hierarchy in which a container that receives a stimulus automatically forwards it to its managed children.
<ul>
<li>[ <a href="#dispatching-hierarchies-1">case 1</a> | <!-- [TODO-resize](#dispatching_hierarchies_2) | --> <a href="#dispatching_hierarchies_summary">summary</a> ]</li>
</ul></li>
<li><a href="#lifespan-hierarchies"><strong>Lifespan Hierarchies</strong></a>: Entities typically form a lifespan hierarchy in which a terminating container entity automatically destroys its managed children.
<ul>
<li>[ <a href="#lifespan-hierarchies-1">case 1</a> | <a href="#lifespan-hierarchies-2">case 2</a> | <a href="#lifespan_hierarchies_summary">summary</a> ]</li>
</ul></li>
<li><a href="#signaling"><strong>Signaling Mechanisms</strong></a>: Entities often need to communicate explicitly through signaling mechanisms, especially if there is no hierarchy relationship between them.
<ul>
<li>[ <a href="#signaling_1">case 1</a> | <a href="#signaling_2">case 2</a> | <a href="#signaling-summary">summary</a> ]</li>
</ul></li>
</ol>
<h3 id="conclusion"><a href="#conclusion-1">Conclusion</a></h3>
<h3 id="author"><a href="#author-1">Author</a></h3>
<!-- TODO: codebases for other open source games -->
<!--
 (the `pingus/` directory):
```
$ sloccount pingus/
SLOC    Directory   SLOC-by-Language (Sorted)
18173   pingus/         cpp=18173
10062   engine/         cpp=10062
6532    editor/         cpp=6532
2771    util/           cpp=2771
1138    math/           cpp=1138
679     lisp/           cpp=679
365     win32/          ansic=365
248     macosx/         objc=248
7       ./              cpp=7

Totals grouped by language (dominant language first):
cpp:          39362 (98.47%)
ansic:          365 (0.91%)
objc:           248 (0.62%)

Total Physical Source Lines of Code (SLOC) = 39,975
```
-->
<!--
Other games manifesting these patterns likely use some form of explicit state
subject to the same rewriting process.
-->
<!--
6. [**Wall-Clock Timers**](#wall-clock-timers):
    Wall-clock timers measure the passage of time from the real world
    (e.g., *10 seconds*) such as for periodic sampling and timeout watchdogs.
    * [ [summary](#wall-clock-timers-summary) ]

6. [**Pausing**](#pausing):
    Pausing allows parts of the game to temporarily stop reacting to incoming
    events.
    * [ [summary](#pausing-summary) ]
    * TODO

7. [**Resource Acquisition and Release**](#resource-acquisition-and-release):
    External resources, such as configuration files and saved games,
    must be acquired and safely released.
    * [ [summary](#resource-acquisition-and-release-summary) ]
    * TODO
-->
<!-- TODO: The patterns are not entirely orthogonal -->
<!--
## Why rewriting Pingus to Céu?

Besides promoting the concurrency model of Céu, we have additional motivations 
to write this report as follows:

* Expose Céu to a real code base that was neither specified nor implemented by 
  the designers of the language.
  Even though video games match the domain of Céu, a real-world project 
  consists of a range of requirements, forcing us to transpose the "academic
  fences" of papers (which usually only explore idiomatic code).
* Exercise the interface between Céu and C/C++.
  Céu is designed to integrate seamlessly with C.
  This allowed us to perform a *live rewriting*, i.e., we incrementally rewrote 
  code from C++ to Céu without breaking the game for long.
* Serve as a comprehensive guide for developers interested in trying Céu.
  We provide an in-depth comparison between the original code in C++ and the 
  equivalent code rewritten to Céu for a number of behaviors in the game.
* Stress-test the implementation of Céu.
  Academic artifacts typically do not go beyond working prototypes.
  We also want Céu to be a robust and practical language for everyday use.
* Evaluate the performance of Céu.
  Having C++ as a benchmark, how does Céu compare in terms of memory usage, 
  code size, and execution time (e.g., FPS rate)?

## Control-Flow Patterns in Pingus
-->
<!--
                    Céu     C++   Céu/C++       Descritpion
    game/                                       the main gameplay
      pingu/        884    1111     0.80            pingus
        ./          343     458     0.75                main functionality
        actions/    541     653     0.83                actions (bomber, climber, etc)
    screens/                                        menus and screens
        others/     762     971     0.78            other menus and screens
                   ----    ----     ----
                   1646    2082     0.79

$ cd cmp/ALL
$ find . -name "*.cpp" | sort | xargs wc
4650
$ find . -name "*.ceu" | sort | xargs wc
3870

$ cd cmp/CPP
$ sloccount .
10786

$ cd cmp/CPP (-engine)
$ sloccount .
9186
$ find . -name "*.cpp" | wc
63
$ find . -name "*.hpp" | wc
63
>>> 126

$ cd /official/src/pingus
$ find . -name "*.cpp" | wc
134
$ find . -name "*.hpp" | wc
138
>>> 272
$ sloccount .
18173
-->
<!--
## Related Work
- super glue, 2012
- patterns,
- ???
- async, 2010, full7.pdf
- animation lang, 2008, 2.pdf
- sm1, 2006, 6.pdf
- sm2, 2006, 7.pdf

-------------------------------------------------------------------------------

<!--
# Qualitative Analysis

- why not quantitative?
    - focus on how
    - not all changes delete code
    - more intereseted in changes that remove global rearrange
        - expressiveness
-->
<p><a name="finite-state-machines"/></p>
<h2 id="finite-state-machines">1) Finite State Machines</h2>
<p>State machines describe the behavior of entities by mapping event occurrences to transitions between states that trigger appropriate actions.</p>
<!--
The double click behavior for the *Armageddon button* is an example of a simple 
state machine.
TODO: Case 3: Sprite Animations
-->
<p><a name="finite_state_machines_1"/></p>
<h3 id="the-armageddon-button-double-click">1.1) The <em>Armageddon</em> Button Double Click</h3>
<!--
Let's consider the case of handling double clicks in the game.
-->
<div class="images">
<img src="images/double-click-opt.gif" width="350"/> <br> <a href="images/double-click-opt.gif"> Figure 3</a>: Double click detection
</div>
<p>In Pingus, a double click in the <em>Armageddon</em> button at the bottom right of the screen literally explodes all pingus (Figure 3).</p>
<!-- CPP-ARMAGEDDON -->
<h4 id="c">C++</h4>
<p>In C++, the class <code>ArmageddonButton</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/components/action_button.cpp#L24"><img src="images/link_12.png" alt="X" /></a>] implements methods for rendering the button and handling mouse and timer events. In the code that follows, we focus on the double click detection, hiding unrelated parts with <code>&lt;...&gt;</code>:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  ArmageddonButton::ArmageddonButton(<...>):
<b><font size="-1" color="#666666"> 2:</font></b>      RectComponent(<...>),
<b><font size="-1" color="#666666"> 3:</font></b>      pressed(<b>false</b>); // button state: initially not pressed
<b><font size="-1" color="#666666"> 4:</font></b>      press_time(0);  // how long since the 1st click?
<b><font size="-1" color="#666666"> 5:</font></b>      <...>
<b><font size="-1" color="#666666"> 6:</font></b>  {
<b><font size="-1" color="#666666"> 7:</font></b>      <...>
<b><font size="-1" color="#666666"> 8:</font></b>  }
<b><font size="-1" color="#666666"> 9:</font></b>  
<b><font size="-1" color="#666666">10:</font></b>  <b>void</b> ArmageddonButton::draw (<...>) {
<b><font size="-1" color="#666666">11:</font></b>      <...>
<b><font size="-1" color="#666666">12:</font></b>  }
<b><font size="-1" color="#666666">13:</font></b>  
<b><font size="-1" color="#666666">14:</font></b>  <b>void</b> ArmageddonButton::update (<b>float</b> delta) {
<b><font size="-1" color="#666666">15:</font></b>      <...>
<b><font size="-1" color="#666666">16:</font></b>      <b>if</b> (pressed) {
<b><font size="-1" color="#666666">17:</font></b>          press_time += delta;
<b><font size="-1" color="#666666">18:</font></b>          <b>if</b> (press_time > 1.0f) {
<b><font size="-1" color="#666666">19:</font></b>              pressed = <b>false</b>;    // giving up, 1st click was
<b><font size="-1" color="#666666">20:</font></b>              press_time = 0;     //            too long ago
<b><font size="-1" color="#666666">21:</font></b>          }
<b><font size="-1" color="#666666">22:</font></b>      } <b>else</b> {
<b><font size="-1" color="#666666">23:</font></b>          <...>
<b><font size="-1" color="#666666">24:</font></b>          press_time = 0;
<b><font size="-1" color="#666666">25:</font></b>      }
<b><font size="-1" color="#666666">26:</font></b>  }
<b><font size="-1" color="#666666">27:</font></b>  
<b><font size="-1" color="#666666">28:</font></b>  <b>void</b> ArmageddonButton::on_click (<...>) {
<b><font size="-1" color="#666666">29:</font></b>      <b>if</b> (pressed) {
<b><font size="-1" color="#666666">30:</font></b>          server->send_armageddon_event();
<b><font size="-1" color="#666666">31:</font></b>      } <b>else</b> {
<b><font size="-1" color="#666666">32:</font></b>          pressed = <b>true</b>;
<b><font size="-1" color="#666666">33:</font></b>      }
<b><font size="-1" color="#666666">34:</font></b>  }</code></pre>
<p>The methods <code>update</code> (ln. 14-26) and <code>on_click</code> (ln. 28-34) are examples of <em>short-lived callbacks</em>, which are pieces of code that execute atomically in reaction to external input events. The callback <code>on_click</code> reacts to mouse clicks detected by the button base class <code>RectComponent</code> (ln. 2), while the callback <code>update</code> continuously reacts to the passage of time, frame by frame. Callbacks are short lived because they must react to input as fast as possible to let other callbacks execute, keeping the game with real-time responsiveness.</p>
<div class="images">
<img src="images/double-click.png" width="550"/> <br> <a href="images/double-click.png"> Figure 4</a>: State machine for the <em>Armageddon</em> double click
</div>
<p>The class first initializes the variable <code>pressed</code> to track the first click (ln. 3,32). It also initializes the variable <code>press_time</code> to count the time since the first click (ln. 4,17). If another click occurs within 1 second, the class signals the double click to the application (ln. 30). Otherwise, the <code>pressed</code> and <code>press_time</code> state variables are reset (ln. 19-20).</p>
<p>Figure 4 illustrates how we can model the double-click behavior in C++ as a state machine. The circles represent the state of the variables in the class, while the arrows represent the callbacks manipulating state.</p>
<p>Note in the code how the accesses to the state variables are spread across the entire class. For instance, the distance between the initialization of <code>pressed</code> (ln. 3) and the last access to it (ln. 32) is over 40 lines in the original file [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/components/action_button.cpp#L33-#L90"><img src="images/link_12.png" alt="X" /></a>]. Arguably, this dispersion of code across methods makes the understanding and maintenance of the double-click behavior more difficult. Also, even though the state variables are private, unrelated methods such as <code>draw</code>, which is defined in middle of the class (ln. 10-12), can potentially access them.</p>
<!--
Because callbacks are short lived, the only way they can affect each other is 
by manipulating persisting member variables in the object.
These *state variables* retain their values across multiple invocations and 
serve as a control mechanism across reactions to external events.
For instance, the callbacks `on_click` and `update` react independently but must 
agree on a common protocol to detect the double click:

* `on_click` writes to `pressed` in the first click (ln. 29), and checks
  its state in further clicks (ln. 32).
* `update`, in the meantime, also checks for `pressed` and may reset its state
  (ln. 16,19).
-->
<!-- CEU-ARMAGEDDON -->
<h4 id="céu">Céu</h4>
<p>Céu provides structured constructs to deal with events, aiming to eradicate explicit manipulation of state variables for control-flow purposes. The equivalent code in Céu for the double-click detection is as follows [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/game/input.ceu#L107"><img src="images/link_12.png" alt="X" /></a>]:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>do</b>
<b><font size="-1" color="#666666"> 2:</font></b>      <b>var</b>& RectComponent c = <...>;       // (the symbol `&` denotes an alias declaration)
<b><font size="-1" color="#666666"> 3:</font></b>      <...>
<b><font size="-1" color="#666666"> 4:</font></b>      <b>loop</b> <b>do</b>
<b><font size="-1" color="#666666"> 5:</font></b>          <b>await</b> c.component.on_click;
<b><font size="-1" color="#666666"> 6:</font></b>          <b>watching</b> 1s <b>do</b>
<b><font size="-1" color="#666666"> 7:</font></b>              <b>await</b> c.component.on_click;
<b><font size="-1" color="#666666"> 8:</font></b>              <b>break</b>;
<b><font size="-1" color="#666666"> 9:</font></b>          <b>end</b>
<b><font size="-1" color="#666666">10:</font></b>      <b>end</b>
<b><font size="-1" color="#666666">11:</font></b>      <...>
<b><font size="-1" color="#666666">12:</font></b>      <b>emit</b> <b>outer</b>.game.go_armageddon;
<b><font size="-1" color="#666666">13:</font></b>  <b>end</b></code></pre>
<!--
Instead of *objects*, classes in Céu instantiate *organisms* with a body 
declaration (ln. 1-13) that starts to execute automatically.
Unlike objects, an organism is a reactive entity that executes concurrently 
with other organisms.
Organisms react to external events sequentially, one after the other, resulting 
in deterministic programs.
Unlike callbacks, organism bodies keep the execution context across event 
occurrences alive (if they do not terminate).
-->
<p>The loop detection (ln. 4-10) awaits the first click (ln. 5) and then, while <a href="http://fsantanna.github.io/ceu/out/manual/v0.20/statements/#watching">watching</a> 1 second (ln. 6-9), awaits the second click (ln. 7). If the second click occurs within 1 second, the <code>break</code> terminates the loop (ln. 8) and the <code>emit</code> signals the double click to the application (ln. 12). Otherwise, the <code>watching</code> block as a whole aborts and restarts the loop, falling back to the first click <code>await</code> (ln. 5).</p>
<p>Double click detection in Céu doesn't require state variables and is entirely self-contained in the <code>loop</code> body (ln. 4-10). Furthermore, these 7 lines of code <strong>only</strong> detect the double click, leaving the actual effect to happen outside the loop (ln. 12).</p>
<!--
The complete implementations for the *Armageddon* button in C++ and Céu are 47
and 24 lines of code, respectively [[![X]][diff_armageddon]].

As we argue throughout this document, appropriate control-flow mechanisms for 
reactive applications (e.g., the `await` and `watching` statements) help on the
structure and composition of code, resulting in considerable gains in
productivity.
-->
<p><a name="finite-state-machines-2"/></p>
<h3 id="the-bomber-action">1.2) The <em>Bomber</em> Action</h3>
<div class="images">
<img src="images/bomber-opt.gif" width="350"/> <br> <a href="images/bomber-opt.gif"> Figure 5</a>: The <em>Bomber</em> action
</div>
<p>The <em>Bomber</em> action explodes the clicked pingu, throwing particles around and also destroying the terrain under its radius (Figure 5).</p>
<div class="images">
<img src="images/state-anim/state-anim.gif" width="550"/> <br> <a href="images/state-anim/state-anim.gif"> Figure 6</a>: State machine for the <em>Bomber</em> animation
</div>
<p>We can model the explosion animation with a sequential state machine (Figure 6) with actions associated to specific frames as follows:</p>
<ol style="list-style-type: decimal">
<li>0th frame: plays a &quot;Oh no!&quot; sound.</li>
<li>10th frame: plays a &quot;Bomb!&quot; sound.</li>
<li>13th frame: throws particles, destroys the terrain, and shows an explosion sprite.</li>
<li>Game tick: hides the explosion sprite.</li>
<li>Last frame: kills the pingu.</li>
</ol>
<p><em>(<a href="https://youtu.be/QLXIT59il6o?t=306">This video</a> presents the sound effects.)</em></p>
<h4 id="c-1">C++</h4>
<p>In C++, the class <code>Bomber</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/actions/bomber.cpp"><img src="images/link_12.png" alt="X" /></a>] defines the callbacks <code>draw</code> and <code>update</code> to manage the state machine described above:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  Bomber::Bomber (Pingu* p) :
<b><font size="-1" color="#666666"> 2:</font></b>      <...>
<b><font size="-1" color="#666666"> 3:</font></b>      sprite(<...>),              // bomber sprite
<b><font size="-1" color="#666666"> 4:</font></b>      sound_played(<b>false</b>),        // tracks state 2
<b><font size="-1" color="#666666"> 5:</font></b>      particle_thrown(<b>false</b>),     // tracks state 3
<b><font size="-1" color="#666666"> 6:</font></b>      colmap_exploded(<b>false</b>),     // tracks state 3
<b><font size="-1" color="#666666"> 7:</font></b>      gfx_exploded(<b>false</b>)         // tracks state 4
<b><font size="-1" color="#666666"> 8:</font></b>  {
<b><font size="-1" color="#666666"> 9:</font></b>      <...>
<b><font size="-1" color="#666666">10:</font></b>      // 1. 0th frame: plays a "Oh no!" sound.
<b><font size="-1" color="#666666">11:</font></b>      get_world()->play_sound("ohno", pingu->get_pos());
<b><font size="-1" color="#666666">12:</font></b>  }
<b><font size="-1" color="#666666">13:</font></b>  
<b><font size="-1" color="#666666">14:</font></b>  <b>void</b> Bomber::update () {
<b><font size="-1" color="#666666">15:</font></b>      sprite.update();
<b><font size="-1" color="#666666">16:</font></b>      <...>   // pingu movement
<b><font size="-1" color="#666666">17:</font></b>  
<b><font size="-1" color="#666666">18:</font></b>      // 2. 10th frame: plays a "Bomb!" sound.
<b><font size="-1" color="#666666">19:</font></b>      <b>if</b> (sprite.get_current_frame()==10 && !sound_played) {
<b><font size="-1" color="#666666">20:</font></b>          sound_played = <b>true</b>;
<b><font size="-1" color="#666666">21:</font></b>          get_world()->play_sound("plop", pingu->get_pos());
<b><font size="-1" color="#666666">22:</font></b>      }
<b><font size="-1" color="#666666">23:</font></b>  
<b><font size="-1" color="#666666">24:</font></b>      // 3. 13th frame: throws particles, destroys the terrain, shows an explosion sprite
<b><font size="-1" color="#666666">25:</font></b>      <b>if</b> (sprite.get_current_frame()==13 && !particle_thrown) {
<b><font size="-1" color="#666666">26:</font></b>          particle_thrown = <b>true</b>;
<b><font size="-1" color="#666666">27:</font></b>          get_world()->get_pingu_particle_holder()->add_particle(...);
<b><font size="-1" color="#666666">28:</font></b>      }
<b><font size="-1" color="#666666">29:</font></b>      <b>if</b> (sprite.get_current_frame()==13 && !colmap_exploded) {
<b><font size="-1" color="#666666">30:</font></b>          colmap_exploded = <b>true</b>;
<b><font size="-1" color="#666666">31:</font></b>          get_world()->remove(bomber_radius, <...>);
<b><font size="-1" color="#666666">32:</font></b>      }
<b><font size="-1" color="#666666">33:</font></b>  
<b><font size="-1" color="#666666">34:</font></b>      // 5. Last frame: kills the Pingu
<b><font size="-1" color="#666666">35:</font></b>      <b>if</b> (sprite.is_finished ()) {
<b><font size="-1" color="#666666">36:</font></b>          pingu->set_status(Pingu::PS_DEAD);
<b><font size="-1" color="#666666">37:</font></b>      }
<b><font size="-1" color="#666666">38:</font></b>  }
<b><font size="-1" color="#666666">39:</font></b>  
<b><font size="-1" color="#666666">40:</font></b>  <b>void</b> Bomber::draw (SceneContext& gc) {
<b><font size="-1" color="#666666">41:</font></b>      // 3. 13th frame: throws particles, destroys the terrain, shows an explosion sprite
<b><font size="-1" color="#666666">42:</font></b>      // 4. Game tick: hides the explosion sprite
<b><font size="-1" color="#666666">43:</font></b>      <b>if</b> (sprite.get_current_frame()==13 && !gfx_exploded) {
<b><font size="-1" color="#666666">44:</font></b>          gfx_exploded = <b>true</b>;
<b><font size="-1" color="#666666">45:</font></b>          gc.color().draw(explo_surf, <...>);
<b><font size="-1" color="#666666">46:</font></b>      }
<b><font size="-1" color="#666666">47:</font></b>      gc.color().draw(sprite, pingu->get_pos());
<b><font size="-1" color="#666666">48:</font></b>  }</code></pre>
<!--*-->
<p>The class first defines one state variable for each action to perform (ln. 4-7). The &quot;Oh no!&quot; sound plays as soon as the object starts in <em>state-1</em> (ln. 11). The <code>update</code> callback (ln. 14-38) updates the pingu animation and movement on every frame regardless of its current state (ln. 15-16). When the animation reaches the 10th frame, it plays the &quot;Bomb!&quot; sound and switches to <em>state-2</em> (ln. 18-22). The state variable <code>sound_played</code> is required because the sprite frame doesn't necessarily advance on every <code>update</code> invocation (e.g., <code>update</code> may execute twice during the 10th frame). The same reasoning and technique applies to <em>state-3</em> (ln. 25-32 and 43-44). The explosion sprite appears in a single frame in <em>state-4</em> (ln. 45). Finally, the pingu dies after the animation frames terminate (ln. 35-37).</p>
<p>Note that a single numeric state variable suffices to track the states, but the original authors probably chose to encode each state in an independent boolean variable to rearrange and experiment with them during development. Still, due to the short-lived nature of callbacks, state variables are unavoidable and are actually the essence of object-oriented programming (i.e., <em>methods + mutable state</em>).</p>
<p>Similarly to <a href="#finite_state_machines_1"> Section 1.1</a>, note also that the state machine is encoded across 3 different methods, each intermixing code with unrelated functionality.</p>
<p><a name="bomber"/></p>
<h4 id="céu-1">Céu</h4>
<p>The equivalent code for the <em>Bomber</em> action in Céu doesn't require state variables and reflects the sequential state machine implicitly, using <code>await</code> statements in direct style to separate the actions [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/game/pingu/actions/bomber.ceu"><img src="images/link_12.png" alt="X" /></a>]:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>code</b>/<b>await</b> Bomber (<b>void</b>) -> _ActionName__Enum
<b><font size="-1" color="#666666"> 2:</font></b>  <b>do</b>
<b><font size="-1" color="#666666"> 3:</font></b>      <...>
<b><font size="-1" color="#666666"> 4:</font></b>      <b>spawn</b> Mover();                          // <b>spawn</b> the pingu movement to execute <b>in</b> the "background"
<b><font size="-1" color="#666666"> 5:</font></b>  
<b><font size="-1" color="#666666"> 6:</font></b>      <b>var</b>&? Sprite s = <b>spawn</b> Sprite(<...>);   // <b>spawn</b> the bomber animation to execute <b>in</b> the "background"
<b><font size="-1" color="#666666"> 7:</font></b>      <b>watching</b> s <b>do</b>
<b><font size="-1" color="#666666"> 8:</font></b>          // 1. 0th frame: plays a "Oh no!" sound.
<b><font size="-1" color="#666666"> 9:</font></b>          {Sound::PingusSound::play_sound("ohno", 0.5, 0.0)};
<b><font size="-1" color="#666666">10:</font></b>  
<b><font size="-1" color="#666666">11:</font></b>          // 2. 10th frame: plays a "Bomb!" sound.
<b><font size="-1" color="#666666">12:</font></b>          <b>await</b> <b>outer</b>.game.dt <b>until</b> s!.sprite.frame == 10;
<b><font size="-1" color="#666666">13:</font></b>          {Sound::PingusSound::play_sound("plop", 0.5, 0.0)};
<b><font size="-1" color="#666666">14:</font></b>  
<b><font size="-1" color="#666666">15:</font></b>          // 3. 13th frame: throws particles, destroys the terrain, shows an explosion sprite
<b><font size="-1" color="#666666">16:</font></b>          <b>await</b> <b>outer</b>.game.dt <b>until</b> s!.sprite.frame == 13;
<b><font size="-1" color="#666666">17:</font></b>          <b>spawn</b> PinguParticles(<...>) <b>in</b> <b>outer</b>.pingu_particles;
<b><font size="-1" color="#666666">18:</font></b>          <b>call</b> Game_Remove({&bomber_radius}, <...>);
<b><font size="-1" color="#666666">19:</font></b>          <b>do</b>
<b><font size="-1" color="#666666">20:</font></b>              <...>
<b><font size="-1" color="#666666">21:</font></b>              <b>spawn</b> Sprite(<...>);            // explosion
<b><font size="-1" color="#666666">22:</font></b>  
<b><font size="-1" color="#666666">23:</font></b>              // 4. Game tick: hides the explosion sprite
<b><font size="-1" color="#666666">24:</font></b>              <b>await</b> <b>outer</b>.game.dt;
<b><font size="-1" color="#666666">25:</font></b>          <b>end</b>
<b><font size="-1" color="#666666">26:</font></b>          <b>await</b> FOREVER;
<b><font size="-1" color="#666666">27:</font></b>      <b>end</b>
<b><font size="-1" color="#666666">28:</font></b>  
<b><font size="-1" color="#666666">29:</font></b>      // 5. Last frame: kills the pingu
<b><font size="-1" color="#666666">30:</font></b>      <b>escape</b> {ActionName::DEAD};
<b><font size="-1" color="#666666">31:</font></b>  <b>end</b></code></pre>
<p>The <code>Bomber</code> is a <code>code/await</code> abstraction of Céu, which is similar to a <a href="https://en.wikipedia.org/wiki/Coroutine">coroutine</a>: a subroutine that retains runtime state, such as local variables and the program counter, across reactions to events (i.e., across <code>await</code> statements). The pingu movement and sprite animation are isolated in two other abstractions and execute in separate through the <code>spawn</code> primitive (ln. 4,6). The event <code>game.dt</code> (ln. 12,12,24) is analogous to the <code>update</code> callback of C++ and occurs on every frame.</p>
<p><a name="bomber_explo"/></p>
<p>The code tracks the animation instance (ln. 7-27), performing the last bomber action on termination (ln. 30). As soon as the animation starts, the code performs the first action (ln. 8). The intermediate actions are performed when the corresponding conditions occur (ln. 12,16,24). The <code>do-end</code> block (ln. 19-25), restricts the lifespan of the single-frame explosion sprite (ln. 21): after the next game tick (ln. 24), the block terminates and automatically destroys the spawned abstraction (removing it from the screen).</p>
<p>In contrast with the implementation in C++, all actions happen in a contiguous chunk of code (ln. 6-30) which handles no extra functionality.</p>
<p><a name="finite-state-machines-summary"/> <br/></p>
<div class="summary">
<p><strong>Summary</strong>:</p>
<p>The structured constructs of Céu provide some advantages in comparison to explicit state machines:</p>
<ul>
<li>They encode all states with direct sequential code, eliminating shared state variables.</li>
<li>They handle all states (and only them) in the same contiguous block, improving code encapsulation.</li>
</ul>
<p><strong>How common are Finite State Machines?</strong></p>
<p>Pingus supports 16 actions in the game [<a href="https://github.com/fsantanna/pingus/tree/ceu/ceu/pingus/screens/game/pingu/actions"><img src="images/link_12.png" alt="X" /></a>]: 5 of them implement at least one state machine and are considerable smaller in Céu in terms of LoCs:</p>
<pre><code>    Action          Céu     C++     Explicit State
    ------------   ----    ----     -----------------
    Bomber           23      50     4 state variables
    Bridger          75     100     2 state variables
    Drown             6      15     1 state variable
    Exiter            7      22     2 state variables
    Splashed          6      19     2 state variables</code></pre>
<p>Considering the other 11 actions, the reduction in LoCs is negligible. This asymmetry in the implementation of actions illustrates the gains in expressiveness when describing state machines in direct style.</p>
<p>As other examples, detecting mouse dragging in the scenario [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/game/playfield.ceu#L45"><img src="images/link_12.png" alt="X" /></a>] and in the small map [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/game/smallmap.ceu#L18"><img src="images/link_12.png" alt="X" /></a>] to move the game viewport also involves state machines. State machines also appear in the <em>FPS counter</em> [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/fps_counter.ceu#L12"><img src="images/link_12.png" alt="X" /></a>] and in UI widgets with visual feedback (e.g., [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/levels/levelsets.ceu#L23"><img src="images/link_12.png" alt="X" /></a>]).</p>
<p>Among the 65 implementation files in Céu, we found 29 cases in 25 files using structured mechanisms to substitute states machines. They manifest as <code>await</code> statements in sequence or in aborting constructs such as <code>par/or</code> and <code>watching</code>.</p>
<!--
actions/    5
actions     over            watching, await
actions     select          par/or, await
button      over/click      await, await
cap_rect    over            watching, await
entrance    abort           watching
entrance    count           await, await
fps         abort           watching, await
game        count           await, await
goal_man    count           await, await
guillotine  abort           watching, await
input       double click    watching, await
input       hold press      watching, await
input       toggle          par/or, await
level       over            await, await
levelset    over            await, await
main        abort           watching, await
pingus      abort           watching, await
playfield   drag            watching, await
rect_comp   click           await, await
sfc_but     over            watching, await
slider      drag            watching, await
smallmap    drag            watching, await
spike       abort           watching, await
story       next_text       par/or, watching, await
-->
<!--
The complete implementations for the *Bomber* action in C++ and Céu are 50 and
19 lines of code, respectively [[![X]][diff_bomber]].

           C++     CEU
Basher      72      74      i%3, i%2, no gains in LoCs, C++ mix
Blocker     35      29      draw/update
Bomber      50      23      draw/update, 4-var
Bridger    100      75      draw/update, 2-var
Climber     28      26      draw/update
Digger      45      43      draw/update
Drown       15       6      draw/update, finished
Exiter      22       7      draw/update, finished, 1-var
Faller      60      52      draw/update, mover, seq
Floater     17      14      draw/update
Jumper      21      22      draw/update
Miner       43      44      draw/update
Slider      31      31      draw/update
Splashed    19       6      draw/update, finisher, 1-var
Waiter      17      12      draw/update
Walker      78      77      draw/update
    16     653     541      83%
     5     206     117      57%
    11     447     424      95%

Entrance    72      61      draw/update
Exit        36      40      draw/update
Guillotine  51      39      draw/update, finished
Hotspot     14      12      draw/update
Smasher     62      62      draw/update
Spike       35      27      draw/update, killing
-->
</div>
<p><a name="continuation-passing"/></p>
<h2 id="continuation-passing">2) Continuation Passing</h2>
<p>The completion of a long-lasting activity may carry a continuation, i.e., some action to execute next.</p>
<!--
If the execution flow is dynamic, the program has to tell the activity where to 
go when it completes.
In Pingus, when the player terminates a level, the game may terminate or return 
to the main menu, depending on how it was invoked from the command line.

Continuation passing is a special case of a state machine in which the previous 
state passes to the current state what will be the next state.

- tudo porque eu consigo voltar/retornar das "chamadas"
    - programacao estruturada

more natural structured code with sequences, conditionals, and loops
-->
<p><a name="continuation-passing-1"/></p>
<h3 id="advancing-pages-in-the-story-screen">2.1) Advancing Pages in the <em>Story</em> Screen</h3>
<div class="images">
<img src="images/story-anim.gif" width="350"/> <br> <a href="images/story-anim.gif"> Figure 7</a>: The <em>Story</em> screen
</div>
<p>The clickable <em>blue dots</em> in the campaign world map transit to ambience story screens (Figure 7). A story is composed of multiple pages and, inside each page, the words of the story appear incrementally over time. A first click in the button <code>&gt;&gt;&gt;</code> fast forwards the words to show the full page. A second click advances to the next page, until the story terminates. If the page completes before a click (due to the time elapsing), a first click advances to the next page.</p>
<!-- CPP-STORY-PAGES -->
<h4 id="c-2">C++</h4>
<p>In C++, the class <code>StoryScreenComponent</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/screens/story_screen.cpp#L158"><img src="images/link_12.png" alt="X" /></a>] implements the method <code>next_text</code>, which is a callback for clicks in <code>&gt;&gt;&gt;</code>:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  StoryScreenComponent::StoryScreenComponent (<...>) :
<b><font size="-1" color="#666666"> 2:</font></b>      <...>
<b><font size="-1" color="#666666"> 3:</font></b>  {
<b><font size="-1" color="#666666"> 4:</font></b>      pages        = <...>;           // vector with loaded pages
<b><font size="-1" color="#666666"> 5:</font></b>      current_page = pages.back();    // first loaded page
<b><font size="-1" color="#666666"> 6:</font></b>      displayed    = <b>false</b>;           // <b>if</b> current page is complete
<b><font size="-1" color="#666666"> 7:</font></b>      <...>
<b><font size="-1" color="#666666"> 8:</font></b>  }
<b><font size="-1" color="#666666"> 9:</font></b>  
<b><font size="-1" color="#666666">10:</font></b>  <...>   // draw page over time
<b><font size="-1" color="#666666">11:</font></b>  
<b><font size="-1" color="#666666">12:</font></b>  <b>void</b> StoryScreenComponent::update (<...>) {
<b><font size="-1" color="#666666">13:</font></b>      <...>
<b><font size="-1" color="#666666">14:</font></b>      <b>if</b> (&lt;all-words-appearing&gt;) {
<b><font size="-1" color="#666666">15:</font></b>          displayed = <b>true</b>;
<b><font size="-1" color="#666666">16:</font></b>      }
<b><font size="-1" color="#666666">17:</font></b>  }
<b><font size="-1" color="#666666">18:</font></b>  
<b><font size="-1" color="#666666">19:</font></b>  <b>void</b> StoryScreenComponent::next_text() {
<b><font size="-1" color="#666666">20:</font></b>      <b>if</b> (!displayed) {
<b><font size="-1" color="#666666">21:</font></b>          displayed = <b>true</b>;
<b><font size="-1" color="#666666">22:</font></b>          <...>                       // remove current page
<b><font size="-1" color="#666666">23:</font></b>      } <b>else</b> {
<b><font size="-1" color="#666666">24:</font></b>          pages.pop_back();
<b><font size="-1" color="#666666">25:</font></b>          <b>if</b> (!pages.empty()) {       // next page
<b><font size="-1" color="#666666">26:</font></b>              current_page = pages.back();
<b><font size="-1" color="#666666">27:</font></b>              displayed    = <b>false</b>;
<b><font size="-1" color="#666666">28:</font></b>              <...>
<b><font size="-1" color="#666666">29:</font></b>          } <b>else</b> {
<b><font size="-1" color="#666666">30:</font></b>              <...>                   // terminates the story screen
<b><font size="-1" color="#666666">31:</font></b>          }
<b><font size="-1" color="#666666">32:</font></b>      }
<b><font size="-1" color="#666666">33:</font></b>  }</code></pre>
<div class="images">
<img src="images/story.png" width="550"/> <br> <a href="images/story.png"> Figure 8</a>: State machine for the <em>Story</em> screen
</div>
<p>The variable <code>pages</code> (ln. 4-5, 24-26) is a vector holding each page, but which also encodes <em>continuations</em> for the story progress: each call to <code>next_text</code> that advances the story (ln. 23-32) removes the current page (ln. 24) and sets the next action to perform (i.e., &quot;display a new page&quot;) in the variable <code>current_page</code> (ln. 26). Figure 8 illustrates the continuation mechanism to advance pages and also a state machine for fast forwarding words (inside the dashed rectangle). The state variable <code>displayed</code> (ln. 6,15,20,21,27) switches between the behaviors &quot;advancing text&quot; and &quot;advancing pages&quot;, which are both handled intermixed inside the method <code>next_text</code>.</p>
<!-- CEU-STORY-PAGES -->
<h4 id="céu-2">Céu</h4>
<p>The code in Céu [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/story.ceu#L60-L112"><img src="images/link_12.png" alt="X" /></a>] uses the <a href="http://fsantanna.github.io/ceu/out/manual/v0.20/storage_entities/#events">internal event</a> <code>next_text</code>, which is emitted from clicks in <code>&gt;&gt;&gt;</code>:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>code</b>/<b>await</b> Story (<b>void</b>) -> <b>bool</b> <b>do</b>
<b><font size="-1" color="#666666"> 2:</font></b>      <...>
<b><font size="-1" color="#666666"> 3:</font></b>      <b>event</b> <b>void</b> next_text;   // emitted from clicks <b>in</b> `>>>`
<b><font size="-1" color="#666666"> 4:</font></b>  
<b><font size="-1" color="#666666"> 5:</font></b>      { pages = <...>; }      // same <b>as</b> <b>in</b> C++
<b><font size="-1" color="#666666"> 6:</font></b>      <b>loop</b> i <b>in</b> [0 <- {pages.size()}[ <b>do</b>
<b><font size="-1" color="#666666"> 7:</font></b>          <b>par</b>/<b>or</b> <b>do</b>
<b><font size="-1" color="#666666"> 8:</font></b>              <b>watching</b> next_text <b>do</b>
<b><font size="-1" color="#666666"> 9:</font></b>                  <...>       // <b>loop</b> to advance text over time
<b><font size="-1" color="#666666">10:</font></b>              <b>end</b>
<b><font size="-1" color="#666666">11:</font></b>              <b>await</b> next_text;
<b><font size="-1" color="#666666">12:</font></b>          <b>with</b>
<b><font size="-1" color="#666666">13:</font></b>              <...>           // <b>loop</b> to redraw current _pages[i]
<b><font size="-1" color="#666666">14:</font></b>          <b>end</b>
<b><font size="-1" color="#666666">15:</font></b>      <b>end</b>
<b><font size="-1" color="#666666">16:</font></b>  <b>end</b></code></pre>
<p>The sequential navigation from page to page uses a loop in direct style (ln. 6-15) instead of explicit state variables for the continuation and state machine. While the text advances in an inner loop (hidden in ln. 9), we watch the <code>next_text</code> event that fast forwards it. The loop may also eventually terminate with the time elapsing normally. This way, we do not need a variable (such as <code>displayed</code> in C++) to switch between the states &quot;advancing text&quot; and &quot;advancing pages&quot;. The <a href="http://fsantanna.github.io/ceu/out/manual/v0.20/#parallel-compositions-and-abortion"><code>par/or</code></a> makes the page advance logic to execute in parallel with the redrawing code (ln. 13). Whenever the page advances, the redrawing code is automatically aborted (due to the <code>or</code> modifier). <!-- which are not mixed in the source code. --> The <code>await next_text</code> in sequence (ln. 11) is the condition to advance to the next page.</p>
<p>Note that, unlike the implementation in C++, the &quot;advancing text&quot; behavior is not intermixed with the &quot;advancing pages&quot; behavior, instead, it is encapsulated inside the inner loop nested with a deeper indentation (ln. 9).</p>
<!--
The complete implementations for the *Story* screen in C++ and Céu are 125
and 111 lines of code, respectively [[![X]][diff_story]].
-->
<p><a name="continuation-passing-2"/></p>
<h3 id="transition-to-the-credits-screen-from-the-story-screen">2.2) Transition to the <em>Credits</em> Screen from the <em>Story</em> Screen</h3>
<div class="images">
<img src="images/credits-anim.gif" width="350"/> <br> <a href="images/credits-anim.gif"> Figure 9</a>: Transition from <em>Story</em> to <em>Credits</em> screen
</div>
<p>The world map has clickable blue dots for both introductory and ending stories. For introductory stories, the game returns to the world map after displaying the pages. For ending stories, the game also displays a <em>Credits</em> screen before returning to the world map (Figure 9).</p>
<!-- CPP-STORY-CREDITS -->
<h4 id="c-3">C++</h4>
<p>In C++, the class <code>StoryDot</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/worldmap/story_dot.cpp#L31"><img src="images/link_12.png" alt="X" /></a>] reads the level file to check whether the story should, after termination, display the <em>Credits</em> screen or not:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  StoryDot::StoryDot(const FileReader& reader) :
<b><font size="-1" color="#666666"> 2:</font></b>      m_credits(<b>false</b>),                           // by default, do not display
<b><font size="-1" color="#666666"> 3:</font></b>  {
<b><font size="-1" color="#666666"> 4:</font></b>      <...>
<b><font size="-1" color="#666666"> 5:</font></b>      reader.read_<b>bool</b>("credits", m_credits);     // read from the file
<b><font size="-1" color="#666666"> 6:</font></b>  }
<b><font size="-1" color="#666666"> 7:</font></b>  
<b><font size="-1" color="#666666"> 8:</font></b>  <b>void</b> StoryDot::on_click() {
<b><font size="-1" color="#666666"> 9:</font></b>      <...>
<b><font size="-1" color="#666666">10:</font></b>      ScreenManager::instance()->push_screen(&lt;StoryScreen&gt;(<...>, m_credits));
<b><font size="-1" color="#666666">11:</font></b>      <...>
<b><font size="-1" color="#666666">12:</font></b>  }</code></pre>
<p>The boolean variable <code>m_credits</code> is passed to the class <code>StoryScreen</code> (ln. 10) [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/screens/story_screen.cpp#L136"><img src="images/link_12.png" alt="X" /></a>] and represents the screen continuation, i.e., what to do after displaying the story. The <code>StoryScreen</code> then forwards the continuation [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/screens/story_screen.cpp#L143"><img src="images/link_12.png" alt="X" /></a>] even further to the auxiliary class <code>StoryScreenComponent</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/screens/story_screen.cpp#L158"><img src="images/link_12.png" alt="X" /></a>] (presented in <a href="#continuation-passing-1"> Section 2.1</a>):</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  StoryScreenComponent::StoryScreenComponent (<...>) :
<b><font size="-1" color="#666666"> 2:</font></b>      m_credits(credits),
<b><font size="-1" color="#666666"> 3:</font></b>      <...>
<b><font size="-1" color="#666666"> 4:</font></b>  {
<b><font size="-1" color="#666666"> 5:</font></b>      <...>
<b><font size="-1" color="#666666"> 6:</font></b>  }
<b><font size="-1" color="#666666"> 7:</font></b>  
<b><font size="-1" color="#666666"> 8:</font></b>  <...>   // draw and update page
<b><font size="-1" color="#666666"> 9:</font></b>  
<b><font size="-1" color="#666666">10:</font></b>  <b>void</b> StoryScreenComponent::next_text() {
<b><font size="-1" color="#666666">11:</font></b>      <b>if</b> (!displayed) {
<b><font size="-1" color="#666666">12:</font></b>          <...>
<b><font size="-1" color="#666666">13:</font></b>      } <b>else</b> {
<b><font size="-1" color="#666666">14:</font></b>          <...>
<b><font size="-1" color="#666666">15:</font></b>          <b>if</b> (!pages.empty()) {
<b><font size="-1" color="#666666">16:</font></b>              <...>
<b><font size="-1" color="#666666">17:</font></b>          } <b>else</b> {
<b><font size="-1" color="#666666">18:</font></b>              <b>if</b> (m_credits) {
<b><font size="-1" color="#666666">19:</font></b>                  ScreenManager::instance()->replace_screen(&lt;Credits&gt;(<...>));
<b><font size="-1" color="#666666">20:</font></b>              } <b>else</b> {
<b><font size="-1" color="#666666">21:</font></b>                  ScreenManager::instance()->pop_screen();
<b><font size="-1" color="#666666">22:</font></b>              }
<b><font size="-1" color="#666666">23:</font></b>          }
<b><font size="-1" color="#666666">24:</font></b>      }
<b><font size="-1" color="#666666">25:</font></b>  }</code></pre>
<p>When the method <code>next_text</code> has no pages left to display (ln. 17-23), it decides where to go next, depending on the continuation flag <code>m_credits</code> (ln. 18).</p>
<!-- CEU-STORY-CREDITS -->
<h4 id="céu-3">Céu</h4>
<p>In Céu, the flow between the screens to display is a direct sequence of statements [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/worldmap/worldmap.ceu#L99-L122"><img src="images/link_12.png" alt="X" /></a>]:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>loop</b> <b>do</b>
<b><font size="-1" color="#666666"> 2:</font></b>      <b>var</b> <b>int</b> ret = <b>await</b> Worldmap();
<b><font size="-1" color="#666666"> 3:</font></b>      <b>if</b> ret=={WORLDMAP_RETURN_STORY_MAP} <b>or</b> ret=={WORLDMAP_RETURN_STORY_CREDITS} <b>then</b>
<b><font size="-1" color="#666666"> 4:</font></b>          <...>
<b><font size="-1" color="#666666"> 5:</font></b>          <b>var</b> <b>bool</b> is_click = <b>await</b> Story();
<b><font size="-1" color="#666666"> 6:</font></b>          <b>if</b> is_click <b>and</b> ret=={WORLDMAP_RETURN_STORY_CREDITS} <b>then</b>
<b><font size="-1" color="#666666"> 7:</font></b>              <...>
<b><font size="-1" color="#666666"> 8:</font></b>              <b>await</b> Credits();
<b><font size="-1" color="#666666"> 9:</font></b>          <b>end</b>
<b><font size="-1" color="#666666">10:</font></b>      <b>else</b>
<b><font size="-1" color="#666666">11:</font></b>          <...>
<b><font size="-1" color="#666666">12:</font></b>      <b>end</b>
<b><font size="-1" color="#666666">13:</font></b>  <b>end</b></code></pre>
<!--
<div class="box">
**The `do` notation**:

The `do` notation is a syntactic sugar for creating and awaiting an organism, 
e.g.:

<pre><code>var <b>int</b> ret = <b>do</b> WorldmapScreen;
<...>

// is equivalent to

<b>var</b> <b>int</b> ret;
<b>do</b>
    <b>var</b> WorldmapScreen w;
    ret = <b>await</b> w;
<b>end</b>
<...></code></pre>

A `do` is analogous to a procedure call, holding the current state while the 
started organism executes.
The code in sequence (marked as `<...>`) only executes after the organism 
terminates.
</div>
-->
<p>We first invoke the <code>Worldmap</code> (ln. 2), which exhibits the map and let the player interact with it until a dot is clicked. If the player selects a story dot (ln. 4-9), we invoke the <code>Story</code> and await its termination (ln. 5). Finally, we check the returned values (ln. 6) to perhaps display the <code>Credits</code> screen (ln. 8). The enclosing loop restores the <code>Worldmap</code> and repeats the process.</p>
<h4 id="discussion">Discussion</h4>
<div class="images">
<img src="images/continuation.png" width="500"/> <br> <a href="images/continuation.png"> Figure 10</a>: Continuation [C++] vs Direct [Céu] Styles
</div>
<p>Figure 10 illustrates the <em>continuation-passing style</em> of C++ and the <em>direct style</em> of Céu for screen transitions:</p>
<ol style="list-style-type: decimal">
<li><code>Main Loop</code> =&gt; <code>Worldmap</code>:
<ul>
<li>C++ uses an explicit stack to push the <code>Worldmap</code> screen [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/pingus_main.cpp#L585"><img src="images/link_12.png" alt="X" /></a>].</li>
<li>Céu invokes the <code>WorldMap</code> screen expecting a return value (ln. 2).</li>
</ul></li>
<li><code>Worldmap</code> (<em>blue dot click</em>) =&gt; <code>Story</code>:
<ul>
<li>C++ pushes the <code>Story</code> screen passing the continuation flag (<code>StoryDot</code>, ln. 10).</li>
<li>Céu stores the <code>Worldmap</code> return value and invokes the <code>Story</code> screen (ln. 2,5).</li>
</ul></li>
<li><code>Story</code> =&gt; <code>Credits</code>:
<ul>
<li>C++ replaces the curren <code>Story</code> screen with the <code>Credits</code> screen (<code>StoryScreenComponent</code>, ln. 19).</li>
<li>Céu invokes the <code>Credits</code> screen after the <code>await Story</code> returns (ln. 8).</li>
</ul></li>
<li><code>Credits</code> =&gt; <code>Worldmap</code>:
<ul>
<li>C++ pops the <code>Credits</code> screen, going back to the <code>Worldmap</code> screen. Céu uses an enclosing <code>loop</code> to restart the process (ln. 1,13).</li>
</ul></li>
</ol>
<p>In contrast with C++, the screens in Céu are decoupled and only the <code>Main Loop</code> touches them: the <code>Worldmap</code> has no references to <code>Story</code>, which has no references to <code>Credits</code>.</p>
<!--
TODO:
- always forward, no returns
- nao existe retorno, sempre continuacao apos continuacao
"nowhere to return"
-->
<p><a name="continuation-passing-summary"/> <br/></p>
<div class="summary">
<p><strong>Summary</strong>:</p>
<p>The direct style of Céu has some advantages in comparison to the continuation-passing style:</p>
<ul>
<li>It uses structured control flow (i.e., sequences and loops) instead of explicit data structures (e.g., stacks) or continuation variables.</li>
<li>The activities are decoupled and do not hold references to one another.</li>
<li>A single parent class describes the flow between the activities in a self-contained block of code. <!-- (instead of being spread among the activity classes). --></li>
</ul>
<p><strong>How common is Continuation Passing?</strong></p>
<p>Continuation passing typically controls the overall structure of the game, such as screen transitions in menus and level progressions. <!--
while state machines are more local
--></p>
<p>Céu uses the direct style techniques in 5 cases involving screen transitions: the main menu [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/main.ceu#L354"><img src="images/link_12.png" alt="X" /></a>], the level menu [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/levels/menu.ceu#L8"><img src="images/link_12.png" alt="X" /></a>], the level set menu [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/main.ceu#L336"><img src="images/link_12.png" alt="X" /></a>], the world map loop [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/worldmap/worldmap.ceu#L98"><img src="images/link_12.png" alt="X" /></a>], and the gameplay loop [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/main.ceu#L248"><img src="images/link_12.png" alt="X" /></a>]. It also uses the same technique for the loop that switches the pingu actions during gameplay [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/game/pingu/pingu.ceu#L144"><img src="images/link_12.png" alt="X" /></a>].</p>
</div>
<p><a name="dispatching-hierarchies"/></p>
<h2 id="dispatching-hierarchies">3) Dispatching Hierarchies</h2>
<p>Entities typically form a dispatching hierarchy in which a container that receives a stimulus automatically forwards it to its managed children.</p>
<!--
Some entities in games manage other child entities, resulting in dispatching 
hierarchies for event forwarding.
-->
<!--
It is common to broadcast notifications so that active objects can react to 
them.
The .
Some notifications
Given that .
https://en.wikipedia.org/wiki/Observer_pattern

TODO: falar de broadcast (in Ceu: unless it is paused, all receive always)

    In Pingus, the *Main Menu* in the figure above is represented as a 
    container class with five buttons as children.
    When a button click occurs, it is first dispatched to the container class,
    which may take an action before deciding to forward the event (or not) to 
    the buttons.
-->
<p><a name="dispatching-hierarchies-1"/></p>
<h3 id="bomber-draw-and-update-callbacks">3.1) Bomber <code>draw</code> and <code>update</code> callbacks</h3>
<!-- CPP-BOMBER-SPRITE -->
<h4 id="c-4">C++</h4>
<p>In C++, the class <code>Bomber</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/actions/bomber.cpp"><img src="images/link_12.png" alt="X" /></a>] declares a <code>sprite</code> member to handle its animation frames (Figure 6):</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>class</b> Bomber : public PinguAction {
<b><font size="-1" color="#666666"> 2:</font></b>      <...>
<b><font size="-1" color="#666666"> 3:</font></b>      Sprite sprite;
<b><font size="-1" color="#666666"> 4:</font></b>  }
<b><font size="-1" color="#666666"> 5:</font></b>  
<b><font size="-1" color="#666666"> 6:</font></b>  Bomber::Bomber (<...>) : <...> {
<b><font size="-1" color="#666666"> 7:</font></b>      sprite.load(<...>);
<b><font size="-1" color="#666666"> 8:</font></b>      <...>
<b><font size="-1" color="#666666"> 9:</font></b>  }
<b><font size="-1" color="#666666">10:</font></b>  
<b><font size="-1" color="#666666">11:</font></b>  <b>void</b> Bomber::update () {
<b><font size="-1" color="#666666">12:</font></b>      sprite.update ();
<b><font size="-1" color="#666666">13:</font></b>  }
<b><font size="-1" color="#666666">14:</font></b>  
<b><font size="-1" color="#666666">15:</font></b>  <b>void</b> Bomber::draw (SceneContext& gc) {
<b><font size="-1" color="#666666">16:</font></b>      <...>
<b><font size="-1" color="#666666">17:</font></b>      gc.color().draw(sprite, <...>);
<b><font size="-1" color="#666666">18:</font></b>  }</code></pre>
<p>The <code>Sprite</code> class is part of the game engine and knows how to update [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/engine/display/sprite_impl.cpp#L112"><img src="images/link_12.png" alt="X" /></a>] and render [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/engine/display/sprite_impl.cpp#L140"><img src="images/link_12.png" alt="X" /></a>] itself. However, the <code>Bomber</code> still has to respond to <code>update</code> and <code>draw</code> requests from the game and forward them to the sprite (ln. 11-13 and 15-18).</p>
<div class="images">
<img src="images/hierarchy.png" width="550"/> <br> <a href="images/hierarchy.png"> Figure 11</a>: Dispatching chain for <code>update</code>
</div>
<p>To understand how the <code>update</code> callback flows from the original environment stimulus from the game down to the sprite, we need to follow a long chain of 7 method dispatches (Figure 11):</p>
<ol style="list-style-type: decimal">
<li><code>ScreenManager::display</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/engine/screen/screen_manager.cpp#L164"><img src="images/link_12.png" alt="X" /></a>] in the main game loop calls <code>update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/engine/screen/screen_manager.cpp#L217"><img src="images/link_12.png" alt="X" /></a>].</li>
<li><code>ScreenManager::update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/engine/screen/screen_manager.cpp#L235"><img src="images/link_12.png" alt="X" /></a>] calls <code>last_screen-&gt;update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/engine/screen/screen_manager.cpp#L258"><img src="images/link_12.png" alt="X" /></a>] for the active game screen (a <code>GameSession</code> instance, considering the <code>Bomber</code>).</li>
<li><code>GameSession::update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/screens/game_session.cpp#L195"><img src="images/link_12.png" alt="X" /></a>] calls <code>world-&gt;update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/server.cpp#L103"><img src="images/link_12.png" alt="X" /></a>].</li>
<li><code>World::update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/world.cpp#L146"><img src="images/link_12.png" alt="X" /></a>] calls <code>obj-&gt;update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/world.cpp#L183"><img src="images/link_12.png" alt="X" /></a>] for each object in the world.</li>
<li><code>PinguHolder::update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/pingu_holder.cpp#L89"><img src="images/link_12.png" alt="X" /></a>] calls <code>pingu-&gt;update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/pingu_holder.cpp#L95"><img src="images/link_12.png" alt="X" /></a>] for each pingu alive.</li>
<li><code>Pingu::update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/pingu.cpp#L311"><img src="images/link_12.png" alt="X" /></a>] calls <code>action-&gt;update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/pingu.cpp#L339"><img src="images/link_12.png" alt="X" /></a>] for the active pingu action.</li>
<li><code>Bomber::update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/actions/bomber.cpp#L58"><img src="images/link_12.png" alt="X" /></a>] calls <code>sprite.update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/actions/bomber.cpp#L60"><img src="images/link_12.png" alt="X" /></a>]. <code>Sprite::update</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/engine/display/sprite_impl.cpp#L112"><img src="images/link_12.png" alt="X" /></a>] finally updates the animation frame.</li>
</ol>
<p>Each dispatching step in the chain is necessary considering the game architecture:</p>
<ul>
<li>With a single assignment to <code>last_screen</code>, we can easily deactivate the current screen and redirect all dispatches to a new screen.</li>
<li>The <code>World</code> class manages and dispatches events to all game entities, such as all pingus and traps, with a the common interface <code>WorldObj</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/worldobj.hpp#L34"><img src="images/link_12.png" alt="X" /></a>].</li>
<li>Since it is common to iterate only over the pingus (vs. all world objects), the container <code>PinguHolder</code> manages all pingus.</li>
<li>Since a single pingu can change between actions during lifetime, the <code>action</code> member decouples them with another level of indirection.</li>
<li>Sprites are part of the game engine and are reusable everywhere (e.g., UI buttons, world objects, etc.), so it is also convenient to decouple them from actions.</li>
</ul>
<p>The <code>draw</code> callback flows through the same dispatching hierarchy until reaching the <code>Sprite</code> class.</p>
<!-- CEU-BOMBER-SPRITE -->
<h4 id="céu-4">Céu</h4>
<p>In Céu, the <code>Bomber</code> action spawns a <code>Sprite</code> animation instance on its body [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/game/pingu/actions/bomber.ceu"><img src="images/link_12.png" alt="X" /></a>]:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>code</b>/<b>await</b> Bomber (<b>void</b>) -> _ActionName__Enum <b>do</b>
<b><font size="-1" color="#666666"> 2:</font></b>      <...>
<b><font size="-1" color="#666666"> 3:</font></b>      <b>var</b>&? Sprite sprite = <b>spawn</b> Sprite(<...>);
<b><font size="-1" color="#666666"> 4:</font></b>      <...>
<b><font size="-1" color="#666666"> 5:</font></b>  <b>end</b></code></pre>
<p>The <code>Sprite</code> instance (ln. 3) can react directly to external <code>dt</code> [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/engine/display/sprite.ceu#L71"><img src="images/link_12.png" alt="X" /></a>] and <code>redraw</code> [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/engine/display/sprite.ceu#L94"><img src="images/link_12.png" alt="X" /></a>] events (which are analogous to <code>update</code> and <code>redraw</code> callbacks, respectively), bypassing the program hierarchy entirely. While and <em>only while</em> the bomber abstraction is alive, the sprite animation is also alive. The radical decoupling between the program hierarchy and reactions to events eliminates dispatching chains entirely.</p>
<!--
For instance, we removed from the game engine most of the boilerplate related
to event dispatching ([[![X]][TODO]]).

On the other hand, now that organisms themselves decide whether or not to react 
to external input, we support that lexical scopes should control their life 
cycles.

<div class="images">
<img src="images/explo.png" width=""/>
<br>
<a href="images/explo.png">
Figure 12</a>: Explosion sprite for the `Bomber` animation</div>


Just like standard local variables, we can delimit the scope of organisms 
through explicit blocks.
As an example, the explosion sprite for the `Bomber` animation above 
[[![X]](#bomber)] reacts and redraws exactly for one occurrence of 
`WORLD_UPDATE` (after the 13th animation frame):

<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  class Bomber <b>with</b>
<b><font size="-1" color="#666666"> 2:</font></b>      <...>
<b><font size="-1" color="#666666"> 3:</font></b>  <b>do</b>
<b><font size="-1" color="#666666"> 4:</font></b>      <b>var</b> Sprite sprite = Sprite.build_name(<...>);
<b><font size="-1" color="#666666"> 5:</font></b>      <...>
<b><font size="-1" color="#666666"> 6:</font></b>          // 13th frame:
<b><font size="-1" color="#666666"> 7:</font></b>          <b>await</b> WORLD_UPDATE <b>until</b> sprite.get_current_frame() == 13;
<b><font size="-1" color="#666666"> 8:</font></b>          <...>
<b><font size="-1" color="#666666"> 9:</font></b>          <b>do</b>
<b><font size="-1" color="#666666">10:</font></b>              <b>var</b> Sprite _ = Sprite.build_name(<...>, &&explo);
<b><font size="-1" color="#666666">11:</font></b>              <b>await</b> WORLD_UPDATE;
<b><font size="-1" color="#666666">12:</font></b>          <b>end</b>
<b><font size="-1" color="#666666">13:</font></b>          <...>
<b><font size="-1" color="#666666">14:</font></b>  <b>end</b></code></pre>

We enclose the declaration with an explicit block (ln. 9-12) that restricts 
its lifespan to a single occurrence of `WORLD_UPDATE` (ln. 11).
When the block terminates, the organism goes out of scope and its execution 
body aborts automatically, effectively removing it from the screen.
Note here that we never manipulate references to the `Sprite`, which is 
declared anonymous with the placeholder `_`.
In constrast, the animation in C++ requires to explicitly check the state 
variable `gfx_exploded` and forward the `draw` method down to the child sprite 
`explo_surf` [[![X]][cpp_bomber_explo]].
-->
<!-- CEU-vs-CPP-BOMBER-SPRITE -->
<p><a name="dispatching_hierarchies_summary"/> <br/></p>
<div class="summary">
<p><strong>Summary</strong>:</p>
<p>Passive entities subjected to hierarchies require a dispatching architecture that makes the reasoning about the program harder:</p>
<ul>
<li>The full dispatching chain may go through dozens of files. <!--(note that we omitted class hierarchies from the discussion).--></li>
<li>The dispatching chain may interleave between classes specific to the game and also classes from the game engine (possibly third-party classes). <!--
* The actual objects in the hierarchy are often dynamically allocated,
  specially for entities held in class containers.
--></li>
</ul>
<p><strong>How common are Dispatching Hierarchies?</strong></p>
<p>In C++, the update subsystem touches 39 files with around 100 lines of code just to forward <code>update</code> methods through the dispatching hierarchy (e.g., class <code>GroupComponent</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/engine/gui/group_component.cpp#L58"><img src="images/link_12.png" alt="X" /></a>]). For the drawing subsystem, 50 files with around 300 lines of code (e.g., class <code>ArmageddonButton</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/components/action_button.cpp#L42"><img src="images/link_12.png" alt="X" /></a>]). The implementation in C++ also relies on dispatching hierarchy for <code>resize</code> callbacks, touching 12 files with around 100 lines of code (e.g., class <code>StartScreen</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/screens/start_screen.cpp#L249"><img src="images/link_12.png" alt="X" /></a>]).</p>
<p>Most of this code is eliminated in Céu since abstractions can react directly to the environment, not depending on hierarchies spread across multiple files.</p>
<p>Note that dispatching hierarchies cross game engine code, suggesting that most games use this control-flow pattern heavily. In the case of the Pingus engine, we rewrote 9 files from C++ to Céu, reducing them from 515 to 173 LoCs, mostly due to dispatching code removal.</p>
<!--
engine/         173     515     0.34        part that interacts with the game logic

Many of these files mix dispatching with state manipulation,
In Céu, forwarding is eliminated
forwarding disapper, ex...
state disappear but are simplified and moved into the control flow
-->
<!--
    RESIZE
    engine/screen            3
    engine/display          13
    engine/screen_manager    4
    engine/gui_screen        4
    pingus/pingus_menu       9
    pingus/level_menu       10
    pingus/result_screen    12
    pingus/option_menu      21
    pingus/game_session     11
    pingus/story_screen      7
    pingus/start_screen      5
    pingus/worldmap_screen   4
                            ==
                        12  103

    DRAW
    engine/gui_screen        5
    engine/surface_button    9
    engine/group_component   5
    pingus/layer_manager     5-2
    pingus/story_screen      4
    pingus/start_screen      3+3+1
    pingus/pingus_counter    3-2
    pingus/button_panel      8
    pingus/smallmap          1
    pingus/check_box         5
    pingus/menu_button       6
    pingus/choice_box        5
    pingus/action_button     11+9+9
    pingus/pingu_holder      7
    pingus/world             3
    pingus/capture_rectangle 14
    pingus/smoke_partile     11
    pingus/pingu_partile     7
    pingus/pingu             1
    pingus/level_menu        1+7+15+1
    pingus/result_screen     1+1+1
    pingus/worldmap/
        story_dot            3+1
        level_dot           17
        worldmap_screen      2
        worldmap             6
        pingus              16
    actions/
        basher               3
        blocker              3
        boarder              3
        bomber               6
        bridger             12
        climber              3
        digger               3
        drown                3
        exiter               3
        faller               7
        floater              3
        jumper               3
        miner                3
        slider               3
        smashed              3
        splashed             3
        waiter               3
        walker               6
    worldobjs/
        exit                 4
        guillotine          11
        hotspot              3
        entrance             5
        smasher              3
        spike                5
                            ==
                        50  307

    UPDATE
    engine/gui_manager       3
    engine/group_component   7
    engine/screen_manager    2
    engine/gui_screen        4
    pingus/layer_manager     5
    pingus/pingus_menu       3
    pingus/game_session      1+1
    pingus/smallmap          3
    pingus/button_panel      5
    pingus/action_button     1
    pingus/server            4
    pingus/layer_manager     5
    pingus/pingu_holder      1
    pingus/world             3
    pingus/state_sprite      5
    pingus/pingu             1
    worldmap/
        worldmap_scrren      1
        worldmap             5
        pingus              11
    actions/
        basher               1
        blocker              1
        bomber               2
        bridger             10
        climber              1
        digger               1
        drown                1
        exiter               1
        faller               6
        floater              1
        miner                1
        slider               3
        smashed              1
        splashed             1
        waiter               1
        walker               2
    worldobjs/
        exit                 1
        guillotine           3
        hotspot              3
        spike                3
                            ==
                        39  115
-->
</div>
<!--* TODO: efficiency?-->
<p><a name="lifespan-hierarchies"/></p>
<h2 id="lifespan-hierarchies">4) Lifespan Hierarchies</h2>
<p>Entities typically form a lifespan hierarchy in which a terminating container entity automatically destroys its managed children.</p>
<!--
Similarly to *dispatching hierarchies*, some entities control the lifespan of 
other child entities, resulting in dynamic and explicit allocation and 
deallocation of objects.

However, it is actually common to have children with a static lifespan which 
are known at compile time.
-->
<p><a name="lifespan-hierarchies-1"/></p>
<h3 id="game-ui-widgets">4.1) Game UI Widgets</h3>
<!-- CPP-CONTAINER -->
<h4 id="c-5">C++</h4>
<div class="images">
<img src="images/game-session-arrows.png" width="300"/> <br> <a href="images/game-session-arrows.png"> Figure 13</a>: UI children with static lifespan
</div>
<p>In C++, the class <code>GameSession</code> coordinates the UI widgets, such as the buttons, pingus counter, and small map (Figure 13) to coexist with the game screen during its whole lifespan [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/screens/game_session.cpp#L76"><img src="images/link_12.png" alt="X" /></a>]:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  GameSession::GameSession(<...>) :
<b><font size="-1" color="#666666"> 2:</font></b>      <...>
<b><font size="-1" color="#666666"> 3:</font></b>  {
<b><font size="-1" color="#666666"> 4:</font></b>      <...>
<b><font size="-1" color="#666666"> 5:</font></b>      button_panel = <b>new</b> ButtonPanel(<...>);      // these widgets are always active...
<b><font size="-1" color="#666666"> 6:</font></b>      pcounter     = <b>new</b> PingusCounter(<...>);
<b><font size="-1" color="#666666"> 7:</font></b>      small_map    = <b>new</b> SmallMap(<...>);
<b><font size="-1" color="#666666"> 8:</font></b>      <...>
<b><font size="-1" color="#666666"> 9:</font></b>      gui_manager->add(button_panel);             // ...but are added
<b><font size="-1" color="#666666">10:</font></b>      gui_manager->add(pcounter);                 //    dynamically to the
<b><font size="-1" color="#666666">11:</font></b>      gui_manager->add(small_map);                //    dispatching hierarchy
<b><font size="-1" color="#666666">12:</font></b>      <...>
<b><font size="-1" color="#666666">13:</font></b>  }</code></pre>
<p>The widgets are created in the constructor (ln. 5-7), added to a UI container (ln. 9-11), and are never removed since they must always be visible. Arguably, to better express the intent of making them coexist with the game screen, the widgets could be declared as top-level automatic (non-dynamic) members. However, the class uses a container to automate <code>draw</code> and <code>update</code> dispatching to the widgets, as discussed in <a href="#dispatching-hierarchies-1"> Section 3.1</a>. In turn, the container method <code>add</code> expects dynamically allocated children only because they are automatically deallocated inside the container destructor [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/engine/gui/group_component.cpp#L37"><img src="images/link_12.png" alt="X" /></a>].</p>
<p>The dynamic nature of containers in C++ demand extra caution from programmers:</p>
<ul>
<li>When containers are part of a dispatching chain, it gets even harder to know which objects are dispatched: one has to &quot;simulate&quot; the program execution and track calls to <code>add</code> and <code>remove</code>.</li>
<li>For objects with dynamic lifespan, calls to <code>add</code> must always have matching calls to <code>remove</code>: missing calls to <code>remove</code> lead to memory and CPU leaks (to be discussed as the <em>lapsed listener</em> problem further). <!--in SEC_REF[[lifespan-hierarchies-2]]--></li>
</ul>
<!-- CPP-CONTAINER-STATIC -->
<!-- CEU-CONTAINER-STATIC -->
<h4 id="céu-5">Céu</h4>
<p>In Céu, entities that coexist just have to be created in the same lexical block:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>code</b>/<b>await</b> Game (<b>void</b>) <b>do</b>
<b><font size="-1" color="#666666"> 2:</font></b>      <...>                       // other coexisting functionality
<b><font size="-1" color="#666666"> 3:</font></b>      <b>spawn</b> ButtonPanel(<...>);
<b><font size="-1" color="#666666"> 4:</font></b>      <b>spawn</b> PingusCounter(<...>);
<b><font size="-1" color="#666666"> 5:</font></b>      <b>spawn</b> SmallMap(<...>);
<b><font size="-1" color="#666666"> 6:</font></b>      <...>                       // other coexisting functionality
<b><font size="-1" color="#666666"> 7:</font></b>  <b>end</b></code></pre>
<p>Since abstractions can react independently, they do not require a dispatching container.</p>
<p>Lexical lifespan never requires containers, allocation and deallocation, or explicit references. In addition, all required memory is known at compile time, similarly to stack-allocated local variables.</p>
<p>Note that the actual code in the repository [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/game/game.ceu#L198"><img src="images/link_12.png" alt="X" /></a>] is equivalent to the code using abstraction above, but inlines all functionality in parallel since they are instantiated only once:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>par</b> <b>do</b>
<b><font size="-1" color="#666666"> 2:</font></b>      <...>                           // other coexisting funcionality
<b><font size="-1" color="#666666"> 3:</font></b>  <b>with</b>
<b><font size="-1" color="#666666"> 4:</font></b>      #include "button_panel.ceu"     // inlined <b>code</b> for the pannel
<b><font size="-1" color="#666666"> 5:</font></b>  <b>with</b>
<b><font size="-1" color="#666666"> 6:</font></b>      #include "pingus_counter.ceu"   // inlined <b>code</b> for the counter
<b><font size="-1" color="#666666"> 7:</font></b>  <b>with</b>
<b><font size="-1" color="#666666"> 8:</font></b>      #include "small_map.ceu"        // inlined <b>code</b> for the map
<b><font size="-1" color="#666666"> 9:</font></b>  <b>with</b>
<b><font size="-1" color="#666666">10:</font></b>      <...>                           // other coexisting funcionality
<b><font size="-1" color="#666666">11:</font></b>  <b>end</b></code></pre>
<p>The <a href="#bomber_explo"><em>Bomber</em> state machine</a> of <a href="#finite-state-machines-2"> Section 1.2</a> also relies on lexical scope to delimit the lifespan of the explosion sprite to a single frame.</p>
<p><a name="lifespan-hierarchies-2"/></p>
<h3 id="the-pingus-container">4.2) The Pingus Container</h3>
<div class="images">
<img src="images/pingus_create_die-anim.gif" width="400"/> <br> <a href="images/pingus_create_die-anim.gif"> Figure 14</a>: Creation and death of pingus
</div>
<p>A pingu is a dynamic entity created periodically and destroyed under certain conditions, such as falling from a high altitude [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/actions/splashed.cpp#L48"><img src="images/link_12.png" alt="X" /></a>] (Figure 14).</p>
<!-- CPP-CONTAINER-DYNAMIC -->
<h4 id="c-6">C++</h4>
<p>In C++, the class <code>PinguHolder</code> is a container that holds all pingus alive:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  Pingu* PinguHolder::create_pingu (<...>) {
<b><font size="-1" color="#666666"> 2:</font></b>      <...>
<b><font size="-1" color="#666666"> 3:</font></b>      Pingu* pingu = <b>new</b> Pingu (<...>);
<b><font size="-1" color="#666666"> 4:</font></b>      pingus.push_back(pingu);
<b><font size="-1" color="#666666"> 5:</font></b>      <...>
<b><font size="-1" color="#666666"> 6:</font></b>  }
<b><font size="-1" color="#666666"> 7:</font></b>  
<b><font size="-1" color="#666666"> 8:</font></b>  <b>void</b> PinguHolder::update() {
<b><font size="-1" color="#666666"> 9:</font></b>      <...>
<b><font size="-1" color="#666666">10:</font></b>      <b>while</b>(pingu != pingus.end()) {
<b><font size="-1" color="#666666">11:</font></b>          (*pingu)->update();
<b><font size="-1" color="#666666">12:</font></b>          <b>if</b> ((*pingu)->get_status() == Pingu::PS_DEAD) {
<b><font size="-1" color="#666666">13:</font></b>              pingu = pingus.erase(pingu);
<b><font size="-1" color="#666666">14:</font></b>          }
<b><font size="-1" color="#666666">15:</font></b>          <...>
<b><font size="-1" color="#666666">16:</font></b>          ++pingu;
<b><font size="-1" color="#666666">17:</font></b>      }
<b><font size="-1" color="#666666">18:</font></b>  }</code></pre>
<p>The method <code>PinguHolder::create_pingu</code> (ln. 1-6) is called periodically to create a new <code>Pingu</code> and add it to the <code>pingus</code> collection (ln. 3-4). The method <code>PinguHolder::update</code> (ln. 8-18) checks the state of all pingus on every frame, removing those with the dead status (ln. 12-14).</p>
<p>Entities with dynamic lifespan in C++ require explicit <code>add</code> and <code>remove</code> calls associated to a container (ln. 4,13). Without the <code>erase</code> call above, a dead pingu would remain in the collection with updates on every frame (ln. 11). Since the <code>redraw</code> behavior for a dead pingu is innocuous, the death could go unnoticed but the program would keep consuming memory and CPU time. This problem is known as the <em>lapsed listener</em> [<a href="http://gameprogrammingpatterns.com/observer.html#don&#39;t-worry,-i&#39;ve-got-a-gc"><img src="images/link_12.png" alt="X" /></a>] and also occurs in languages with garbage collection: A container typically holds a strong reference to a child (sometimes the only reference to it), and the runtime cannot magically detect it as garbage.</p>
<!-- CEU-CONTAINER-DYNAMIC -->
<h4 id="céu-6">Céu</h4>
<p>Céu supports <code>pool</code> declarations to hold dynamic abstraction instances. Additionally, the <code>spawn</code> statement supports a pool identifier to associate the new instance with a pool.</p>
<p>The game screen spawns a new <code>Pingu</code> on every invocation of <code>Pingu_Spawn</code> [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/game/game.ceu#L163"><img src="images/link_12.png" alt="X" /></a>]:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>code</b>/<b>await</b> Game (<b>void</b>) <b>do</b>
<b><font size="-1" color="#666666"> 2:</font></b>      <...>
<b><font size="-1" color="#666666"> 3:</font></b>      <b>pool</b>[] Pingu pingus;
<b><font size="-1" color="#666666"> 4:</font></b>      <b>code</b>/<b>await</b> Pingu_Spawn (<...>) <b>do</b>
<b><font size="-1" color="#666666"> 5:</font></b>          <...>
<b><font size="-1" color="#666666"> 6:</font></b>          <b>spawn</b> Pingu(<...>) <b>in</b> <b>outer</b>.pingus;
<b><font size="-1" color="#666666"> 7:</font></b>      <b>end</b>
<b><font size="-1" color="#666666"> 8:</font></b>      <...>   // <b>code</b> invoking Pingu_Spawn
<b><font size="-1" color="#666666"> 9:</font></b>  <b>end</b></code></pre>
<p>The <code>spawn</code> statement (ln. 6) specifies the pool declared at the top-level block of the game screen (ln. 3). In this case, the lifespan of the new instances follows the scope of the pool (ln. 1-9) instead of the <code>spawn</code> enclosing scope (ln. 4-7). Since pools are also subject to lexical scope, the lifespan of all dynamically allocated pingus is constrained to the game screen.</p>
<!--
Therefore, if the top-level block of `PinguHolder` goes out of scope 
(ln. 1-9), the execution of all pingus is aborted and they are 
automatically reclaimed from memory.
The same happens if the block containing the instance of `PinguHolder` goes out 
of scope [[![X]][ceu_world_pinguholder]] (and so on, up to the outermost block 
of the program [[![X]][ceu_main_outermost]]).
-->
<div class="images">
<img src="images/pool.png" width="400"/> <br> <a href="images/pool.png"> Figure 15</a>: Lifespan of dynamic instances
</div>
<p>Lexical scopes handle memory and event dispatching automatically for static instances and also for pools. However, the lifespan of a dynamic instance does not necessarily have to match the lifespan of its associated pool (Figure 15). In Céu, when the execution block of a dynamic instance terminates, which characterizes its <em>natural termination</em>, the instance is automatically removed from its pool. Therefore, dynamic instances do not require any extra bookkeeping related to containers or explicit deallocation.</p>
<p>To remove a pingu from the game in Céu, we just need to terminate its execution block according to the appropriate conditions [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/game/pingu/pingu.ceu#L98"><img src="images/link_12.png" alt="X" /></a>]:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>code</b>/<b>await</b> Pingu (<...>) <b>do</b>
<b><font size="-1" color="#666666"> 2:</font></b>      <...>
<b><font size="-1" color="#666666"> 3:</font></b>      <b>loop</b> <b>do</b>
<b><font size="-1" color="#666666"> 4:</font></b>          <b>await</b> <b>outer</b>.game.dt;
<b><font size="-1" color="#666666"> 5:</font></b>          <b>if</b> <b>call</b> Pingu_Rel_Getpixel(0,-1) == {Groundtype::GP_OUTOFSCREEN} <b>then</b>
<b><font size="-1" color="#666666"> 6:</font></b>              <...>
<b><font size="-1" color="#666666"> 7:</font></b>              <b>escape</b> {PS_DEAD};
<b><font size="-1" color="#666666"> 8:</font></b>          <b>end</b>
<b><font size="-1" color="#666666"> 9:</font></b>      <b>end</b>
<b><font size="-1" color="#666666">10:</font></b>  <b>end</b></code></pre>
<p>The <code>escape</code> statement (ln. 7) aborts the execution block of the <code>Pingu</code> instance, removing it from its associated pool automatically. Hence, a dynamic instance that terminates naturally leaves no traces in the program.</p>
<!--
The language ensures, at compile time, that there are no possible dangling 
pointers to organisms (TODO: not discussed here).
Céu distinguishes between *aliases* and *pointers*.
Aliases are similar to C++ references [[![X]][cpp_reference]], while pointers 
are the same as in C and C++.
Aliases respect static scoping rules and can only be bound to variables defined 
on enclosing (wider) scopes.
For this reason, aliases are more restricted but safer than pointers.
Given that the control-flow statements of Céu cross event occurrences, scopes 
tend to last long and aliases are used extensively in programs.

Note that we can safely pass the `pingus` and the anonymous `PinguHolder` 
because they are in the same scope.
[cpp_reference]: https://en.wikipedia.org/wiki/Reference_%28C%2B%2B%29

To complete the previous example, the class `World` also declares a 
`PinguHolder`:

```
class World with
    <...>
do                                  // X4
    <...>
    pool IPingu[] pingus;           // X1
    var PinguHolder _ with          // X2
        this.pingus = &pingus;
        <...>
    end;                            // X3
    <...>
end                                 // X5
class World with
    <...>
do
    <...>
    var CPingusCounter pcounter = <...>;        // always active and
    var ButtonPanel button_panel;               // reacting directly without
    var SmallMap smallmap with                  // a dispatching hierarchy
        <...>
    end;
    <...>
end
```
-->
<p><a name="lifespan_hierarchies_summary"/> <br/></p>
<div class="summary">
<p><strong>Summary</strong>:</p>
<p>Lexical lifespan for static instances and natural termination for dynamic instances provide some advantages in comparison to lifespan hierarchies through containers:</p>
<ul>
<li>Lexical scope makes an abstraction lifespan explicit in the source code.</li>
<li>The memory for static instances is known at compile time.</li>
<li>Natural termination makes an instance innocuous and, hence, susceptible to immediate reclamation.</li>
<li>Abstraction instances (static or dynamic) never require explicit manipulation of pointers/references.</li>
</ul>
<p><strong>How common are Lifespan Hierarchies?</strong></p>
<p>All entities in a game have an associated lifespan.</p>
<p>The implementation in Céu has over 200 static instantiations spread across all 65 files. For dynamic entities, it defines 23 pools in 10 files, with almost 96 instantiations across 37 files. Pools are used to hold explosion particles, levels and level sets from files, gameplay &amp; worldmap objects, and UI widgets.</p>
<!--
await Code: 38
spawn Code: 263
spawn in: 96 uses in 37 files
pool:     23 uses in 10 files
-->
<!--
Overall, passive objects of C++ impose a dispatching architecture that makes 
the reasoning about the program harder:

# case-1
* When containers are part of a dispatching chain, it gets even harder to track 
  what objects are dispatched:
  one has to "simulate" the program execution and track calls to `add` and
  `remove`.
* For objects with dynamic lifespan, calls to `add` must always have matching 
  calls to `remove`:
  missing calls to `remove` lead to memory and CPU leaks (see the *lapsed listener* problem below).
In Céu, entities that coexist with an enclosing class just need to be declared 
at the top-level block [[![X]][ceu_world_top]]:
Again, here we never manipulate references to deal with containers, or 
allocation and deallocation.
Also, all memory required for static instances is known at compile time.

# case-2
-->
</div>
<p><a name="signaling"/></p>
<h2 id="signaling-mechanisms">5) Signaling Mechanisms</h2>
<p>Entities often need to communicate explicitly through signaling mechanisms, especially if there is no hierarchy relationship between them.</p>
<p><a name="signaling_1"/></p>
<h3 id="pausing-the-world">5.1) Pausing the World</h3>
<div class="images">
<img src="images/pause-anim-opt.gif" width="250"/> <br> <a href="images/pause-anim-opt.gif"> Figure 16</a>: Pausing the world.
</div>
<p>A click in the <em>Pause</em> button at the bottom right of the screen pauses all world objects, such as the clouds and pingus, but not other elements, such as the <em>Armageddon</em> button animation (Figure 16). The <em>Pause</em> button is also affected when the player presses <code>P</code> on the keyboard and indicates its state with dark and light backgrounds.</p>
<h4 id="c-7">C++</h4>
<p>In C++, the class <code>PauseButton</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/components/action_button.cpp#L135"><img src="images/link_12.png" alt="X" /></a>] handles mouse clicks to toggle the world pause state which is checked when redrawing the button:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  PauseButton::PauseButton(GameSession s, <...>):
<b><font size="-1" color="#666666"> 2:</font></b>      RectComponent(<...>),
<b><font size="-1" color="#666666"> 3:</font></b>      session(s),
<b><font size="-1" color="#666666"> 4:</font></b>      background("core/buttons/hbuttonbgb"),
<b><font size="-1" color="#666666"> 5:</font></b>      backgroundhl("core/buttons/hbuttonbg"),
<b><font size="-1" color="#666666"> 6:</font></b>      <...>
<b><font size="-1" color="#666666"> 7:</font></b>  {
<b><font size="-1" color="#666666"> 8:</font></b>      <...>
<b><font size="-1" color="#666666"> 9:</font></b>  }
<b><font size="-1" color="#666666">10:</font></b>  
<b><font size="-1" color="#666666">11:</font></b>  <b>void</b> PauseButton::on_click (<...>) {
<b><font size="-1" color="#666666">12:</font></b>      session->set_pause(!session->get_pause());
<b><font size="-1" color="#666666">13:</font></b>  }
<b><font size="-1" color="#666666">14:</font></b>  
<b><font size="-1" color="#666666">15:</font></b>  <b>void</b> PauseButton::draw (<...>) {
<b><font size="-1" color="#666666">16:</font></b>      <...>
<b><font size="-1" color="#666666">17:</font></b>      <b>if</b> (session->get_pause()) {
<b><font size="-1" color="#666666">18:</font></b>          gc.draw(backgroundhl, <...>);
<b><font size="-1" color="#666666">19:</font></b>      } <b>else</b> {
<b><font size="-1" color="#666666">20:</font></b>          gc.draw(background, <...>);
<b><font size="-1" color="#666666">21:</font></b>      }
<b><font size="-1" color="#666666">22:</font></b>      <...>
<b><font size="-1" color="#666666">23:</font></b>  }</code></pre>
<p>The mouse callback <code>on_click</code> (ln. 11-13) toggles the pause state. Depending on the current state, the method <code>draw</code> (ln. 15-23) chooses the appropriate background sprite loaded in the class constructor (ln. 4-5).</p>
<p>The class <code>GameSession</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/screens/game_session.cpp#L159"><img src="images/link_12.png" alt="X" /></a>] handles keyboard presses and applies the pause state to the world:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>void</b> GameSession::on_pause_press () {
<b><font size="-1" color="#666666"> 2:</font></b>      set_pause(!get_pause());
<b><font size="-1" color="#666666"> 3:</font></b>  }
<b><font size="-1" color="#666666"> 4:</font></b>  
<b><font size="-1" color="#666666"> 5:</font></b>  <b>void</b> GameSession::update_server (<...>) {
<b><font size="-1" color="#666666"> 6:</font></b>      <...>
<b><font size="-1" color="#666666"> 7:</font></b>      <b>if</b> (!get_pause()) {
<b><font size="-1" color="#666666"> 8:</font></b>          <...>
<b><font size="-1" color="#666666"> 9:</font></b>          server->update();
<b><font size="-1" color="#666666">10:</font></b>      }
<b><font size="-1" color="#666666">11:</font></b>      <...>
<b><font size="-1" color="#666666">12:</font></b>  }</code></pre>
<p>The call to the world <code>update</code> (ln. 9) only applies if the world is not paused (ln. 7). Since <code>update</code> methods propagate throughout the world hierarchy, skipping the call to the root method effectively pauses the world.</p>
<h4 id="céu-7">Céu</h4>
<p>As discussed in <a href="#dispatching-hierarchies-1"> Section 3.1</a>, entities in Céu do not update through dispatching hierarchies, but instead react directly to events. This way, the pausing technique applied in C++ is not effective in Céu.</p>
<p>In Céu, the <em>Pause</em> button communicates with the rest of the application through the event <code>go_pause_toggle</code> [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/game/input.ceu#L162"><img src="images/link_12.png" alt="X" /></a>]:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <...>
<b><font size="-1" color="#666666"> 2:</font></b>  <b>var</b>& RectComponent c = <b>spawn</b> RectComponent(<...>);
<b><font size="-1" color="#666666"> 3:</font></b>  <b>spawn</b> <b>do</b>
<b><font size="-1" color="#666666"> 4:</font></b>      <b>loop</b> <b>do</b>
<b><font size="-1" color="#666666"> 5:</font></b>          <b>watching</b> go_pause_toggle <b>do</b>
<b><font size="-1" color="#666666"> 6:</font></b>              <b>spawn</b> Sprite(<...>, "core/buttons/hbuttonbgb");
<b><font size="-1" color="#666666"> 7:</font></b>              <b>await</b> c.component.on_click;
<b><font size="-1" color="#666666"> 8:</font></b>              <b>emit</b> go_pause_toggle;
<b><font size="-1" color="#666666"> 9:</font></b>          <b>end</b>
<b><font size="-1" color="#666666">10:</font></b>          <b>watching</b> go_pause_toggle <b>do</b>
<b><font size="-1" color="#666666">11:</font></b>              <b>spawn</b> Sprite(<...>, "core/buttons/hbuttonbg");
<b><font size="-1" color="#666666">12:</font></b>              <b>await</b> c.component.on_click;
<b><font size="-1" color="#666666">13:</font></b>              <b>emit</b> go_pause_toggle;
<b><font size="-1" color="#666666">14:</font></b>          <b>end</b>
<b><font size="-1" color="#666666">15:</font></b>      <b>end</b>
<b><font size="-1" color="#666666">16:</font></b>  <b>end</b>
<b><font size="-1" color="#666666">17:</font></b>  <...></code></pre>
<p>The button toggles between showing the dark (ln. 10-14) and light (ln. 5-9) background sprites based on their lexical scope. The background changes when the button is clicked (ln. 7,12) or when <code>go_pause_toggle</code> is emitted from a keyboard press (ln. 5,10). The button also broadcasts <code>go_pause_toggle</code> whenever it is clicked (ln. 8,13).</p>
<p>The pausing mechanism relies on two update events, <code>game.dt</code> for the game world, and <code>main.dt</code> for the rest of the application [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/game/input.ceu#L17"><img src="images/link_12.png" alt="X" /></a>]:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>event</b> <b>void</b> go_pause_toggle;
<b><font size="-1" color="#666666"> 2:</font></b>  <...>
<b><font size="-1" color="#666666"> 3:</font></b>  <b>spawn</b> <b>do</b>
<b><font size="-1" color="#666666"> 4:</font></b>      <b>var</b> <b>bool</b> is_paused = <b>false</b>;
<b><font size="-1" color="#666666"> 5:</font></b>      <b>par</b> <b>do</b>
<b><font size="-1" color="#666666"> 6:</font></b>          <b>every</b> go_pause_toggle <b>do</b>
<b><font size="-1" color="#666666"> 7:</font></b>              is_paused = <b>not</b> is_paused;
<b><font size="-1" color="#666666"> 8:</font></b>          <b>end</b>
<b><font size="-1" color="#666666"> 9:</font></b>      <b>with</b>
<b><font size="-1" color="#666666">10:</font></b>          <b>every</b> <b>outer</b>.main.dt <b>do</b>
<b><font size="-1" color="#666666">11:</font></b>              <...>
<b><font size="-1" color="#666666">12:</font></b>              <b>if</b> <b>not</b> is_paused <b>then</b>
<b><font size="-1" color="#666666">13:</font></b>                  <b>emit</b> <b>outer</b>.game.dt(<...>);
<b><font size="-1" color="#666666">14:</font></b>              <b>end</b>
<b><font size="-1" color="#666666">15:</font></b>          <b>end</b>
<b><font size="-1" color="#666666">16:</font></b>          <...>
<b><font size="-1" color="#666666">17:</font></b>      <b>end</b>
<b><font size="-1" color="#666666">18:</font></b>  <b>end</b>
<b><font size="-1" color="#666666">19:</font></b>  <...></code></pre>
<p>Whenever <code>go_pause_toggle</code> is emitted, the local state variable <code>is_paused</code> is toggled (ln. 6-8). Also, whenever <code>main.dt</code> occurs (ln. 10-15), the event <code>game.dt</code> is emitted only if the world is not paused (ln. 12-14).</p>
<p>World entities are set to react to <code>game.dt</code>, while all other entities are set to react to <code>main.dt</code>. Since all world entities are <code>Sprite</code> instances, the abstraction interface receives its update event as a reference [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/engine/display/sprite.ceu#L20"><img src="images/link_12.png" alt="X" /></a>]. On creation, world and non-world sprites pass distinct events, e.g.:</p>
<ul>
<li>The <em>Bomber</em> action uses <code>game.dt</code> [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/game/pingu/actions/bomber.ceu#L22"><img src="images/link_12.png" alt="X" /></a>], since it is a world entity.</li>
<li>The <em>Armageddon</em> button uses <code>main.dt</code> [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/game/input.ceu#L117"><img src="images/link_12.png" alt="X" /></a>], since it should not pause together with the world entities.</li>
</ul>
<p>This technique contrasts with the implementation in C++, which prevents the <code>update</code> dispatching chain to flow from the world &quot;root&quot; towards the sprite &quot;leaves&quot;. In Céu, the sprite &quot;leaves&quot; execute detached from a hierarchy, but do not update because the event of interest is never generated in the paused state.</p>
<p><a name="signaling_2"/></p>
<h3 id="global-keys-and-the-options-menu">5.2) Global Keys and the Options Menu</h3>
<div class="images">
<img src="images/options-anim-opt.gif" width="350"/> <br> <a href="images/options-anim-opt.gif"> Figure 17</a>: The <em>Mouse Grab</em> configuration option.
</div>
<p>The <em>Mouse Grab</em> option restricts the mouse movement to the game window boundaries (Figure 17). The option can be set anywhere in the game by pressing <em>Ctrl-G</em>. In addition, the <em>Options</em> menu has a check box to toggle the <em>Mouse Grab</em> option with mouse clicks while still responding to <em>Ctrl-G</em> presses.</p>
<div class="images">
<img src="images/events.png" width="450"/> <br> <a href="images/events.png"> Figure 18</a>: Mutual dependecy between signals.
</div>
<p>The implementations in C++ and Céu use a signalling mechanism to connect the key presses, the check box, and a configuration manager that applies the appropriate side effects in the game (i.e., restrict the mouse movement). Figure 18 illustrates how the mutual notifications create a dependency cycle between the configuration manager and the check box.</p>
<!-- CPP-GRAB -->
<h4 id="c-8">C++</h4>
<p>In C++, the class <code>GlobalEvent</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/global_event.cpp#L34"><img src="images/link_12.png" alt="X" /></a>] detects <em>Ctrl-G</em> presses and invokes the callback <code>config_manager.set_mouse_grab</code>:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>void</b> GlobalEvent::on_button_press (<...>) {
<b><font size="-1" color="#666666"> 2:</font></b>      <...>
<b><font size="-1" color="#666666"> 3:</font></b>      <b>switch</b> (event.keysym.sym) {
<b><font size="-1" color="#666666"> 4:</font></b>          <b>case</b> SDLK_g:
<b><font size="-1" color="#666666"> 5:</font></b>              <b>if</b> (keystate[SDLK_LCTRL] || keystate[SDLK_RCTRL]) {
<b><font size="-1" color="#666666"> 6:</font></b>                  config_manager.set_mouse_grab(
<b><font size="-1" color="#666666"> 7:</font></b>                      !config_manager.get_mouse_grab());
<b><font size="-1" color="#666666"> 8:</font></b>              }
<b><font size="-1" color="#666666"> 9:</font></b>              <b>break</b>;
<b><font size="-1" color="#666666">10:</font></b>          <...>
<b><font size="-1" color="#666666">11:</font></b>      }
<b><font size="-1" color="#666666">12:</font></b>  }</code></pre>
<p><a name="cpp_config-manager"/></p>
<p>The class <code>ConfigManager</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/config_manager.cpp#L182"><img src="images/link_12.png" alt="X" /></a>] uses a <code>boost::signal</code> [<a href="http://www.boost.org/doc/libs/1_60_0/doc/html/signals2.html"><img src="images/link_12.png" alt="X" /></a>] to notify the application when the new configuration is applied:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  boost::signals2::signal<<b>void</b>(<b>bool</b>)> on_mouse_grab_change;   // definition in `config_manager.h`
<b><font size="-1" color="#666666"> 2:</font></b>  
<b><font size="-1" color="#666666"> 3:</font></b>  <b>void</b> ConfigManager::set_mouse_grab (<b>bool</b> v) {
<b><font size="-1" color="#666666"> 4:</font></b>      <...>
<b><font size="-1" color="#666666"> 5:</font></b>      <b>if</b> (v != get_mouse_grab()) {
<b><font size="-1" color="#666666"> 6:</font></b>          <...>   // the actual "grab" effect
<b><font size="-1" color="#666666"> 7:</font></b>          on_mouse_grab_change(v);
<b><font size="-1" color="#666666"> 8:</font></b>      }
<b><font size="-1" color="#666666"> 9:</font></b>  }</code></pre>
<p>The <code>if</code> enclosing the signal emission (ln. 5-8) breaks the dependency cycle of Figure 18 and prevents an infinite execution loop.</p>
<p>The class <code>CheckBox</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/components/check_box.cpp"><img src="images/link_12.png" alt="X" /></a>] also uses a <code>boost::signal</code> to notify the application on changes:</p>
<p><a name="cpp_check-box"/></p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  boost::signals2::signal<<b>void</b> (<b>bool</b>)> on_change;   // definition in `check_box.hpp`
<b><font size="-1" color="#666666"> 2:</font></b>  
<b><font size="-1" color="#666666"> 3:</font></b>  <b>void</b> CheckBox::set_state (<b>bool</b> is_on, <b>bool</b> send_signal) {
<b><font size="-1" color="#666666"> 4:</font></b>      <...>   // switches the check box state
<b><font size="-1" color="#666666"> 5:</font></b>      <b>if</b> (send_signal) {
<b><font size="-1" color="#666666"> 6:</font></b>          on_change(is_on);
<b><font size="-1" color="#666666"> 7:</font></b>      }
<b><font size="-1" color="#666666"> 8:</font></b>  }</code></pre>
<p>Again, the <code>if</code> enclosing the signal emission (ln. 5-7) breaks the dependency cycle of Figure 18 to avoid infinite execution.</p>
<p>The class <code>OptionMenu</code> [<a href="https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/pingus/screens/option_menu.cpp#L79"><img src="images/link_12.png" alt="X" /></a>] creates the dependency loop by connecting the two signals:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>typedef</b> std::vector&lt;boost::signals2::connection&gt; Connections;   // definition in `option_menu.hpp`
<b><font size="-1" color="#666666"> 2:</font></b>  Connections connections;                                        // definition in `option_menu.hpp`
<b><font size="-1" color="#666666"> 3:</font></b>  
<b><font size="-1" color="#666666"> 4:</font></b>  OptionMenu::OptionMenu() :
<b><font size="-1" color="#666666"> 5:</font></b>      connections(),
<b><font size="-1" color="#666666"> 6:</font></b>      mousegrab_box(),
<b><font size="-1" color="#666666"> 7:</font></b>      <...>
<b><font size="-1" color="#666666"> 8:</font></b>  {
<b><font size="-1" color="#666666"> 9:</font></b>      mousegrab_box = <b>new</b> CheckBox(<...>);
<b><font size="-1" color="#666666">10:</font></b>      connections.push_back(
<b><font size="-1" color="#666666">11:</font></b>          config_manager.on_mouse_grab_change.connect(
<b><font size="-1" color="#666666">12:</font></b>              std::bind(&CheckBox::set_state, mousegrab_box, <...>, <b>false</b>);
<b><font size="-1" color="#666666">13:</font></b>          )
<b><font size="-1" color="#666666">14:</font></b>      );
<b><font size="-1" color="#666666">15:</font></b>      connections.push_back(
<b><font size="-1" color="#666666">16:</font></b>          mousegrab_box->on_change.connect(
<b><font size="-1" color="#666666">17:</font></b>              std::bind(&ConfigManager::set_mouse_grab, &config_manager, <...>);
<b><font size="-1" color="#666666">18:</font></b>          )
<b><font size="-1" color="#666666">19:</font></b>      );
<b><font size="-1" color="#666666">20:</font></b>      <...>
<b><font size="-1" color="#666666">21:</font></b>  
<b><font size="-1" color="#666666">22:</font></b>  }
<b><font size="-1" color="#666666">23:</font></b>  
<b><font size="-1" color="#666666">24:</font></b>  OptionMenu::~OptionMenu() {
<b><font size="-1" color="#666666">25:</font></b>      <b>for</b> (Connections::iterator i=connections.begin(); i!=connections.end(); ++i) {
<b><font size="-1" color="#666666">26:</font></b>          (*i).disconnect();
<b><font size="-1" color="#666666">27:</font></b>      }
<b><font size="-1" color="#666666">28:</font></b>  }</code></pre>
<p>The constructor binds the signal <code>config_manager.on_mouse_grab_change</code> to the callback method <code>mousegrab_box-&gt;set_state</code> (ln. 10-14), and also the signal <code>mousegrab_box-&gt;on_change</code> to the callback method <code>config_manager.set_mouse_grab</code> (ln. 15-19). This way, every time the <code>ConfigManager</code> signals <code>on_mouse_grab_change</code> (<code>ConfigManager</code>, ln. 7 <a href="#cpp_config-manager">up</a>), <code>set_state</code> is implicitly called. The same happens between the signal <code>on_change</code> in the <code>CheckBox</code> and the method <code>set_mouse_grab</code> in the <code>ConfigManager</code> (<code>ConfigManager</code>, ln. 3 <a href="#cpp_config-manager">up</a>).</p>
<p>Note that the signal binding to call <code>CheckBox::set_state</code> (ln. 12) receives a fixed value <code>false</code> as the last argument to prevent infinite execution (<code>CheckBox</code>, ln. 3 <a href="#cpp_check-box">up</a>).</p>
<p>The destructor (ln. 24-28) breaks the connections explicitly when the <em>Option</em> screen terminates.</p>
<!-- CEU-GRAB -->
<h4 id="céu-8">Céu</h4>
<p>In Céu, a <em>Ctrl-G</em> key press broadcasts the internal event <code>config_manager.go_mouse_grab</code> to the application [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/global_event.ceu"><img src="images/link_12.png" alt="X" /></a>]:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>spawn</b> <b>do</b>
<b><font size="-1" color="#666666"> 2:</font></b>      <b>var</b> _SDL_KeyboardEvent&& e;
<b><font size="-1" color="#666666"> 3:</font></b>      <b>every</b> e <b>in</b> SDL_KEYDOWN <b>do</b>
<b><font size="-1" color="#666666"> 4:</font></b>          <b>var</b> _u8&& keystate = _SDL_GetKeyState(null);
<b><font size="-1" color="#666666"> 5:</font></b>          <...>
<b><font size="-1" color="#666666"> 6:</font></b>          <b>if</b> e:keysym.sym == {SDLK_g} <b>then</b>
<b><font size="-1" color="#666666"> 7:</font></b>              <b>if</b> ((keystate[{SDLK_LCTRL}] <b>as</b> <b>bool</b>) <b>or</b> (keystate[{SDLK_RCTRL}] <b>as</b> <b>bool</b>)) <b>then</b>
<b><font size="-1" color="#666666"> 8:</font></b>                  <b>emit</b> config_manager.go_mouse_grab(
<b><font size="-1" color="#666666"> 9:</font></b>                          <b>not</b> ({config_manager.get_mouse_grab()} <b>as</b> <b>bool</b>));
<b><font size="-1" color="#666666">10:</font></b>              <b>end</b>
<b><font size="-1" color="#666666">11:</font></b>          <b>end</b>
<b><font size="-1" color="#666666">12:</font></b>          <...>
<b><font size="-1" color="#666666">13:</font></b>      <b>end</b>
<b><font size="-1" color="#666666">14:</font></b>  <b>end</b></code></pre>
<p>The configuration manager [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/config_manager.ceu#L4"><img src="images/link_12.png" alt="X" /></a>] just needs to react to <code>go_mouse_grab</code> continuously to perform the <em>grab</em> effect:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>data</b> ConfigManager <b>with</b>
<b><font size="-1" color="#666666"> 2:</font></b>      <b>event</b> <b>bool</b> go_mouse_grab;
<b><font size="-1" color="#666666"> 3:</font></b>  <b>end</b>
<b><font size="-1" color="#666666"> 4:</font></b>  <b>var</b> ConfigManager config_manager = val ConfigManager(_);
<b><font size="-1" color="#666666"> 5:</font></b>  
<b><font size="-1" color="#666666"> 6:</font></b>  <b>spawn</b> <b>do</b>
<b><font size="-1" color="#666666"> 7:</font></b>      <b>var</b> <b>bool</b> v;
<b><font size="-1" color="#666666"> 8:</font></b>      <b>every</b> v <b>in</b> config_manager.go_mouse_grab <b>do</b>
<b><font size="-1" color="#666666"> 9:</font></b>          <...>   // the actual "grab" effect
<b><font size="-1" color="#666666">10:</font></b>      <b>end</b>
<b><font size="-1" color="#666666">11:</font></b>  <b>end</b></code></pre>
<p>The <code>CheckBox</code> [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/options/check_box.ceu"><img src="images/link_12.png" alt="X" /></a>] exposes the event <code>go_click</code> for notifications in both directions, i.e., from the abstraction to the application and <em>vice versa</em>:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>data</b> ICheckBox <b>with</b>
<b><font size="-1" color="#666666"> 2:</font></b>      <b>var</b>   <b>bool</b> is_on;
<b><font size="-1" color="#666666"> 3:</font></b>      <b>event</b> <b>bool</b> go_click;
<b><font size="-1" color="#666666"> 4:</font></b>  <b>end</b>
<b><font size="-1" color="#666666"> 5:</font></b>  
<b><font size="-1" color="#666666"> 6:</font></b>  <b>code</b>/<b>await</b> CheckBox (<...>) -> (<b>var</b> ICheckBox checkbox) -> FOREVER <b>do</b>
<b><font size="-1" color="#666666"> 7:</font></b>      checkbox = val ICheckBox(<...>);
<b><font size="-1" color="#666666"> 8:</font></b>      <...>
<b><font size="-1" color="#666666"> 9:</font></b>      <b>par</b> <b>do</b>
<b><font size="-1" color="#666666">10:</font></b>          <b>every</b> c.component.on_click <b>do</b>
<b><font size="-1" color="#666666">11:</font></b>              <b>emit</b> checkbox.go_click(<b>not</b> checkbox.is_on);
<b><font size="-1" color="#666666">12:</font></b>          <b>end</b>
<b><font size="-1" color="#666666">13:</font></b>      <b>with</b>
<b><font size="-1" color="#666666">14:</font></b>          <b>loop</b> <b>do</b>
<b><font size="-1" color="#666666">15:</font></b>              <...>   // switches the check box state
<b><font size="-1" color="#666666">16:</font></b>              checkbox.is_on = <b>await</b> checkbox.go_click;
<b><font size="-1" color="#666666">17:</font></b>          <b>end</b>
<b><font size="-1" color="#666666">18:</font></b>      <b>end</b>
<b><font size="-1" color="#666666">19:</font></b>  <b>end</b></code></pre>
<p>The abstraction reacts to external clicks continuously (ln. 10-12) to broadcast the event <code>go_click</code> (ln. 11). It also reacts continuously to <code>go_click</code> in another line of execution (ln. 14-17), which awakes from notifications from the first line of execution or from the application.</p>
<p>The <code>OptionMenu</code> [<a href="https://github.com/fsantanna/pingus/blob/ceu/ceu/pingus/screens/options/options.ceu#L23"><img src="images/link_12.png" alt="X" /></a>] connects the two events as follows:</p>
<pre><code><b><font size="-1" color="#666666"> 1:</font></b>  <b>code</b>/<b>await</b> OptionMenu <...> <b>do</b>
<b><font size="-1" color="#666666"> 2:</font></b>      <...>
<b><font size="-1" color="#666666"> 3:</font></b>      <b>var</b>& CheckBox b2 = <...>;
<b><font size="-1" color="#666666"> 4:</font></b>      <b>spawn</b> <b>do</b>
<b><font size="-1" color="#666666"> 5:</font></b>          <b>par</b> <b>do</b>
<b><font size="-1" color="#666666"> 6:</font></b>              <b>var</b> <b>bool</b> v;
<b><font size="-1" color="#666666"> 7:</font></b>              <b>every</b> v <b>in</b> <b>outer</b>.config_manager.go_mouse_grab <b>do</b>
<b><font size="-1" color="#666666"> 8:</font></b>                  <b>emit</b> b2.checkbox.go_click(v);
<b><font size="-1" color="#666666"> 9:</font></b>              <b>end</b>
<b><font size="-1" color="#666666">10:</font></b>          <b>with</b>
<b><font size="-1" color="#666666">11:</font></b>              <b>var</b> <b>bool</b> v;
<b><font size="-1" color="#666666">12:</font></b>              <b>every</b> v <b>in</b> b2.checkbox.go_click <b>do</b>
<b><font size="-1" color="#666666">13:</font></b>                  <b>emit</b> <b>outer</b>.config_manager.go_mouse_grab(v);
<b><font size="-1" color="#666666">14:</font></b>              <b>end</b>
<b><font size="-1" color="#666666">15:</font></b>          <b>end</b>
<b><font size="-1" color="#666666">16:</font></b>      <b>end</b>
<b><font size="-1" color="#666666">17:</font></b>      <...>
<b><font size="-1" color="#666666">18:</font></b>  <b>end</b></code></pre>
<p>The two loops in parallel handle the connections in opposite directions: from the configuration manager to the check box (ln. 7-9); and from the check box to the configuration manager (ln. 12-14).</p>
<p>When the <em>Option</em> screen terminates, the connections break automatically since the body is automatically aborted.</p>
<p>Note that the implementation in Céu does not check event emits to break the dependency cycle and prevent infinite execution. Due to the <a href="http://fsantanna.github.io/ceu/out/manual/v0.20/#internal-reactions">stack-based execution for internal events</a> in Céu, programs with mutually-dependent events do not create infinite execution loops.</p>
<p><a name="signaling-summary"/> <br/></p>
<div class="summary">
<p><strong>Summary</strong>:</p>
<p>First-class internal events of Céu provide some advantages in comparison to Boost signals:</p>
<ul>
<li>They use the same convenient syntax of external events (e.g., <code>emit</code>, <code>await</code>, <code>every</code>, etc.).</li>
<li>They never create infinite dependency loops.</li>
<li>They do not require explicit unbinding.</li>
</ul>
<p><strong>How common are Signalling Mechanisms?</strong></p>
<p>The implementation in Céu uses 39 events for internal communication defined in 23 files with over 200 invocations of <code>emit</code> and <code>await</code> spread in over 50 files.</p>
<p>Internal events are used for resizing entities, broadcasting update and draw requests, pausing parts of the game, triggering new pingu actions, signalling collisions, signalling UI interactions, among many others cases.</p>
</div>
<!--
<a name="wall-clock-timers"/>

SEC[[
## Wall-Clock Timers
]]

5. **Wall-Clock Timers**
    Wall-clock timers measure the passage of time from the real world
    (e.g., *10 seconds*) such as for periodic sampling and timeout watchdogs.

    The double click behavior above uses a timeout of 1 second to restart.

<a name="wall-clock-timers-summary"/>
<br/>

<div class="summary">
**Summary**:
</div>

<a name="pausing"/>

SEC[[
## Pausing
]]

6. **Pausing**
    Pausing allows parts of the game to temporarily suspend execution or
    reactions to incoming events.

    In Pingus, the player can press a button in the screen to toggle between 
    pause and resume.

<a name="pausing-summary"/>
<br/>

<div class="summary">
**Summary**:
</div>

<a name="resource-acquisition-and-release"/>

SEC[[
## Resource Acquisition and Release
]]

7. **Resource Acquisition and Release**
    External resources, such as configuration files and saved games,
    must be acquired and properly released.

    TODO

<a name="resource-acquisition-and-release-summary"/>
<br/>

<div class="summary">
**Summary**:
</div>

# Quantitative Analysis

## Code Size

## Memory

## CPU
-->
<!-- ************************************ -->
<!--

- tracking: follow the source code
    - execution order, redraw, sort
- composition over inheritance
- no dynamic allocation or GC
- static reasoning
- no hier b/c orgs can react directly to the env
    - lexical scope

## The Game Loop

The *game loop* determines the general structure of virtually all games 
[[![X]][gpp_gameloop]] (Pingus is no different [[![X]][pingus-gameloop]]):

```
while (true)
{
    processInput();
    update();
    render();
}
```

> A game loop runs continuously during gameplay.
> Each turn of the loop, it processes user input without blocking, updates the 
> game state, and renders the game.
> It tracks the passage of time to control the rate of gameplay.

The `update` function does the hard work, dealing with the state of all game 
entities, and has to execute as fast as possible to keep real-time 
responsiveness to input events.
However, short-lived functions such as `update` do not retain local variables 
and control-flow state across consecutive invocations.
In this sense, they eliminate any vestige of structured programming, becoming 
*our generation's goto* [[![X]][goto]].

[gpp_gameloop]: http://gameprogrammingpatterns.com/game-loop.html
[pingus_gameloop]: https://github.com/Pingus/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/engine/screen/screen_manager.cpp#L172
[goto]: http://tirania.org/blog/archive/2013/Aug-15.html


## The Synchronous Concurrency Model

```
    initialize state;
    while (true) do
        read inputs;
        update state;
        write outputs;
    end
```

The game loop:
`ScreenManager::display`
https://github.com/fsantanna/pingus/blob/7b255840c201d028fd6b19a2185ccf7df3a2cd6e/src/engine/screen/screen_manager.cpp#L164

```
void ScreenManager::display() {
    Uint32 old = SDL_GetTicks();

    while (!screens.empty()) {
        // READ INPUTS
        Uint32 now = SDL_GetTicks();
        Uint32 delta = now - old;
        old = now;
        <read-other-inputs>

        // UPDATE STATE
        screens.back()->update(delta);
        <update-other-inputs>

        // WRITE OUTPUTS
        screens.back()->draw(<...>);
        Display::flip_display();
    }
}
```

## Céu

- control
    = Accidental complexity
- not pure functions

- end of document
    - GC, why gcc doesn't solve: lapsed listeners
        - static mem, orgs, aliases, lexical scope
    - GC also doesn't solve resources:
Garbage collecting resources (file handles, etc):

This is a very different question, because resource freeing has observable 
consequences beyond performance and memory consumption - unlike garbage 
collection, which is justified by the realization that if you do not have any 
pointers to a value in memory, then it can simply dissapear (or not) without 
observable consequences.

For example, if you have a file handle open for writing, then other applications can't open that file. You want such resource usage to be clear and deterministic, so that files do not just remain open for a random duration depending on the garbage collector's internals.

In general, I would not advocate garbage collection of OS resources or any other thing requiring explicit cleanup. For example, I think that Java/C# finalizers are a misguided idea, because they have observable, nondeterministic consequences. That is exactly the sort of feature a high-level, secure language should avoid. The bizarre finalization state diagrams for those languages should be enough to indicate that something is wrong here!

For resource freeing, constructs which guarantee that every resource is freed look promising (think of wrapping a file handle in an abstraction like a Haskell State monad). Or just plain old handles with explicit closing (and thus the risk of not closing a handle, closing it when it's not open, etc).

Garbage collection without type information?

C++ garbage collection would greatly benefit if it was assisted by the compiler. During a scan, only pointers to objects need to be scanned. Unfortunately, it is not possible without assistance from the compiler. That is the reason third-party solutions are not good enough for performance-intensive applications.

Memory management and resource management is not the same. Resources other than memory are usually few in a program and not interconnected. A program may have files, sockets, windows and other types of handles, but usually these handles are 'dead ends', i.e. they do not contain references to other handles. Memory, on the other hand, is a totally different beast: a block of memory usually contains references to other blocks of memory. So the idea of finalizers is a bad one, since resources other than memory should be freed by RAII techniques (for deterministic resource management), but memory should be handled by garbage collector.

I will say it again, because no one seemed to notice it: could it be that there exists a "calculus" for resource management?
By Achilleas Margaritis at Fri, 2006-02-03 11:46 | login or register to post comment

## Idioms

All patterns relate to event handling and control flow in games, and we argue 
how Céu offers more appropriate abstractions than existing languages.

### State Machines

    At any time, the program can only be in a single state, which globally and 
    univocally represents the current XXX.
    This unique and global view of the program state as a single value has 
maintenance scalability problems (AKA the *state explosion phenomena*).
    - state machines vs await
    The more XXX, the more states to track, state explosion.
    The machine transits from state to state

Map the whole behavior into a single number is a problem.
    - hierarchical machines can help, but still has this mapping property
        - locally unscallabe
        - still a data sultion to a control problem
        - explicit state machines vs implicit
        - incremental implementation requires global changes
            - in ceu, its just compositions

### Wall-Clock Timers
    - wall-clock time
        - story chars
        - credits up
        - fps
Activities that involve reactions to \emph{wall-clock time}%
\footnote{
By wall-clock time we mean the passage of time from the real world, measured in 
hours, minutes, etc.
}
appear in typical patterns of embedded development, such as timeout watchdogs 
and sensor samplings.
However, support for wall-clock time is somewhat low-level in existing 
languages, usually through timer callbacks or ``sleep'' blocking calls.

### Pausing
    - pause
        - alternative is again hierarchies which enable/disable forwarding
    - problem with timer callbacks

# Evaluation

- DOC: two main points:
    = WHY
        - state machines
        - C libraries
        - static memory
        - control safety
    = BOUNS: Lua
-->
<hr />
<h2 id="conclusion-1">Conclusion</h2>
<p>We promote the <em>structured synchronous reactive</em> programming model of Céu for the development of games. We present 9 in-depth use cases apllied to <em>Pingus</em> (an open-source <em>Lemmings</em> clone), categorized in 5 control-flow patterns that likely apply to other games.</p>
<p>We show how the standard way to program games with objects and callbacks in C++ hinders structured programming techniques, such as support for sequential execution, long-lasting loops, and persisting local variables. In this sense, callbacks actually disrupt structured programming, becoming <a href="http://tirania.org/blog/archive/2013/Aug-15.html">&quot;our generation’s goto&quot;</a> according to Miguel de Icaza.</p>
<p>Overall, we believe that most difficulties in implementing control behavior in game logic is not inherent to this domain, but a result of accidental complexity due to the lack of structured abstractions and an appropriate concurrency model to handle event-based applications.</p>
<hr />
<h2 id="author-1">Author</h2>
<p>Francisco Sant'Anna</p>
<ul>
<li><a href="http://www.ceu-lang.org/chico/" class="uri">http://www.ceu-lang.org/chico/</a></li>
<li><a href="https://github.com/fsantanna/" class="uri">https://github.com/fsantanna/</a></li>
<li><a href="https://twitter.com/_fsantanna/">@_fsantanna</a></li>
</ul>
<h3 id="acknowledgments">Acknowledgments</h3>
<p><a href="https://github.com/leokaplan/">Leonardo Kaplan</a> and <a href="https://github.com/Tkachov/">Alexander Tkachov</a> for early explorations and prototypes.</p>
